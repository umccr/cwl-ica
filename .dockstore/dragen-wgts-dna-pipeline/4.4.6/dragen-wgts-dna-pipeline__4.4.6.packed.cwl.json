{
  "$graph": [
    {
      "class": "ExpressionTool",
      "requirements": [
        {
          "class": "InlineJavascriptRequirement"
        },
        {
          "types": [
            {
              "type": "record",
              "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options",
              "fields": [
                {
                  "label": "aln_min_score",
                  "doc": "A signed integer that specifies a minimum acceptable alignment score to report the baseline for MAPQ. When using local alignments (global is 0), aln-min-score is computed by the host software as 22 * match-score. When using global alignments (global is 1), aln-min-score is set to -1000000. Host software computation can be overridden by setting aln-min-score in configuration file.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/aln_min_score"
                },
                {
                  "label": "clip_pe_overhang",
                  "doc": "When nonzero, clips 3' read ends overhanging their mate's 5' ends as aligned. Set 1 to soft-clip overhang, 2 to hard-clip.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/clip_pe_overhang"
                },
                {
                  "label": "dedup_min_qual",
                  "doc": "Specifies a minimum base quality for calculating read quality metric for deduplication.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/dedup_min_qual"
                },
                {
                  "label": "en_alt_hap_aln",
                  "doc": "Allows haplotype alignments to be output as supplementary.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/en_alt_hap_aln"
                },
                {
                  "label": "en_chimeric_aln",
                  "doc": "Allows chimeric alignments to be output as supplementary.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/en_chimeric_aln"
                },
                {
                  "label": "gap_ext_pen",
                  "doc": "Specifies the penalty for extending a gap.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/gap_ext_pen"
                },
                {
                  "label": "gap_open_pen",
                  "doc": "Specifies the penalty for opening a gap (ie, insertion or deletion).\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/gap_open_pen"
                },
                {
                  "label": "global",
                  "doc": "Controls whether alignment is end-to-end in the read. The following values represent the different alignments: 0 is local alignment (Smith-Waterman) 1 is global alignment (Needleman-Wunsch)\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/global"
                },
                {
                  "label": "hard_clip_tags",
                  "doc": "Flags put hard-clipped bases in XB/XQ tags: [0] primary, [1] supplementary, [2] secondary\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/hard_clip_tags"
                },
                {
                  "label": "hard_clips",
                  "doc": "Specifies alignments for hard clipping. The following values represent the different alignments: Bit 0 is primary Bit 1 is supplementary Bit 2 is secondary\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/hard_clips"
                },
                {
                  "label": "map_orientations",
                  "doc": "Constrains orientations to accept forward-only, reverse-complement only, or any alignments. The following values represent the different orientations: 0 is any 1 is forward only 2 is reverse only\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/map_orientations"
                },
                {
                  "label": "mapq_floor_1snp",
                  "doc": "Minimum MAPQ when the best score exceeds others by at least one SNP cost\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/mapq_floor_1snp"
                },
                {
                  "label": "mapq_max",
                  "doc": "Specifies ceiling on reported MAPQ. The default value is 60.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/mapq_max"
                },
                {
                  "label": "mapq_strict_sjs",
                  "doc": "Specific to RNA. When set to 0, a higher MAPQ value is returned, expressing confidence that the alignment is at least partially correct. When set to 1, a lower MAPQ value is returned, expressing the splice junction ambiguity.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/mapq_strict_sjs"
                },
                {
                  "label": "match_n_score",
                  "doc": "A signed integer that specifies the score increment for matching where a read or reference base is N.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/match_n_score"
                },
                {
                  "label": "match_score",
                  "doc": "Specifies the score increment for matching reference nucleotide.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/match_score"
                },
                {
                  "label": "max_rescues",
                  "doc": "Specifies maximum rescue alignments per read pair. The default value is 10.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/max_rescues"
                },
                {
                  "label": "min_overhang",
                  "doc": "Minimum overhang on each side of a splice junction\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/min_overhang"
                },
                {
                  "label": "min_score_coeff",
                  "doc": "Sets adjustment to aln-min-score per read base.\n",
                  "type": [
                    "null",
                    "float"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/min_score_coeff"
                },
                {
                  "label": "mismatch_pen",
                  "doc": "Defines the score penalty for a mismatch.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/mismatch_pen"
                },
                {
                  "label": "no_noncan_motifs",
                  "doc": "Set to suppress individual non-canonical splice junctions.\n0 = no filter, 1 = remove unless annotated, 2 = remove noncanonical motif splice junctions\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/no_noncan_motifs"
                },
                {
                  "label": "no_unclip_score",
                  "doc": "When set to 1, the option removes any unclipped bonus (unclip-score) contributing to an alignment from the alignment score before further processing.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/no_unclip_score"
                },
                {
                  "label": "no_unpaired",
                  "doc": "Determines if only properly paired alignments should be reported for paired reads.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/no_unpaired"
                },
                {
                  "label": "pe_max_penalty",
                  "doc": "Specifies the maximum pairing score penalty for unpaired or distant ends.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/pe_max_penalty"
                },
                {
                  "label": "pe_orientation",
                  "doc": "Specifies the expected paired-end orientation. The following values represent the different orientations: 0 is FR (default) 1 is RF 2 is FF\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/pe_orientation"
                },
                {
                  "label": "rescue_sigmas",
                  "doc": "Sets deviations from the mean read length used for rescue scan radius. The default value is 2.5.\n",
                  "type": [
                    "null",
                    "float"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/rescue_sigmas"
                },
                {
                  "label": "sec_aligns",
                  "doc": "Restricts the maximum number of secondary (suboptimal) alignments to report per read.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/sec_aligns"
                },
                {
                  "label": "sec_aligns_hard",
                  "doc": "If set to 1, forces the read to be unmapped when not all secondary alignments can be output.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/sec_aligns_hard"
                },
                {
                  "label": "sec_phred_delta",
                  "doc": "Controls which secondary alignments are emitted. Only secondary alignments within this Phred value of the primary are reported.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/sec_phred_delta"
                },
                {
                  "label": "sec_score_delta",
                  "doc": "Determines the pair score threshold below primary that secondary alignments are allowed.\n",
                  "type": [
                    "null",
                    "float"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/sec_score_delta"
                },
                {
                  "label": "supp_aligns",
                  "doc": "Restricts the maximum number of supplementary (chimeric) alignments to report per read.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/supp_aligns"
                },
                {
                  "label": "supp_as_sec",
                  "doc": "Determines if supplementary alignments should be reported with secondary flag.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/supp_as_sec"
                },
                {
                  "label": "supp_min_score_adj",
                  "doc": "Specifies amount to increase minimum alignment score for supplementary alignments. The score is computed by host software as 8 * match-score for DNA. The default is 0 for RNA.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/supp_min_score_adj"
                },
                {
                  "label": "unclip_score",
                  "doc": "Specifies the score bonus for reaching the edge of the read.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/unclip_score"
                },
                {
                  "label": "unpaired_pen",
                  "doc": "Specifies the penalty for unpaired alignments, using Phred scale.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options/unpaired_pen"
                }
              ]
            }
          ],
          "class": "SchemaDefRequirement"
        }
      ],
      "id": "#dragen-parse-aligner-schema__4.4.0.cwl",
      "label": "dragen-parse-aligner-schema v(4.4.0)",
      "doc": "Documentation for dragen-parse-aligner-schema v4.4.0\n",
      "inputs": [
        {
          "label": "alignment options input",
          "doc": "Alignment options\n",
          "type": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options",
          "id": "#dragen-parse-aligner-schema__4.4.0.cwl/dragen-parse-aligner-schema--4.4.0/aligner_options_input"
        }
      ],
      "expression": "${\n  return {\n    \"aligner_options_output\": inputs.aligner_options_input\n  };\n}\n",
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      },
      "outputs": [
        {
          "label": "alignment options output",
          "doc": "Alignment options\n",
          "type": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options",
          "id": "#dragen-parse-aligner-schema__4.4.0.cwl/dragen-parse-aligner-schema--4.4.0/aligner_options_output"
        }
      ]
    },
    {
      "class": "ExpressionTool",
      "id": "#dragen-parse-mapper-schema__4.4.0.cwl",
      "label": "dragen-parse-mapper-schema v(4.4.0)",
      "doc": "Documentation for dragen-parse-mapper-schema v4.4.0\n",
      "requirements": [
        {
          "class": "InlineJavascriptRequirement"
        },
        {
          "types": [
            {
              "type": "record",
              "name": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options",
              "fields": [
                {
                  "label": "ann_sj_max_indel",
                  "doc": "Specifies maximum indel length to expect near an annotated splice junction.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options/ann_sj_max_indel"
                },
                {
                  "label": "edit chain limit",
                  "doc": "For edit-mode 1 or 2, the option sets maximum seed chain length in a read to qualify for seed editing.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options/edit_chain_limit"
                },
                {
                  "label": "edit_mode",
                  "doc": "Controls when seed editing is used. The following values represent the different edit modes: 0 is no edits, 1 is chain length test, 2 is paired chain length test, 3 is full seed edits\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options/edit_mode"
                },
                {
                  "label": "edit_read_len",
                  "doc": "For edit-mode 1 or 2, controls the read length for edit-seed-num seed editing positions.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options/edit_read_len"
                },
                {
                  "label": "edit-seed-num",
                  "doc": "For edit-mode 1 or 2, controls the requested number of seeds per read to allow editing on.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options/edit_seed_num"
                },
                {
                  "label": "map_orientations",
                  "doc": "Restricts the orientation of read mapping to only forward in the reference genome or only reverse-complemented. The following values represent the different orientations (paired end requires normal):0 is normal (paired-end inputs must use normal), 1 is reverse-complemented, 2 is no forward\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options/map_orientations"
                },
                {
                  "label": "max_intron_bases",
                  "doc": "Specifies maximum intron length reported.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options/max_intron_bases"
                },
                {
                  "label": "min_intron_bases",
                  "doc": "Specifies minimum reference deletion length reported as an intron.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options/min_intron_bases"
                },
                {
                  "label": "seed_density",
                  "doc": "Controls requested density of seeds from reads queried in the hash table\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options/seed_density"
                }
              ]
            }
          ],
          "class": "SchemaDefRequirement"
        }
      ],
      "inputs": [
        {
          "label": "alignment options input",
          "doc": "Alignment options or null\n",
          "type": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options",
          "id": "#dragen-parse-mapper-schema__4.4.0.cwl/dragen-parse-mapper-schema--4.4.0/mapper_options_input"
        }
      ],
      "outputs": [
        {
          "label": "alignment options output",
          "doc": "Alignment options\n",
          "type": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options",
          "id": "#dragen-parse-mapper-schema__4.4.0.cwl/dragen-parse-mapper-schema--4.4.0/mapper_options_output"
        }
      ],
      "expression": "${\n  return {\n    \"mapper_options_output\": inputs.mapper_options_input\n  };\n}\n",
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "ExpressionTool",
      "id": "#dragen-parse-snv-variant-caller-schema__4.4.0.cwl",
      "label": "dragen-parse-snv-variant-caller-schema v(4.4.0)",
      "doc": "Documentation for dragen-parse-snv-variant-caller-schema\nv4.4.0\n",
      "requirements": [
        {
          "class": "InlineJavascriptRequirement"
        },
        {
          "types": [
            {
              "type": "record",
              "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options",
              "fields": [
                {
                  "label": "dbsnp",
                  "doc": "Sets the path to the variant annotation database VCF (or *.vcf.gz) file.\n",
                  "type": [
                    "null",
                    "File"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/dbsnp"
                },
                {
                  "label": "dn cnv vcf",
                  "doc": "For de novo calling, filters joint structural variant VCF from the CNV calling step. If omitted, DRAGEN skips any checks with overlapping copy number variants.",
                  "type": [
                    "null",
                    "File"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/dn_cnv_vcf"
                },
                {
                  "label": "dn input vcf",
                  "doc": "For de novo calling, filters joint small variant VCF from the de novo calling step.",
                  "type": [
                    "null",
                    "File"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/dn_input_vcf"
                },
                {
                  "label": "dn output vcf",
                  "doc": "For de novo calling, specifies the file location for writing the filtered VCF file. If not specified, the input VCF is overwritten.",
                  "type": [
                    "null",
                    "File"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/dn_output_vcf"
                },
                {
                  "label": "dn sv vcf",
                  "doc": "For de novo calling, filters the joint structural variant VCF file from the SV calling step. If omitted, DRAGEN skips any checks with overlapping structural variants.",
                  "type": [
                    "null",
                    "File"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/dn_sv_vcf"
                },
                {
                  "label": "enable joint genotyping",
                  "doc": "To enable the joint genotyping caller, set to true.",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/enable_joint_genotyping"
                },
                {
                  "label": "enable methylation calling",
                  "doc": "Automatically adds tags related to methylation and outputs a single BAM for methylation protocols.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/enable_methylation_calling"
                },
                {
                  "label": "enable multi sample gvcf",
                  "doc": "Enables generation of a multisample gVCF file. If set to true, requires a combined gVCF file as input.",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/enable_multi_sample_gvcf"
                },
                {
                  "label": "enable variant caller",
                  "doc": "Enables the DRAGEN variant caller.\nThis is forced to true for DNA but for RNA analysis, you will need to set this to true\nin order to enable the variant caller.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/enable_variant_caller"
                },
                {
                  "label": "enable variant deduplication",
                  "doc": "Enables variant deduplication. The default value is false.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/enable_variant_deduplication"
                },
                {
                  "label": "enable vcf compression",
                  "doc": "Enables compression of VCF output files. The default value is true.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/enable_vcf_compression"
                },
                {
                  "label": "enable vcf indexing",
                  "doc": "Outputs a *.tbi index file in addition to the output VCF/gVCF. The default is true.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/enable_vcf_indexing"
                },
                {
                  "label": "enable vlrd",
                  "doc": "Enables Virtual Long Read Detection.",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/enable_vlrd"
                },
                {
                  "label": "pedigree file",
                  "doc": "Specifies the path to a pedigree file that describes the familial relationships between panels (specific to joint calling). Only pedigree files that contain trios are supported.",
                  "type": [
                    "null",
                    "File"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/pedigree_file"
                },
                {
                  "label": "qc detect contamination",
                  "doc": "Recommended way to run contamination detection based on GATK CalculateContamination.\nSupports germline and somatic.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/qc_detect_contamination"
                },
                {
                  "label": "qc indel denovo quality threshold",
                  "doc": "Sets the threshold for counting and reporting de novo INDEL variants.",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/qc_indel_denovo_quality_threshold"
                },
                {
                  "label": "qc snp denovo quality threshold",
                  "doc": "Sets the threshold for counting and reporting de novo SNP variants.",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/qc_snp_denovo_quality_threshold"
                },
                {
                  "label": "rna vc enable homozygous genotype",
                  "doc": "Enables the generation of homozygous genotypes in the VCF output. The default value is false.",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/rna_vc_enable_homozygous_genotype"
                },
                {
                  "label": "rna vc homozygous genotype af threshold",
                  "doc": "Sets the allele frequency threshold for calling homozygous genotypes. The default value is 0.85",
                  "type": [
                    "null",
                    "float"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/rna_vc_homozygous_genotype_af_threshold"
                },
                {
                  "label": "variant",
                  "doc": "Specifies the path to a single gVCF file. You can use the --variant option multiple times to specify paths to multiple gVCF files. Use one file per line. Up to 500 gVCFs are supported.",
                  "type": [
                    "null",
                    "File"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/variant"
                },
                {
                  "label": "variant list",
                  "doc": "Specifies the path to a file containing a list of input gVCF files that need to be combined. Use one file per line.",
                  "type": [
                    "null",
                    "File"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/variant_list"
                },
                {
                  "label": "vc af call threshold",
                  "doc": "If the AF filter is enabled using --vc-enable-af-filter=true, the option sets the allele frequency call threshold for nuclear chromosomes to emit a call in the VCF. The default value is 0.01.",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_af_call_threshold"
                },
                {
                  "label": "vc af call threshold mito",
                  "doc": "If the AF filter is enabled using --vc-enable-af-filter-mito=true, the option sets the allele frequency call threshold to emit a call in the VCF for mitochondrial variant calling. The default value is 0.01.",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_af_call_threshold_mito"
                },
                {
                  "label": "vc af filter threshold",
                  "doc": "If the AF filter is enabled using --vc-enable-af-filter=true, the option sets the allele frequency filter threshold for nuclear chromosomes to mark emitted VCF calls as filtered. The default value is 0.05.",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_af_filter_threshold"
                },
                {
                  "label": "vc af filter threshold mito",
                  "doc": "If the AF filter is enabled using --vc-enable-af-filter-mito=true, the option sets the allele frequency filter threshold to mark emitted VCF calls as filtered for mitochondrial variant calling. The default value is 0.02.",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_af_filter_threshold_mito"
                },
                {
                  "label": "vc callability normal threshold",
                  "doc": "Specifies the normal sample coverage threshold for a site to be considered callable in the somatic callable regions report. The default is 5.",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_callability_normal_threshold"
                },
                {
                  "label": "vc callability tumor threshold",
                  "doc": "Specifies the tumor sample coverage threshold for a site to be considered callable in the somatic callable regions report. The default is 50.",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_callability_tumor_threshold"
                },
                {
                  "label": "vc clustered event penalty",
                  "doc": "SQ score penalty applied to phased clustered somatic events; set to 0 to disable the penalty. The default value is 4.0 for tumor-normal and 7.0 for tumor-only.",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_clustered_event_penalty"
                },
                {
                  "label": "vc combine phased variants distance",
                  "doc": "Specifies the maximum distance over which phased insertions, deletions, and SNVs will be combined into a complex indel.\nThis distance threshold will be applied to any group of phased variants that includes at least one indel.\nThe default is 2 for somatic and 0 for germline (disabled).\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_combine_phased_variants_distance"
                },
                {
                  "label": "vc combine phased variants distance snvs only",
                  "doc": "Specifies the maximum distance over which phased SNVs will be combined into an MNV.\nThis option applies only to phased variant groups consisting of only SNVs.\nThe default is 2 for somatic and 0 for germline (disabled). For phased variant groups that include both SNVs and indels,\nthe analogous vc-combine-phased-variants-distance option applies.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_combine_phased_variants_distance_snvs_only"
                },
                {
                  "label": "vc combine phased variants max vaf delta",
                  "doc": "Specifies the threshold for filtering MNV component variant calls when the events comprising to the MNV have\ndifferent allele frequencies. The default value is 0.1, which means that any SNV or INDEL with an AF that is\nmore than 0.1 greater than the MNV AF shall be emitted as a PASSing call, while the remaining components\nshall be emitted with the 'mnv_component' FILTER flag. Only applicable when vc-combine-phased-variants-distance\nis greater than 0 and vc-mnv-emit-component-calls is true. (Default=0.1)\n",
                  "type": [
                    "null",
                    "float"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_combine_phased_variants_max_vaf_delta"
                },
                {
                  "label": "vc decoy contigs",
                  "doc": "Specifies the path to a comma-separated list of contigs to skip during variant calling.",
                  "type": [
                    "null",
                    {
                      "type": "array",
                      "items": "string"
                    }
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_decoy_contigs"
                },
                {
                  "label": "vc depth annotation threshold",
                  "doc": "Filters all non-PASS somatic alt variants with a depth below this threshold. The default value is 0 (no filtering).",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_depth_annotation_threshold"
                },
                {
                  "label": "vc depth filter threshold",
                  "doc": "Filters all somatic variants (alt or homref) with a depth below this threshold. The default value is 0 (no filtering).",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_depth_filter_threshold"
                },
                {
                  "label": "vc emit ref confidence",
                  "doc": "Enables base pair resolution gVCF generation or banded gVCF generation.",
                  "type": [
                    "null",
                    "string"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_emit_ref_confidence"
                },
                {
                  "label": "vc emit zero coverage intervals",
                  "doc": "Specifies whether or not to emit zero coverage intervals in the VCF output.\nThe default value is true\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_emit_zero_coverage_intervals"
                },
                {
                  "label": "vc max alternate alleles",
                  "doc": "Specifies the maximum number of alternate alleles to emit in the VCF output.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_max_alternate_alleles"
                },
                {
                  "label": "vc max callable region memory usage",
                  "doc": "Set the maximum size of a single callable region. Default is \"13GB\".\n",
                  "type": [
                    "null",
                    "string"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_max_callable_region_memory_usage"
                },
                {
                  "label": "vc mnv emit component calls",
                  "doc": "Specifies whether or not to emit the individual component variant records along with the merged variant records.\nWhen set to true, all component calls making up an MNV or complex indel will be emitted in the VCF\nalong with the merged variant record. The default is true for somatic and false (disabled) for germline.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vc_mnv_emit_component_calls"
                },
                {
                  "label": "vd eh vcf",
                  "doc": "Inputs the ExpansionHunter VCF file for variant deduplication. The input file can be gzipped.\n",
                  "type": [
                    "null",
                    "File"
                  ],
                  "secondaryFiles": [
                    {
                      "pattern": ".tbi",
                      "required": false
                    }
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vd_eh_vcf"
                },
                {
                  "label": "vd output match log",
                  "doc": "Outputs a file that describes the variants that matched during deduplication. The default value is false.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vd_output_match_log"
                },
                {
                  "label": "vd small variant vcf",
                  "doc": "Inputs small variant VCF file for variant deduplication. The input file can be gzipped.\n",
                  "type": [
                    "null",
                    "File"
                  ],
                  "secondaryFiles": [
                    {
                      "pattern": ".tbi",
                      "required": false
                    }
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vd_small_variant_vcf"
                },
                {
                  "label": "vd sv vcf",
                  "doc": "Inputs structural variant VCF for variant deduplication. The input file can be gzipped.\n",
                  "type": [
                    "null",
                    "File"
                  ],
                  "secondaryFiles": [
                    {
                      "pattern": ".tbi",
                      "required": false
                    }
                  ],
                  "name": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options/vd_sv_vcf"
                }
              ]
            }
          ],
          "class": "SchemaDefRequirement"
        }
      ],
      "inputs": [
        {
          "label": "alignment options input",
          "doc": "Alignment options or null\n",
          "type": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options",
          "id": "#dragen-parse-snv-variant-caller-schema__4.4.0.cwl/dragen-parse-snv-variant-caller-schema--4.4.0/snv_variant_caller_options_input"
        }
      ],
      "outputs": [
        {
          "label": "alignment options output",
          "doc": "Alignment options\n",
          "type": [
            "null",
            "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options"
          ],
          "id": "#dragen-parse-snv-variant-caller-schema__4.4.0.cwl/dragen-parse-snv-variant-caller-schema--4.4.0/snv_variant_caller_options_output"
        }
      ],
      "expression": "${\n  return {\n    \"snv_variant_caller_options_output\": inputs.snv_variant_caller_options_input\n  };\n}\n",
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "ExpressionTool",
      "id": "#dragen-parse-sv-caller-schema__4.4.0.cwl",
      "label": "dragen-parse-sv-caller-schema v(4.4.0)",
      "doc": "Documentation for dragen-parse-sv-caller-schema v4.4.0\n",
      "requirements": [
        {
          "class": "InlineJavascriptRequirement"
        },
        {
          "types": [
            {
              "type": "record",
              "name": "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options",
              "fields": [
                {
                  "label": "enable csv",
                  "doc": "Enables the structural variant caller.\nThe default value is false.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options/enable_sv"
                },
                {
                  "label": "sv call regions bed",
                  "doc": "A bed file containing the regions to be used for structural variant calling.\n",
                  "type": [
                    "null",
                    "File"
                  ],
                  "name": "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options/sv_call_regions_bed"
                },
                {
                  "label": "sv filtered contigs",
                  "doc": "A file containing the list of contigs to be filtered out from structural variant calling.\nThe default value is empty.\n",
                  "type": [
                    "null",
                    {
                      "type": "array",
                      "items": "string"
                    }
                  ],
                  "name": "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options/sv_filtered_contigs"
                }
              ]
            }
          ],
          "class": "SchemaDefRequirement"
        }
      ],
      "inputs": [
        {
          "label": "alignment options input",
          "doc": "Alignment options or null\n",
          "type": "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options",
          "id": "#dragen-parse-sv-caller-schema__4.4.0.cwl/dragen-parse-sv-caller-schema--4.4.0/sv_caller_options_input"
        }
      ],
      "outputs": [
        {
          "label": "alignment options output",
          "doc": "Alignment options\n",
          "type": [
            "null",
            "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options"
          ],
          "id": "#dragen-parse-sv-caller-schema__4.4.0.cwl/dragen-parse-sv-caller-schema--4.4.0/sv_caller_options_output"
        }
      ],
      "expression": "${\n  return {\n    \"sv_caller_options_output\": inputs.sv_caller_options_input\n  };\n}\n",
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "ExpressionTool",
      "id": "#dragen-wgts-parse-alignment-schema__4.4.0.cwl",
      "label": "dragen-wgts-parse-alignment-schema v(4.4.0)",
      "doc": "Documentation for dragen-wgts-parse-alignment-schema v4.4.0\n",
      "requirements": [
        {
          "class": "InlineJavascriptRequirement"
        },
        {
          "types": [
            {
              "$import": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options"
            },
            {
              "$import": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options"
            },
            {
              "$import": "#dragen-qc-coverage__1.0.0.yaml/dragen-qc-coverage"
            },
            {
              "type": "record",
              "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options",
              "fields": [
                {
                  "label": "aligner",
                  "doc": "Specifies any options under the [Aligner] configuration section\n",
                  "type": [
                    "null",
                    {
                      "$import": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options"
                    }
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/aligner"
                },
                {
                  "label": "append read index to name",
                  "doc": "By default, DRAGEN names both mate ends of pairs the same. When set to true, DRAGEN appends /1 and /2 to the two ends.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/append_read_index_to_name"
                },
                {
                  "doc": "Enables the deterministic sort of output alignment records. The default value is true.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/enable_deterministic_sort"
                },
                {
                  "label": "enable down sampler",
                  "doc": "Enables the down-sampling of input reads. The default value is false.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/enable_down_sampler"
                },
                {
                  "doc": "Enables the flagging of duplicate output alignment records.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/enable_duplicate_marking"
                },
                {
                  "label": "enable sampling",
                  "doc": "Automatically detects paired-end parameters by running a sample through the mapper/aligner.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/enable_sampling"
                },
                {
                  "label": "fastq offset",
                  "doc": "Specifies the FASTQ offset to use for the input FASTQ files. The default value is 33.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/fastq_offset"
                },
                {
                  "label": "filter flags from output",
                  "doc": "Filters output alignments with any bits set in val present in the flags field. Hex and decimal values accepted.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/filter_flags_from_output"
                },
                {
                  "label": "generate md tags",
                  "doc": "Generates MD tags with alignment output records. The default value is false.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/generate_md_tags"
                },
                {
                  "label": "generate sa tags",
                  "doc": "Generates SA:Z tags for records that have chimeric or supplemental alignments.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/generate_sa_tags"
                },
                {
                  "label": "generate zs tags",
                  "doc": "Generate ZS tags for alignment output records. The default value is false.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/generate_zs_tags"
                },
                {
                  "label": "input qname suffix delimiter",
                  "doc": "Controls the delimiter used for append-read-index-to-name and for detecting matching pair names with BAM input.\n",
                  "type": [
                    "null",
                    "string"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/input_qname_suffix_delimiter"
                },
                {
                  "label": "mapper",
                  "doc": "Specifies any options under the [Mapper] configuration section\n",
                  "type": [
                    "null",
                    {
                      "$import": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options"
                    }
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/mapper"
                },
                {
                  "label": "output format",
                  "doc": "Sets the format of the output file from the map/align stage.\nThe following values are valid:\n  * SAM\n  * BAM\n  * CRAM\n",
                  "type": [
                    "null",
                    "string"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/output_format"
                },
                {
                  "label": "preserve bqsr tags",
                  "doc": "Determines whether to preserve BI and BD flags from the input BAM file, which can cause problems with hard clipping.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/preserve_bqsr_tags"
                },
                {
                  "label": "preserve map align order",
                  "doc": "Produces output file that preserves original order of reads in the input file.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/preserve_map_align_order"
                },
                {
                  "label": "qc coverage",
                  "doc": "Up to three regions can be specified for coverage region reports.\n",
                  "type": [
                    "null",
                    {
                      "type": "array",
                      "items": {
                        "$import": "#dragen-qc-coverage__1.0.0.yaml/dragen-qc-coverage"
                      }
                    }
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/qc_coverage"
                },
                {
                  "label": "ref sequence filter",
                  "doc": "Outputs only reads mapping to the reference sequence.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/ref_sequence_filter"
                },
                {
                  "label": "remove duplicates",
                  "doc": "If true, the option removes duplicate alignment records instead of only flagging them.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/remove_duplicates"
                },
                {
                  "label": "rna ann sj min len",
                  "doc": "Discard splice junctions which have length less than this value, during the generation of splice junctions\nfrom an annotations file (GTF/GFF/SJ.out.tab)\nSet to 0 to disable. Default is 6\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/rna_ann_sj_min_len"
                },
                {
                  "label": "rna library type",
                  "doc": "Specifies the type of RNA-seq library. The following are the available values:\nIU - Paired-end unstranded library.\nISR - Paired-end stranded library in which read2 matches the transcript strand (eg, Illumina Stranded Total RNA Prep).\nISF - Paired-end stranded library in which read1 matches the transcript strand.\nU - Single-end unstranded library.\nSR - Single-end stranded library in which reads are in reverse orientation to the transcript strand (eg, Illumina Stranded Total RNA Prep).\nSF - Single-end stranded library in which reads match the transcript strand.\nA -  DRAGEN examines the first reads pairs in the data set to automatically detect the correct library type. For polya tail trimming, the library type is assumed to be unstranded. Autodetect is the default value.\n",
                  "type": [
                    "null",
                    "string"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/rna_library_type"
                },
                {
                  "label": "rna mapq unique",
                  "doc": "Some downstream tools, such as Cufflinks, expect the MAPQ value to be a unique value\nfor all uniquely mapped reads.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/rna_mapq_unique"
                },
                {
                  "label": "rrna filter contigs",
                  "doc": "Sets the name of the rRNA sequences to use for filtering.\nIf you do not specify a value, the default gl000220 is used for human genome alignments\nwith the reference autodetect feature.\ngl000220 is an unplaced contig included in hg19 and hg38 genomes,\nwhich include a full copy of the rRNA repeat.\nFor other genomes, you must include a rRNA decoy contig when creating a hash table.\n",
                  "type": [
                    "null",
                    "string"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/rrna_filter_contig"
                },
                {
                  "label": "rrna filter enable",
                  "doc": "Enables the removal of rRNA reads from the output alignment records.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/rrna_filter_enable"
                },
                {
                  "label": "sample size",
                  "doc": "Specifies number of reads to sample when enable-sampling is true.\n",
                  "type": [
                    "null",
                    "int"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/sample_size"
                },
                {
                  "label": "strip input qname suffixes",
                  "doc": "Determines whether to strip read-index suffixes (eg, /1 and /2) from input QNAMEs. If set to false, the option preserves entire name.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options/strip_input_qname_suffixes"
                }
              ]
            }
          ],
          "class": "SchemaDefRequirement"
        }
      ],
      "inputs": [
        {
          "label": "dragen wgts alignment options",
          "doc": "Alignment options or null\n",
          "type": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options",
          "id": "#dragen-wgts-parse-alignment-schema__4.4.0.cwl/dragen-wgts-parse-alignment-schema--4.4.0/dragen_wgts_alignment_options"
        }
      ],
      "outputs": [
        {
          "label": "dragen wgts alignment options output",
          "doc": "Dragen wgts alignment options output\n",
          "type": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options",
          "id": "#dragen-wgts-parse-alignment-schema__4.4.0.cwl/dragen-wgts-parse-alignment-schema--4.4.0/dragen_wgts_alignment_options_output"
        }
      ],
      "expression": "${\n  return {\n    \"dragen_wgts_alignment_options_output\": inputs.dragen_wgts_alignment_options\n  };\n}\n",
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "CommandLineTool",
      "id": "#dragen-nirvana-downloader__4.4.4.cwl",
      "label": "dragen-nirvana-downloader v(4.4.4)",
      "doc": "Documentation for dragen-nirvana-downloader v4.4.4\n",
      "hints": [
        {
          "dockerPull": "079623148045.dkr.ecr.us-east-1.amazonaws.com/cp-prod/b35eb8ce-3035-4796-896b-1b33b6a02c44:latest",
          "class": "DockerRequirement"
        },
        {
          "coresMin": 16,
          "ramMin": 240000,
          "class": "ResourceRequirement",
          "https://platform.illumina.com/rdf/ica/resources:tier": "standard",
          "https://platform.illumina.com/rdf/ica/resources:type": "fpga",
          "https://platform.illumina.com/rdf/ica/resources:size": "medium"
        }
      ],
      "requirements": [
        {
          "listing": [
            {
              "entryname": "run_nirvana_download.sh",
              "entry": "#!/usr/bin/env bash\n\n# Fail on non-zero exit of subshell\nset -euo pipefail\n\n# Reset dragen\n/opt/edico/bin/dragen_reset\n\n# Create directories\nmkdir \\\\\n  \".dotnet\" \\\\\n  \"/scratch/nirvana_assembly_$(inputs.genome_version)\"\n\n# Set the env var for dotnet\nexport DOTNET_BUNDLE_EXTRACT_BASE_DIR=\"$(runtime.outdir)/.dotnet\"\n\n# Run the nirvana script\necho \"Downloading $(inputs.annotations_type)\" 1>&2\n\"/opt/edico/share/nirvana/DataManager\" \"download\" \\\\\n  --ref \"$(inputs.genome_version)\" \\\\\n  --versions-config \"/opt/edico/resources/annotation/$(inputs.annotations_type)_annotations_$(inputs.genome_version).json\" \\\\\n  --dir \"/scratch/nirvana_assembly_$(inputs.genome_version)\" \\\\\n  --credentials-file \"/opt/edico/config/data-downloader.json\"\n\n# Dont trust it, so we run it again for good measure\necho \"Rerunning nirvana download for $(inputs.annotations_type)\" 1>&2\n\"/opt/edico/share/nirvana/DataManager\" \"download\" \\\\\n  --ref \"$(inputs.genome_version)\" \\\\\n  --versions-config \"/opt/edico/resources/annotation/$(inputs.annotations_type)_annotations_$(inputs.genome_version).json\" \\\\\n  --dir \"/scratch/nirvana_assembly_$(inputs.genome_version)\" \\\\\n  --credentials-file \"/opt/edico/config/data-downloader.json\"\n\n# If the annotation type is not \"all\" we need to rerun with \"all\" as well\nif [[ \"$(inputs.annotations_type)\" != \"all\" ]]; then\n  echo \"Also downloading \"all\" annotations as well\" 1>&2\n  \"/opt/edico/share/nirvana/DataManager\" \"download\" \\\\\n    --ref \"$(inputs.genome_version)\" \\\\\n    --versions-config \"/opt/edico/resources/annotation/all_annotations_$(inputs.genome_version).json\" \\\\\n    --dir \"/scratch/nirvana_assembly_$(inputs.genome_version)\" \\\\\n    --credentials-file \"/opt/edico/config/data-downloader.json\"\n\n  # Do we have trust issues, of course we do. Run it again.\n  echo \"Rerunning download for \"all\" annotations\" 1>&2\n  \"/opt/edico/share/nirvana/DataManager\" \"download\" \\\\\n    --ref \"$(inputs.genome_version)\" \\\\\n    --versions-config \"/opt/edico/resources/annotation/all_annotations_$(inputs.genome_version).json\" \\\\\n    --dir \"/scratch/nirvana_assembly_$(inputs.genome_version)\" \\\\\n    --credentials-file \"/opt/edico/config/data-downloader.json\"\nfi\n\n# Make note of the files we have (to stderr)\necho \"Downloaded files summary\" 1>&2\necho \"=================\" 1>&2\nfind \"/scratch/nirvana_assembly_$(inputs.genome_version)\" -type f 1>&2\necho \"=================\" 1>&2\n\n# Tar it up!\necho \"Tarring it up $(inputs.annotations_type)\" 1>&2\ntar \\\\\n  --create \\\\\n  --directory \"/scratch\" \\\\\n  --use-compress-program \"pigz\" \\\\\n  --file \"/scratch/nirvana_assembly_$(inputs.genome_version).tar.gz\" \\\\\n  \"nirvana_assembly_$(inputs.genome_version)\"\n\n# Move to outputs\nmv \"/scratch/nirvana_assembly_$(inputs.genome_version).tar.gz\" \"$(runtime.outdir)/nirvana_assembly_$(inputs.genome_version).tar.gz\"\n"
            }
          ],
          "class": "InitialWorkDirRequirement"
        },
        {
          "expressionLib": [
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Globals */\n/*\nList of options that are booleans but where the values are expressed as a number\n*/\nvar DragenNumericBooleanType = [\n    \"global\",\n    \"all\"\n];\nvar DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH = '/opt/instance-identity';\n/*  Functions */\nfunction get_scratch_mount() {\n    /*\n    Return the path of the scratch directory space\n    */\n    return \"/scratch/\";\n}\nfunction get_intermediate_results_dir() {\n    /*\n    Get intermediate results directory as /scratch for dragen runs\n    */\n    return get_scratch_mount() + \"intermediate-results/\";\n}\nfunction get_name_root_from_tarball(basename) {\n    var tar_ball_regex = /(\\S+)\\.tar(?:\\.gz)?/g;\n    var tar_ball_expression = tar_ball_regex.exec(basename);\n    if (tar_ball_expression === null) {\n        throw new Error(\"Could not get nameroot from \".concat(basename));\n    }\n    return tar_ball_expression[1];\n}\nfunction get_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_ref_mount() {\n    /*\n    Get the reference mount point\n    */\n    return get_scratch_mount() + \"ref/\";\n}\nfunction get_ora_ref_mount() {\n    /*\n    Get the ORA reference mount point\n    */\n    return get_scratch_mount() + \"ora-reference/\";\n}\nfunction get_ora_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ora_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_nirvana_ref_mount() {\n    /*\n    Get the Nirvana reference mount point\n    */\n    return get_scratch_mount() + \"nirvana-reference/\";\n}\nfunction get_nirvana_ref_path(reference_input_obj) {\n    return get_nirvana_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_variant_annotation_data_mount(nirvana_annotation_options) {\n    if (!nirvana_annotation_options) {\n        return null;\n    }\n    if (!nirvana_annotation_options.variant_annotation_data) {\n        return null;\n    }\n    return get_attribute_from_optional_input(nirvana_annotation_options.variant_annotation_data, \"path\");\n}\nfunction get_dragen_bin_path() {\n    /*\n    Get dragen bin path\n    */\n    return \"/opt/edico/bin/dragen\";\n}\nfunction get_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"fastq_list.csv\";\n}\nfunction get_tumor_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"tumor_fastq_list.csv\";\n}\nfunction capitalizeFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction json_to_toml(json_data) {\n    /*  Convert JSON to TOML format */\n    /*  Much easier than the other way around */\n    /*  Initialize an empty string to store the TOML data */\n    var toml_data = '';\n    var global_keys_list = [];\n    /*  Iterate through each key in the JSON object to first find the 'global' keys */\n    for (var key in json_data) {\n        var value = json_data[key];\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            continue;\n        }\n        global_keys_list.push(key);\n    }\n    var _loop_1 = function (key) {\n        var value = json_data[key];\n        if (value === null) {\n            return \"continue\";\n        }\n        /*  If the value is an array, we need to make an entry for each item in the array */\n        else if (Array.isArray(value)) {\n            value.forEach(function (item) {\n                toml_data += \"\".concat(key, \" = \").concat(item, \"\\n\");\n            });\n        }\n        else {\n            /*  Regular append */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    };\n    /*  Add global keys to the TOML data first */\n    for (var _i = 0, global_keys_list_1 = global_keys_list; _i < global_keys_list_1.length; _i++) {\n        var key = global_keys_list_1[_i];\n        _loop_1(key);\n    }\n    /*  Iterate through each key in the JSON object */\n    for (var key in json_data) {\n        var value = json_data[key];\n        /*  Skip global keys */\n        if (global_keys_list.indexOf(key) !== -1) {\n            continue;\n        }\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"File\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is a directory, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"Directory\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is an object, treat it as a section */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            /*  Section header should have a capitalized first letter */\n            toml_data += \"[\".concat(capitalizeFirstLetter(key), \"]\\n\");\n            for (var sub_key in value) {\n                toml_data += \"\".concat(sub_key, \" = \").concat(value[sub_key], \"\\n\");\n            }\n        }\n        /*  If the value is a string, treat it as a key-value pair */\n        else {\n            /*  Otherwise, treat it as a key-value pair */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    }\n    /*  Return the TOML data */\n    return toml_data;\n}\n/* Convert TOML to JSON format */\nfunction toml_to_json(toml_str) {\n    /*\n    Convert TOML to JSON format.\n    This implementation uses a simple TOML parser for basic key-value pairs and sections.\n    For production use, consider using a library like `@iarna/toml` or `toml`.\n    */\n    var result = {};\n    var currentSection = null;\n    var lines = toml_str.split(/\\r?\\n/);\n    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n        var line = lines_1[_i];\n        line = line.trim();\n        if (!line || line.startsWith(\"#\"))\n            continue;\n        /*  Section header */\n        var sectionMatch = line.match(/^\\[(.+)\\]$/);\n        if (sectionMatch) {\n            /*  Make section lowercase */\n            currentSection = sectionMatch[1].toLowerCase().trim();\n            if (!result[currentSection]) {\n                result[currentSection] = {};\n            }\n            continue;\n        }\n        /*  Key-value pair */\n        var kvMatch = line.match(/^([^=]+)=(.*)$/);\n        if (kvMatch) {\n            var key = kvMatch[1].trim();\n            var value = kvMatch[2].trim();\n            /*  Check if value is empty */\n            if ((value === \"\")) {\n                value = null;\n            }\n            /*  Remove quotes if present */\n            else if ((value.startsWith('\"') && value.endsWith('\"')) ||\n                (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n                value = value.slice(1, -1);\n            }\n            else if (value === \"true\" || value === \"false\") {\n                value = value === \"true\";\n            }\n            else if (!isNaN(Number(value))) {\n                value = Number(value);\n            }\n            /* Set the key name by replacing hyphens with underscores */\n            key = key.replace(/-/g, '_');\n            /* Replace hyphens with underscores in the key */\n            if (currentSection) {\n                /* Check if the key exists in the current section */\n                if (result[currentSection].hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[currentSection][key])) {\n                        /* Push the entry */\n                        result[currentSection][key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[currentSection][key] !== undefined) {\n                            result[currentSection][key] = [result[currentSection][key], value];\n                        }\n                        else {\n                            result[currentSection][key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[currentSection][key] = value;\n                }\n            }\n            else {\n                /* Check if the key exists */\n                if (result.hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[key])) {\n                        /* Push the entry */\n                        result[key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[key] !== undefined) {\n                            result[key] = [result[key], value];\n                        }\n                        else {\n                            result[key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[key] = value;\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction build_fastq_list_csv_header(header_names) {\n    /*\n    Convert lowercase labels to uppercase values\n    i.e\n    [ \"rgid\", \"rglb\", \"rgsm\", \"lane\", \"read_1\", \"read_2\" ]\n    to\n    \"RGID,RGLB,RGSM,Lane,Read1File,Read2File\"\n    */\n    var modified_header_names = [];\n    for (var _i = 0, header_names_1 = header_names; _i < header_names_1.length; _i++) {\n        var header_name = header_names_1[_i];\n        if (header_name.indexOf(\"rg\") === 0) {\n            /*\n            rgid -> RGID\n            */\n            modified_header_names.push(header_name.toUpperCase());\n        }\n        else if (header_name.indexOf(\"read\") === 0) {\n            /*\n            read_1 -> Read1File\n            */\n            modified_header_names.push(\"Read\" + header_name.charAt(header_name.length - 1) + \"File\");\n        }\n        else {\n            /*\n            lane to Lane\n            */\n            modified_header_names.push(header_name[0].toUpperCase() + header_name.substr(1));\n        }\n    }\n    /*\n    Convert array to comma separated strings\n    */\n    return modified_header_names.join(\",\") + \"\\n\";\n}\nfunction get_fastq_list_row_as_csv_row(fastq_list_row, row_order) {\n    var fastq_list_row_values_array = [];\n    /*  This for loop is here to ensure were assigning values in the same order as the header */\n    for (var _i = 0, row_order_1 = row_order; _i < row_order_1.length; _i++) {\n        var item_index = row_order_1[_i];\n        var found_item = false;\n        /*  Find matching attribute in this row */\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            var fastq_list_row_field_value = fastq_list_row[fastq_list_row_field_name];\n            if (fastq_list_row_field_value === null) {\n                /*\n                Item not found, add an empty attribute for this cell in the csv\n                */\n                continue;\n            }\n            /*  The header value matches the name in the item */\n            if (fastq_list_row_field_name === item_index) {\n                /*\n                If the field value has a class attribute then it's either read_1 or read_2\n                */\n                if (fastq_list_row_field_value.hasOwnProperty(\"class\")) {\n                    var fastq_list_row_field_value_file = fastq_list_row_field_value;\n                    /*\n                    Assert that this is actually of class file\n                    */\n                    if (fastq_list_row_field_value_file.class !== \"File\") {\n                        continue;\n                    }\n                    /*  Read 1 and 2 files are mounted as rgid/filename */\n                    fastq_list_row_values_array.push(fastq_list_row.rgid + '/' + fastq_list_row_field_value_file.basename);\n                }\n                else {\n                    /*\n                    Push the string attribute to the fastq list csv row\n                    Replace any commas in the string with ' -'\n                    */\n                    fastq_list_row_values_array.push(fastq_list_row_field_value.toString().replace(/,/g, \" -\"));\n                }\n                found_item = true;\n                break;\n            }\n        }\n        if (!found_item) {\n            /*\n            Push blank cell if no item found\n            */\n            fastq_list_row_values_array.push(\"\");\n        }\n    }\n    /*\n    Convert to string and return as string\n    */\n    return fastq_list_row_values_array.join(\",\") + \"\\n\";\n}\nfunction generate_fastq_list_csv(fastq_list_rows) {\n    /*\n    Fastq list rows generation\n    */\n    var fastq_csv_file = {\n        class:\"File\",\n        basename:get_fastq_list_csv_path()\n    };\n    /*\n    Set the row order\n    */\n    var row_order = [];\n    /*\n    Set the array order\n    Make sure we iterate through all rows of the array\n    */\n    for (var _i = 0, fastq_list_rows_1 = fastq_list_rows; _i < fastq_list_rows_1.length; _i++) {\n        var fastq_list_row = fastq_list_rows_1[_i];\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            if (row_order.indexOf(fastq_list_row_field_name) === -1) {\n                row_order.push(fastq_list_row_field_name);\n            }\n        }\n    }\n    /*\n    Make header\n    */\n    fastq_csv_file.contents = build_fastq_list_csv_header(row_order);\n    /*\n    For each fastq list row,\n    collect the values of each attribute but in the order of the header\n    */\n    for (var _c = 0, fastq_list_rows_2 = fastq_list_rows; _c < fastq_list_rows_2.length; _c++) {\n        var fastq_list_row = fastq_list_rows_2[_c];\n        /*  Add csv row to file contents */\n        fastq_csv_file.contents += get_fastq_list_row_as_csv_row(fastq_list_row, row_order);\n    }\n    return fastq_csv_file;\n}\nfunction get_value_for_config(valueObj) {\n    /* If valueObj is an IFile, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"File\") {\n        return valueObj.path;\n    }\n    /* If valueObj is an IDirectory, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"Directory\") {\n        return valueObj.path;\n    }\n    /* Recursively call this function for nested objects */\n    if (typeof valueObj === 'object' && !Array.isArray(valueObj)) {\n        var newValueObj = {};\n        for (var key in valueObj) {\n            if (valueObj[key] === null || valueObj[key] === undefined) {\n                continue;\n            }\n            /* Special case - boolean to numeric */\n            if (key in DragenNumericBooleanType) {\n                newValueObj[key.replace(/_/g, \"-\")] = valueObj[key] ? 1 :0;\n                continue;\n            }\n            newValueObj[key.replace(/_/g, \"-\")] = get_value_for_config(valueObj[key]);\n        }\n        return newValueObj;\n    }\n    /* Consider arrays */\n    if (Array.isArray(valueObj)) {\n        return valueObj.map(function (item) { return get_value_for_config(item); });\n    }\n    /* Otherwise return the value as is */\n    return valueObj;\n}\nfunction get_dragen_config_path() {\n    return \"dragen_config.toml\";\n}\nfunction dragen_to_config_toml(props) {\n    /* Part 1 - Generate the json blob */\n    var json_blob = {};\n    for (var key in props) {\n        /* Get props key value */\n        var value = props[key];\n        /* Skip null props */\n        if (value === null || value === undefined) {\n            continue;\n        }\n        /*  FIXME denovo to DeNovo */\n        /* Special cases */\n        /* 1. Fastq list rows we rename to 'fastq-list',\n            alignment data mounted at the base of the working directory\n        */\n        /* Sequence data */\n        if (key === \"fastq_list_rows\") {\n            json_blob[\"fastq-list\"] = get_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"bam_input\") {\n            json_blob[\"bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_input\") {\n            json_blob[\"cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_reference\") {\n            json_blob[\"cram-reference\"] = value.basename;\n            continue;\n        }\n        /* Tumor sequence data */\n        if (key === \"tumor_fastq_list_rows\") {\n            json_blob['tumor-fastq-list'] = get_tumor_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"tumor_bam_input\") {\n            json_blob[\"tumor-bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_input\") {\n            json_blob[\"tumor-cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_reference\") {\n            json_blob[\"tumor-cram-reference\"] = value.basename;\n            continue;\n        }\n        /* 2. If ref-tar is parsed through, we use ref-dir instead */\n        if (key === \"ref_tar\") {\n            json_blob['ref-dir'] = get_ref_mount() + value.basename.replace(/\\.tar\\.gz$/, \"\");\n            /*\n                If the ref_tar does not contain 'graph',\n                then we also need to add the parameter,\n                --validate-pangenome-reference=false,\n                this was in place when we wanted to align genome to linear somatic reference\n                however, we are no longer doing that so this parameter is not needed\n            */\n            if (!value.basename.includes(\"graph\")) {\n                json_blob['validate-pangenome-reference'] = false;\n            }\n            continue;\n        }\n        /* If the ora reference is parsed through, we also place the ora reference into the scratch space */\n        if (key === \"ora_reference\") {\n            /* Mounted at scratch mount, strip the .tar.gz from the basename */\n            json_blob['ora-reference'] = get_ora_ref_path(value);\n            continue;\n        }\n        /* If the nirvana reference is parsed through, we also place the nirvana reference into the scratch space */\n        if (key === \"variant_annotation_data\") {\n            /* Mounted at the scratch mount, strip the .tar.gz from the basename */\n            json_blob['variant-annotation-data'] = get_nirvana_ref_path(value);\n            continue;\n        }\n        /* 3. Check if key is in the boolean to numeric list */\n        if (key in DragenNumericBooleanType) {\n            json_blob[key.replace(/_/g, \"-\")] = value ? 1 :0;\n            continue;\n        }\n        /* 4. Check if key is a qc coverage object */\n        if (key === \"qc_coverage\") {\n            /*\n            We need to iterate through the qc coverage objects\n            and add them to the json blob\n            */\n            value.forEach(function (qcObject, index) {\n                json_blob[\"qc-coverage-region-\".concat(index + 1)] = qcObject.region.path;\n                json_blob[\"qc-coverage-reports-\".concat(index + 1)] = qcObject.report_type;\n                if (qcObject.thresholds !== null && qcObject.thresholds !== undefined) {\n                    json_blob[\"qc-coverage-region-\".concat(index + 1, \"-thresholds\")] = qcObject.thresholds.map(function (threshold) { return threshold.toString(); }).join(\",\");\n                }\n            });\n            continue;\n        }\n        /* 5. Get value for standard options */\n        if (props.hasOwnProperty(key)) {\n            /*  We replace snake case with hyphen */\n            json_blob[key.replace(/_/g, \"-\")] = get_value_for_config(value);\n        }\n    }\n    /* Part 2 - Convert the json blob to toml */\n    return json_to_toml(json_blob);\n}\nfunction generate_sequence_data_mount_points(sequence_data, tumor_sequence_data) {\n    /*\n    Create and add in the fastq list csv for the input fastqs\n    If the input is bam or cram, we also mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the sequence data */\n    if (\"fastq_list_rows\" in sequence_data && sequence_data.fastq_list_rows !== undefined) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _i = 0, _a = sequence_data.fastq_list_rows; _i < _a.length; _i++) {\n            var fastq_list_row = _a[_i];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in sequence_data && sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.bam_input.secondaryFiles) {\n            sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in sequence_data && sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.cram_input.secondaryFiles) {\n            sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (sequence_data.cram_reference.secondaryFiles) {\n                sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Can exist here if germline-only */\n    if (!tumor_sequence_data) {\n        /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n        return e;\n    }\n    /*  Add the tumor sequence data */\n    if (\"fastq_list_rows\" in tumor_sequence_data && tumor_sequence_data.fastq_list_rows !== undefined) {\n        /* Upload the csv */\n        e.push({\n            \"entryname\":get_tumor_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(tumor_sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _b = 0, _c = tumor_sequence_data.fastq_list_rows; _b < _c.length; _b++) {\n            var fastq_list_row = _c[_b];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in tumor_sequence_data && tumor_sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.bam_input.secondaryFiles) {\n            tumor_sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in tumor_sequence_data && tumor_sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.cram_input.secondaryFiles) {\n            tumor_sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (tumor_sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":tumor_sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_sequence_data.cram_reference.secondaryFiles) {\n                tumor_sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_alignment_data_mount_points(alignment_data, tumor_alignment_data) {\n    /*\n    If the input is bam or cram, we mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the alignment data data */\n    if (\"bam_input\" in alignment_data && alignment_data.bam_input !== undefined) {\n        /* Add in the bam file */\n        e.push({\n            \"entryname\":alignment_data.bam_input.basename,\n            /* Due to the secondary files, we need to manually add in each file object */\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.bam_input.secondaryFiles) {\n            alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in alignment_data && alignment_data.cram_input !== undefined) {\n        /* Add in the cram file */\n        e.push({\n            \"entryname\":alignment_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.cram_input.secondaryFiles) {\n            alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (alignment_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":alignment_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":alignment_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (alignment_data.cram_reference.secondaryFiles) {\n                alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Now repeat for tumor alignment data */\n    if (tumor_alignment_data) {\n        /*  Add the alignment data data */\n        if (\"bam_input\" in tumor_alignment_data && tumor_alignment_data.bam_input !== undefined) {\n            /* Add in the bam file */\n            e.push({\n                \"entryname\":tumor_alignment_data.bam_input.basename,\n                /* Due to the secondary files, we need to manually add in each file object */\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.bam_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.bam_input.secondaryFiles) {\n                tumor_alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n        else if (\"cram_input\" in tumor_alignment_data && tumor_alignment_data.cram_input !== undefined) {\n            /* Add in the cram file */\n            e.push({\n                \"entryname\":tumor_alignment_data.cram_input.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.cram_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.cram_input.secondaryFiles) {\n                tumor_alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n            /*  We also add in the reference file if its provided */\n            if (tumor_alignment_data.cram_reference !== undefined) {\n                e.push({\n                    \"entryname\":tumor_alignment_data.cram_reference.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":tumor_alignment_data.cram_reference.location\n                    }\n                });\n                /* Then add in each secondary file object */\n                if (tumor_alignment_data.cram_reference.secondaryFiles) {\n                    tumor_alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                        e.push({\n                            \"entryname\":secondary_file_iter_.basename,\n                            \"entry\":{\n                                \"class\":\"File\",\n                                \"location\":secondary_file_iter_.location\n                            }\n                        });\n                    });\n                }\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_mv_qc_files_script_mount_points(options_list) {\n    /*\n     If alignment_options.qc_coverage is defined, we generate a script to move the qc files to their name attribute\n    */\n    var qc_files_script = generate_mv_qc_files_script(options_list);\n    if (!qc_files_script) {\n        return [];\n    }\n    else {\n        return [\n            {\n                entryname:qc_files_script.basename,\n                /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n                entry:qc_files_script\n            }\n        ];\n    }\n}\nfunction strip_uri_from_name(name_with_uri) {\n    /*\n    Given a string as a uri, return all after the trailing hash\n     */\n    return name_with_uri.split('#').pop() || name_with_uri;\n}\nfunction generate_mv_qc_files_script(options_list) {\n    /*\n    Generate mv qc files script\n     */\n    /* Check if alignment_options.qc_coverage is defined */\n    if (!options_list.alignment_options.qc_coverage || options_list.alignment_options.qc_coverage.length === 0) {\n        return null;\n    }\n    /* Initialise vars */\n    var output_file_prefix = options_list.output_file_prefix;\n    var output_directory = options_list.output_directory;\n    /* Initialise the script */\n    var mv_qc_files_script = \"#!/usr/bin/env bash\\n\\n\";\n    mv_qc_files_script += \"# Exit on failure\\n\";\n    mv_qc_files_script += \"set -euo pipefail\\n\\n\";\n    mv_qc_files_script += \"# Log start\\n\";\n    mv_qc_files_script += \"echo \\\"Start Moving QC files\\\" 1>&2\\n\\n\";\n    /* Arrays to make */\n    var qc_files_suffixes = [\n        /* Germline */\n        \"contig_mean_cov.csv\",\n        \"cov_report.bed\",\n        \"coverage_metrics.csv\",\n        \"fine_hist.csv\",\n        \"hist.csv\",\n        \"overall_mean_cov.csv\",\n        \"read_cov_report.bed\",\n        /* Somatic */\n        \"contig_mean_cov_normal.csv\",\n        \"contig_mean_cov_tumor.csv\",\n        \"cov_report_normal.bed\",\n        \"cov_report_tumor.bed\",\n        \"coverage_metrics_normal.csv\",\n        \"coverage_metrics_tumor.csv\",\n        \"fine_hist_normal.csv\",\n        \"fine_hist_tumor.csv\",\n        \"hist_normal.csv\",\n        \"hist_tumor.csv\",\n        \"overall_mean_cov_normal.csv\",\n        \"overall_mean_cov_tumor.csv\",\n        \"read_cov_report_normal.bed\",\n        \"read_cov_report_tumor.bed\",\n        \"somatic_callable_regions.bed\",\n    ];\n    var qc_file_names = options_list.alignment_options.qc_coverage.map(function (qc_coverage) { return strip_uri_from_name(qc_coverage.name); });\n    /* Create the qc suffixes array */\n    mv_qc_files_script += \"# Initialise coverage arrays \\n\";\n    mv_qc_files_script += \"QC_SUFFIXES=( \\\\\\n\";\n    for (var _i = 0, qc_files_suffixes_1 = qc_files_suffixes; _i < qc_files_suffixes_1.length; _i++) {\n        var qc_suffix = qc_files_suffixes_1[_i];\n        mv_qc_files_script += \"  \\\"\".concat(qc_suffix, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* QC Array complete */\n    /* Create the array of qc names */\n    mv_qc_files_script += \"QC_COVERAGE_NAMES=( \\\\\\n\";\n    for (var _a = 0, qc_file_names_1 = qc_file_names; _a < qc_file_names_1.length; _a++) {\n        var qc_coverage_name = qc_file_names_1[_a];\n        mv_qc_files_script += \"  \\\"\".concat(qc_coverage_name, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* Now iterate through each qc name and suffix to move the files */\n    mv_qc_files_script += \"# Move the QC files to the output directory\\n\";\n    mv_qc_files_script += \"for qc_name_idx in \\\"${!QC_COVERAGE_NAMES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"  qc_name=\\\"${QC_COVERAGE_NAMES[$qc_name_idx]}\\\"\\n\";\n    mv_qc_files_script += \"  for qc_suffix in \\\"${QC_SUFFIXES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"    if [[ -f \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" ]]; then\\n\");\n    mv_qc_files_script += \"      mv \\\\\\n\";\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" \\\\\\n\");\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-${qc_name}_${qc_suffix}\\\"\\n\");\n    mv_qc_files_script += \"    fi\\n\";\n    mv_qc_files_script += \"  done\\n\";\n    mv_qc_files_script += \"done\\n\\n\";\n    mv_qc_files_script += \"# Log completion\\n\";\n    mv_qc_files_script += \"echo \\\"Finish Moving QC files\\\" 1>&2\\n\";\n    return {\n        class:\"File\",\n        basename:\"mv_qc_files.sh\",\n        contents:mv_qc_files_script\n    };\n}\nfunction dragen_merge_options(options_list) {\n    /*\n    Merge a list of objects, ignoring null or undefined values\n    Options are merged in the order they are provided\n    So if there are duplicate keys, the last one will be used\n    */\n    var merged_options = {};\n    for (var _i = 0, options_list_1 = options_list; _i < options_list_1.length; _i++) {\n        var options_object = options_list_1[_i];\n        if (options_object === null || options_object === undefined) {\n            continue;\n        }\n        for (var key in options_object) {\n            /*\n             Check if the key is null or undefined.\n            */\n            if (options_object[key] === undefined) {\n                continue;\n            }\n            /*\n              If the merged key does NOT exist in the merged options but the value is null we add it in\n            */\n            if ((!merged_options.hasOwnProperty(key)) && options_object[key] === null) {\n                merged_options[key] = null;\n                continue;\n            }\n            /*\n              If the merged key DOES exist in the merged options but the value is null we skip it\n            */\n            if (merged_options.hasOwnProperty(key) && options_object[key] === null) {\n                continue;\n            }\n            /*\n              If the key already exists in merged options, check if the\n              merged_options key is a dictionary, if so we need to recursively merge instead\n            */\n            if (merged_options.hasOwnProperty(key) &&\n                typeof merged_options[key] === 'object' &&\n                (merged_options[key] !== null) &&\n                !Array.isArray(merged_options[key])) {\n                /*\n                  Check the item key is also an object\n                */\n                if (typeof options_object[key] === 'object' && !Array.isArray(options_object[key])) {\n                    /*\n                      If the key is an object, we merge the two objects\n                      This is useful for options that have sub-options\n                      However we dont to override values in merged_options that are already set\n                      if the value in the options object is null,\n                      we can solve this by calling the dragen_merge_options function recursively\n                    */\n                    merged_options[key] = dragen_merge_options([\n                        merged_options[key],\n                        options_object[key]\n                    ]);\n                }\n                /*\n                  Otherwise we just override it.\n                */\n                else {\n                    merged_options[key] = options_object[key];\n                }\n                continue;\n            }\n            /*\n            Just a standard option.\n            */\n            if (options_object.hasOwnProperty(key)) {\n                merged_options[key] = options_object[key];\n            }\n        }\n    }\n    return merged_options;\n}\nfunction get_dragen_wgts_dna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name ? props.sample_name :\"\", \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction get_dragen_wgts_rna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name, \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_rna_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Set enable rna to true */\n        enable_rna:true,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction filter_object_by_keys(object1, object2) {\n    /**\n     * Return object 1 with only the keys that are in object 2\n     */\n    var filtered_object = {};\n    /* Dont need to filter if object1 is null or undefined */\n    if (object1 === null || object1 === undefined) {\n        return object2;\n    }\n    /* Iterate through object1 and check if the key is in object2 */\n    for (var key in object1) {\n        if (object2.hasOwnProperty(key)) {\n            filtered_object[key] = object1[key];\n        }\n    }\n    return filtered_object;\n}\nfunction get_dragen_wgts_dna_variant_calling_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /*\n        Naming things\n        */\n        sample_name:props.sample_name,\n        tumor_sample_name:props.tumor_sample_name,\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        tumor_sequence_data:props.tumor_sequence_data,\n        ref_tar:props.reference.tarball,\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:(props.tumor_sample_name ? props.tumor_sample_name :props.sample_name),\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:((props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") +\n            props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__\" +\n            \"dragen_wgts_dna_\" + (props.tumor_sample_name ? \"somatic\" :\"germline\") + \"_variant_calling\"),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        /* SNV caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        /* CNV caller options */\n        cnv_caller_options:props.cnv_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* SV caller options */\n        sv_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.sv_caller_options),\n            props.sv_caller_options,\n        ]),\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n        /* Targeted Caller options */\n        targeted_caller_options:props.targeted_caller_options,\n        /* Mrjd Options */\n        mrjd_options:props.mrjd_options,\n        /* TMB Options */\n        tmb_options:props.tmb_options,\n        /* MSI Options */\n        msi_options:props.msi_options,\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n    };\n}\nfunction get_dragen_wgts_rna_variant_calling_stage_options_from_pipeline(props) {\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Annotation file, used for a lot of the variant calling options */\n        annotation_file:props.annotation_file,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:props.sample_name,\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:(props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__dragen_wgts_rna_variant_calling\"),\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        gene_expression_quantification_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.gene_expression_quantification_options),\n            props.gene_expression_quantification_options,\n        ]),\n        gene_fusion_detection_options:props.gene_fusion_detection_options,\n        splice_variant_caller_options:props.splice_variant_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n    };\n}\n/**\n * Multiqc functions\n *\n */\nfunction get_wgts_dna_multiqc_output_filename(props) {\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc_report.html\";\n}\nfunction get_wgts_rna_multiqc_output_filename(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc_report.html\";\n}\nfunction get_wgts_dna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc\";\n}\nfunction get_wgts_rna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc\";\n}\nfunction get_wgts_dna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS DNA Pipeline ( \" +\n        (props.tumor_sample_name ? props.tumor_sample_name + \"/\" :\"\") +\n        props.sample_name + \" )\");\n}\nfunction get_wgts_rna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS RNA Pipeline ( \" +\n        props.sample_name +\n        \" )\");\n}\nfunction pick_first_non_null(object_list) {\n    for (var _i = 0, object_list_1 = object_list; _i < object_list_1.length; _i++) {\n        var object = object_list_1[_i];\n        if (object) {\n            return object;\n        }\n    }\n}\nfunction pick_all_non_null(object_list) {\n    var non_null_objects = [];\n    for (var _i = 0, object_list_2 = object_list; _i < object_list_2.length; _i++) {\n        var object = object_list_2[_i];\n        if (object) {\n            non_null_objects.push(object);\n        }\n    }\n    return non_null_objects;\n}\nfunction dragen_references_match(reference_list) {\n    /*\n    Determine if the two references match,\n    If one the references is null or undefined then still return true\n    Since we really just want to know if we have two different references\n    */\n    if (reference_list.length !== 2) {\n        throw new Error(\"dragen_references_match:reference_list must be of length 2\");\n    }\n    /* Check if either of the references are null or undefined */\n    if (!reference_list[0] || !reference_list[1]) {\n        return true;\n    }\n    return reference_list[0].tarball.location == reference_list[1].tarball.location;\n}\n/* Utility functions */\nfunction get_optional_attribute_from_object(input_object, attribute) {\n    /*\n    Get attribute from object, if attribute is not defined return null\n    Assume the input object is an object of key value pairs where we know the key is of type string\n    stackoverflow.com/questions/56833469/typescript-error-ts7053-element-implicitly-has-an-any-type\n    */\n    if (input_object.hasOwnProperty(attribute)) {\n        return input_object[attribute];\n    }\n    else {\n        return null;\n    }\n}\nfunction get_attribute_from_optional_input(input_object, attribute) {\n    /*\n    Get attribute from optional input -\n    If input is not defined, then return null\n    */\n    if (input_object === null || input_object === undefined) {\n        return null;\n    }\n    else {\n        return get_optional_attribute_from_object(input_object, attribute);\n    }\n}\nfunction is_not_null(input_obj) {\n    /*\n    Determine if input object is defined and is not null\n    */\n    return !(input_obj === null || input_obj === undefined);\n}\n"
          ],
          "class": "InlineJavascriptRequirement"
        },
        {
          "tmpdirMin": "${\n  /* 1 Tb */\n  return Math.pow(2, 20);\n}\n",
          "class": "ResourceRequirement"
        }
      ],
      "baseCommand": [
        "bash",
        "run_nirvana_download.sh"
      ],
      "inputs": [
        {
          "label": "annotations type",
          "doc": "Annotations type, one of all, germline_tagging, tmb\nIf not \"all\" we will download \"all\" as well\n",
          "type": [
            "null",
            {
              "type": "enum",
              "symbols": [
                "#dragen-nirvana-downloader__4.4.4.cwl/dragen-nirvana-downloader--4.4.4/annotations_type/all",
                "#dragen-nirvana-downloader__4.4.4.cwl/dragen-nirvana-downloader--4.4.4/annotations_type/germline_tagging",
                "#dragen-nirvana-downloader__4.4.4.cwl/dragen-nirvana-downloader--4.4.4/annotations_type/tmb"
              ]
            }
          ],
          "default": "all",
          "id": "#dragen-nirvana-downloader__4.4.4.cwl/dragen-nirvana-downloader--4.4.4/annotations_type"
        },
        {
          "label": "genome version",
          "doc": "Genome version, one of GRCh37, GRCh38\n",
          "type": [
            "null",
            {
              "type": "enum",
              "symbols": [
                "#dragen-nirvana-downloader__4.4.4.cwl/dragen-nirvana-downloader--4.4.4/genome_version/GRCh37",
                "#dragen-nirvana-downloader__4.4.4.cwl/dragen-nirvana-downloader--4.4.4/genome_version/GRCh38"
              ]
            }
          ],
          "default": "GRCh38",
          "id": "#dragen-nirvana-downloader__4.4.4.cwl/dragen-nirvana-downloader--4.4.4/genome_version"
        }
      ],
      "outputs": [
        {
          "label": "nirvana assembly tarball",
          "doc": "The downloaded nirvana assembly tar.gz file\n",
          "type": "File",
          "outputBinding": {
            "glob": "nirvana_assembly_$(inputs.genome_version).tar.gz"
          },
          "id": "#dragen-nirvana-downloader__4.4.4.cwl/dragen-nirvana-downloader--4.4.4/nirvana_assembly_tarball"
        }
      ],
      "successCodes": [
        0
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "CommandLineTool",
      "id": "#dragen-wgts-dna-variant-calling-step__4.4.6.cwl",
      "label": "dragen-variant-calling-step v(4.4.6)",
      "doc": "Documentation for dragen-variant-calling-step v4.4.0\n",
      "hints": [
        {
          "dockerPull": "079623148045.dkr.ecr.us-east-1.amazonaws.com/cp-prod/1df60bef-1edb-4efc-a50c-8e9625b5e60d:latest",
          "class": "DockerRequirement"
        },
        {
          "coresMin": 24,
          "ramMin": 256000,
          "class": "ResourceRequirement",
          "https://platform.illumina.com/rdf/ica/resources:tier": "standard",
          "https://platform.illumina.com/rdf/ica/resources:type": "fpga2",
          "https://platform.illumina.com/rdf/ica/resources:size": "medium"
        }
      ],
      "requirements": [
        {
          "listing": [
            {
              "entryname": "$(get_dragen_config_path())",
              "entry": "${\n\n  /*\n    Check if theres any tumor sequence data in bam/cram format,\n    if so rename bam / cram input params to have tumor_ prefix\n  */\n  var tumor_sequence_data = {};\n  if (inputs.dragen_options.tumor_sequence_data){\n    /* Check what data type we have */\n    if (inputs.dragen_options.tumor_sequence_data.fastq_list_rows){\n       /* Has fastq list rows */\n       tumor_sequence_data[\"tumor_fastq_list_rows\"] = inputs.dragen_options.tumor_sequence_data.fastq_list_rows;\n    } else if (inputs.dragen_options.tumor_sequence_data.bam_input){\n      /* Has bam input */\n      tumor_sequence_data[\"tumor_bam_input\"] = inputs.dragen_options.tumor_sequence_data.bam_input;\n    } else {\n      /* Has cram input */\n      tumor_sequence_data[\"tumor_cram_input\"] = inputs.dragen_options.tumor_sequence_data.cram_input;\n\n      /* Check for cram reference */\n      if (inputs.dragen_options.tumor_sequence_data.cram_reference){\n        /* Has cram reference */\n        tumor_sequence_data[\"tumor_cram_reference\"] = inputs.dragen_options.tumor_sequence_data.cram_reference;\n      }\n    }\n  }\n\n  /*\n  Check lic-instance-id-location is not undefined\n  */\n  if (!inputs.dragen_options.lic_instance_id_location){\n    /* Use the global lic-instance-id-location default value */\n    var lic_instance_id_location = DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH;\n  } else {\n    /* Use the user defined lic-instance-id-location */\n    var lic_instance_id_location = inputs.dragen_options.lic_instance_id_location;\n  }\n\n  return dragen_to_config_toml(\n    dragen_merge_options(\n      [\n         /* Input data */\n         inputs.dragen_options.sequence_data,\n         tumor_sequence_data,\n         /* Alignment options */\n         inputs.dragen_options.alignment_options,\n         /* SNV VC Options */\n         inputs.dragen_options.snv_variant_caller_options,\n         /* CNV Options */\n         inputs.dragen_options.cnv_caller_options,\n         /* MAF Conversion Options */\n         inputs.dragen_options.maf_conversion_options,\n         /* SV Caller Options */\n         inputs.dragen_options.sv_caller_options,\n         /* Nirvana Annotation Options */\n         inputs.dragen_options.nirvana_annotation_options,\n         /* Targeted Caller Options */\n         inputs.dragen_options.targeted_caller_options,\n         /* MRJD Options */\n         inputs.dragen_options.mrjd_options,\n         /* TMB Options */\n         inputs.dragen_options.tmb_options,\n         /* MSI Options */\n         inputs.dragen_options.msi_options,\n         /* Dragen mandatory options */\n         {\n            \"output_directory\": inputs.dragen_options.output_directory,\n            \"output_file_prefix\": inputs.dragen_options.output_file_prefix,\n            \"ref_tar\": inputs.dragen_options.ref_tar,\n            \"lic_instance_id_location\": lic_instance_id_location,\n            \"ora_reference\": inputs.dragen_options.ora_reference,\n         },\n         /* VC Mandatory options */\n         {\n            /* We push this to /scratch */\n            \"intermediate_results_dir\": get_intermediate_results_dir(),\n            /* Force enable parameters */\n            /* We now align in this step too to prevent a double invocation of the dragen license charge */\n            \"enable_map_align\": true,\n            \"enable_map_align_output\": true,\n            \"enable_variant_caller\": true\n         }\n      ]\n    )\n  );\n}\n"
            },
            {
              "entryname": "run_dragen.sh",
              "entry": "#!/usr/bin/env bash\n\n# Fail on non-zero exit of subshell\nset -euo pipefail\n\n# Reset dragen\n/opt/edico/bin/dragen_reset\n\n# Create directories\nmkdir --parents \\\\\n  \"$(get_ref_mount())\" \\\\\n  \"$(get_intermediate_results_dir())\" \\\\\n  \"$(inputs.dragen_options.output_directory)\"\n\n# untar ref data into scratch space\ntar \\\\\n  --directory \"$(get_ref_mount())\" \\\\\n  --extract \\\\\n  --use-compress-program pigz \\\\\n  --file \"$(inputs.dragen_options.ref_tar.path)\"\n\n# Check if ora reference is set\nif [[ \"$(is_not_null(inputs.dragen_options.ora_reference))\" == \"true\" ]]; then\n  mkdir --parents \\\\\n    \"$(get_ora_ref_mount())\"\n  tar \\\\\n    --directory \"$(get_ora_ref_mount())\" \\\\\n    --extract \\\\\n    --use-compress-program pigz \\\\\n    --file \"$(get_attribute_from_optional_input(inputs.dragen_options.ora_reference, \"path\"))\"\nfi\n\n# Check if nirvana annotation options are set\nif [[ \"$(is_not_null(inputs.dragen_options.nirvana_annotation_options) && is_not_null(inputs.dragen_options.nirvana_annotation_options.variant_annotation_data))\" == \"true\" ]]; then\n  mkdir --parents \\\\\n    \"$(get_nirvana_ref_mount())\"\n  tar \\\\\n    --directory \"$(get_nirvana_ref_mount())\" \\\\\n    --extract \\\\\n    --use-compress-program pigz \\\\\n    --file \"$(get_variant_annotation_data_mount(inputs.dragen_options.nirvana_annotation_options))\"\nfi\n\n# Copy over the config.toml file to the output directory too\ncp \"$(get_dragen_config_path())\" \"$(inputs.dragen_options.output_directory)/$(inputs.dragen_options.output_file_prefix).config.toml\"\n\n# Run dragen command and import options from cli\n\"$(get_dragen_bin_path())\" \"\\${@}\"\n\n# Rename normal bam file if we ran the somatic workflow\n# below is js function is_not_null(inputs.dragen_options.tumor_sequence_data) == \"true\"\n# This may look like \"true\" == \"true\" when the script is written\nif [[ \"$(is_not_null(inputs.dragen_options.tumor_sequence_data))\" == \"true\" ]]; then\n  # Normal bam file is currently named \"output_file_prefix.bam\", where output_file_prefix is the name of the tumor sample\n  # It should instead be named \"sample_name_normal.bam\", to match \"tumor_sample_name_tumor.bam\".\n  # We will also need to rename the bai and .md5sum secondary files\n  mv \"$(inputs.dragen_options.output_directory)/$(inputs.dragen_options.output_file_prefix).bam\" \"$(inputs.dragen_options.output_directory)/$(inputs.dragen_options.sample_name)_normal.bam\"\n  mv \"$(inputs.dragen_options.output_directory)/$(inputs.dragen_options.output_file_prefix).bam.bai\" \"$(inputs.dragen_options.output_directory)/$(inputs.dragen_options.sample_name)_normal.bam.bai\"\n  mv \"$(inputs.dragen_options.output_directory)/$(inputs.dragen_options.output_file_prefix).bam.md5sum\" \"$(inputs.dragen_options.output_directory)/$(inputs.dragen_options.sample_name)_normal.bam.md5sum\"\nfi\n\n# Rename qc stats if we set\n# below is js function is_not_null(inputs.dragen_options.alignment_options.qc_coverage) == \"true\"\n# This may look like \"true\" == \"true\" when the script is written or \"false\" == \"true\"\nif [[ \"$(is_not_null(inputs.dragen_options.alignment_options.qc_coverage))\" == \"true\" ]]; then\n    bash \"mv_qc_files.sh\"\nfi\n"
            },
            "${\n  return generate_sequence_data_mount_points(inputs.dragen_options.sequence_data, inputs.dragen_options.tumor_sequence_data);\n}\n",
            "${\n  return generate_mv_qc_files_script_mount_points(inputs.dragen_options);\n}\n"
          ],
          "class": "InitialWorkDirRequirement"
        },
        {
          "expressionLib": [
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Globals */\n/*\nList of options that are booleans but where the values are expressed as a number\n*/\nvar DragenNumericBooleanType = [\n    \"global\",\n    \"all\"\n];\nvar DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH = '/opt/instance-identity';\n/*  Functions */\nfunction get_scratch_mount() {\n    /*\n    Return the path of the scratch directory space\n    */\n    return \"/scratch/\";\n}\nfunction get_intermediate_results_dir() {\n    /*\n    Get intermediate results directory as /scratch for dragen runs\n    */\n    return get_scratch_mount() + \"intermediate-results/\";\n}\nfunction get_name_root_from_tarball(basename) {\n    var tar_ball_regex = /(\\S+)\\.tar(?:\\.gz)?/g;\n    var tar_ball_expression = tar_ball_regex.exec(basename);\n    if (tar_ball_expression === null) {\n        throw new Error(\"Could not get nameroot from \".concat(basename));\n    }\n    return tar_ball_expression[1];\n}\nfunction get_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_ref_mount() {\n    /*\n    Get the reference mount point\n    */\n    return get_scratch_mount() + \"ref/\";\n}\nfunction get_ora_ref_mount() {\n    /*\n    Get the ORA reference mount point\n    */\n    return get_scratch_mount() + \"ora-reference/\";\n}\nfunction get_ora_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ora_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_nirvana_ref_mount() {\n    /*\n    Get the Nirvana reference mount point\n    */\n    return get_scratch_mount() + \"nirvana-reference/\";\n}\nfunction get_nirvana_ref_path(reference_input_obj) {\n    return get_nirvana_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_variant_annotation_data_mount(nirvana_annotation_options) {\n    if (!nirvana_annotation_options) {\n        return null;\n    }\n    if (!nirvana_annotation_options.variant_annotation_data) {\n        return null;\n    }\n    return get_attribute_from_optional_input(nirvana_annotation_options.variant_annotation_data, \"path\");\n}\nfunction get_dragen_bin_path() {\n    /*\n    Get dragen bin path\n    */\n    return \"/opt/edico/bin/dragen\";\n}\nfunction get_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"fastq_list.csv\";\n}\nfunction get_tumor_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"tumor_fastq_list.csv\";\n}\nfunction capitalizeFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction json_to_toml(json_data) {\n    /*  Convert JSON to TOML format */\n    /*  Much easier than the other way around */\n    /*  Initialize an empty string to store the TOML data */\n    var toml_data = '';\n    var global_keys_list = [];\n    /*  Iterate through each key in the JSON object to first find the 'global' keys */\n    for (var key in json_data) {\n        var value = json_data[key];\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            continue;\n        }\n        global_keys_list.push(key);\n    }\n    var _loop_1 = function (key) {\n        var value = json_data[key];\n        if (value === null) {\n            return \"continue\";\n        }\n        /*  If the value is an array, we need to make an entry for each item in the array */\n        else if (Array.isArray(value)) {\n            value.forEach(function (item) {\n                toml_data += \"\".concat(key, \" = \").concat(item, \"\\n\");\n            });\n        }\n        else {\n            /*  Regular append */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    };\n    /*  Add global keys to the TOML data first */\n    for (var _i = 0, global_keys_list_1 = global_keys_list; _i < global_keys_list_1.length; _i++) {\n        var key = global_keys_list_1[_i];\n        _loop_1(key);\n    }\n    /*  Iterate through each key in the JSON object */\n    for (var key in json_data) {\n        var value = json_data[key];\n        /*  Skip global keys */\n        if (global_keys_list.indexOf(key) !== -1) {\n            continue;\n        }\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"File\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is a directory, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"Directory\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is an object, treat it as a section */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            /*  Section header should have a capitalized first letter */\n            toml_data += \"[\".concat(capitalizeFirstLetter(key), \"]\\n\");\n            for (var sub_key in value) {\n                toml_data += \"\".concat(sub_key, \" = \").concat(value[sub_key], \"\\n\");\n            }\n        }\n        /*  If the value is a string, treat it as a key-value pair */\n        else {\n            /*  Otherwise, treat it as a key-value pair */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    }\n    /*  Return the TOML data */\n    return toml_data;\n}\n/* Convert TOML to JSON format */\nfunction toml_to_json(toml_str) {\n    /*\n    Convert TOML to JSON format.\n    This implementation uses a simple TOML parser for basic key-value pairs and sections.\n    For production use, consider using a library like `@iarna/toml` or `toml`.\n    */\n    var result = {};\n    var currentSection = null;\n    var lines = toml_str.split(/\\r?\\n/);\n    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n        var line = lines_1[_i];\n        line = line.trim();\n        if (!line || line.startsWith(\"#\"))\n            continue;\n        /*  Section header */\n        var sectionMatch = line.match(/^\\[(.+)\\]$/);\n        if (sectionMatch) {\n            /*  Make section lowercase */\n            currentSection = sectionMatch[1].toLowerCase().trim();\n            if (!result[currentSection]) {\n                result[currentSection] = {};\n            }\n            continue;\n        }\n        /*  Key-value pair */\n        var kvMatch = line.match(/^([^=]+)=(.*)$/);\n        if (kvMatch) {\n            var key = kvMatch[1].trim();\n            var value = kvMatch[2].trim();\n            /*  Check if value is empty */\n            if ((value === \"\")) {\n                value = null;\n            }\n            /*  Remove quotes if present */\n            else if ((value.startsWith('\"') && value.endsWith('\"')) ||\n                (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n                value = value.slice(1, -1);\n            }\n            else if (value === \"true\" || value === \"false\") {\n                value = value === \"true\";\n            }\n            else if (!isNaN(Number(value))) {\n                value = Number(value);\n            }\n            /* Set the key name by replacing hyphens with underscores */\n            key = key.replace(/-/g, '_');\n            /* Replace hyphens with underscores in the key */\n            if (currentSection) {\n                /* Check if the key exists in the current section */\n                if (result[currentSection].hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[currentSection][key])) {\n                        /* Push the entry */\n                        result[currentSection][key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[currentSection][key] !== undefined) {\n                            result[currentSection][key] = [result[currentSection][key], value];\n                        }\n                        else {\n                            result[currentSection][key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[currentSection][key] = value;\n                }\n            }\n            else {\n                /* Check if the key exists */\n                if (result.hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[key])) {\n                        /* Push the entry */\n                        result[key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[key] !== undefined) {\n                            result[key] = [result[key], value];\n                        }\n                        else {\n                            result[key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[key] = value;\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction build_fastq_list_csv_header(header_names) {\n    /*\n    Convert lowercase labels to uppercase values\n    i.e\n    [ \"rgid\", \"rglb\", \"rgsm\", \"lane\", \"read_1\", \"read_2\" ]\n    to\n    \"RGID,RGLB,RGSM,Lane,Read1File,Read2File\"\n    */\n    var modified_header_names = [];\n    for (var _i = 0, header_names_1 = header_names; _i < header_names_1.length; _i++) {\n        var header_name = header_names_1[_i];\n        if (header_name.indexOf(\"rg\") === 0) {\n            /*\n            rgid -> RGID\n            */\n            modified_header_names.push(header_name.toUpperCase());\n        }\n        else if (header_name.indexOf(\"read\") === 0) {\n            /*\n            read_1 -> Read1File\n            */\n            modified_header_names.push(\"Read\" + header_name.charAt(header_name.length - 1) + \"File\");\n        }\n        else {\n            /*\n            lane to Lane\n            */\n            modified_header_names.push(header_name[0].toUpperCase() + header_name.substr(1));\n        }\n    }\n    /*\n    Convert array to comma separated strings\n    */\n    return modified_header_names.join(\",\") + \"\\n\";\n}\nfunction get_fastq_list_row_as_csv_row(fastq_list_row, row_order) {\n    var fastq_list_row_values_array = [];\n    /*  This for loop is here to ensure were assigning values in the same order as the header */\n    for (var _i = 0, row_order_1 = row_order; _i < row_order_1.length; _i++) {\n        var item_index = row_order_1[_i];\n        var found_item = false;\n        /*  Find matching attribute in this row */\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            var fastq_list_row_field_value = fastq_list_row[fastq_list_row_field_name];\n            if (fastq_list_row_field_value === null) {\n                /*\n                Item not found, add an empty attribute for this cell in the csv\n                */\n                continue;\n            }\n            /*  The header value matches the name in the item */\n            if (fastq_list_row_field_name === item_index) {\n                /*\n                If the field value has a class attribute then it's either read_1 or read_2\n                */\n                if (fastq_list_row_field_value.hasOwnProperty(\"class\")) {\n                    var fastq_list_row_field_value_file = fastq_list_row_field_value;\n                    /*\n                    Assert that this is actually of class file\n                    */\n                    if (fastq_list_row_field_value_file.class !== \"File\") {\n                        continue;\n                    }\n                    /*  Read 1 and 2 files are mounted as rgid/filename */\n                    fastq_list_row_values_array.push(fastq_list_row.rgid + '/' + fastq_list_row_field_value_file.basename);\n                }\n                else {\n                    /*\n                    Push the string attribute to the fastq list csv row\n                    Replace any commas in the string with ' -'\n                    */\n                    fastq_list_row_values_array.push(fastq_list_row_field_value.toString().replace(/,/g, \" -\"));\n                }\n                found_item = true;\n                break;\n            }\n        }\n        if (!found_item) {\n            /*\n            Push blank cell if no item found\n            */\n            fastq_list_row_values_array.push(\"\");\n        }\n    }\n    /*\n    Convert to string and return as string\n    */\n    return fastq_list_row_values_array.join(\",\") + \"\\n\";\n}\nfunction generate_fastq_list_csv(fastq_list_rows) {\n    /*\n    Fastq list rows generation\n    */\n    var fastq_csv_file = {\n        class:\"File\",\n        basename:get_fastq_list_csv_path()\n    };\n    /*\n    Set the row order\n    */\n    var row_order = [];\n    /*\n    Set the array order\n    Make sure we iterate through all rows of the array\n    */\n    for (var _i = 0, fastq_list_rows_1 = fastq_list_rows; _i < fastq_list_rows_1.length; _i++) {\n        var fastq_list_row = fastq_list_rows_1[_i];\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            if (row_order.indexOf(fastq_list_row_field_name) === -1) {\n                row_order.push(fastq_list_row_field_name);\n            }\n        }\n    }\n    /*\n    Make header\n    */\n    fastq_csv_file.contents = build_fastq_list_csv_header(row_order);\n    /*\n    For each fastq list row,\n    collect the values of each attribute but in the order of the header\n    */\n    for (var _c = 0, fastq_list_rows_2 = fastq_list_rows; _c < fastq_list_rows_2.length; _c++) {\n        var fastq_list_row = fastq_list_rows_2[_c];\n        /*  Add csv row to file contents */\n        fastq_csv_file.contents += get_fastq_list_row_as_csv_row(fastq_list_row, row_order);\n    }\n    return fastq_csv_file;\n}\nfunction get_value_for_config(valueObj) {\n    /* If valueObj is an IFile, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"File\") {\n        return valueObj.path;\n    }\n    /* If valueObj is an IDirectory, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"Directory\") {\n        return valueObj.path;\n    }\n    /* Recursively call this function for nested objects */\n    if (typeof valueObj === 'object' && !Array.isArray(valueObj)) {\n        var newValueObj = {};\n        for (var key in valueObj) {\n            if (valueObj[key] === null || valueObj[key] === undefined) {\n                continue;\n            }\n            /* Special case - boolean to numeric */\n            if (key in DragenNumericBooleanType) {\n                newValueObj[key.replace(/_/g, \"-\")] = valueObj[key] ? 1 :0;\n                continue;\n            }\n            newValueObj[key.replace(/_/g, \"-\")] = get_value_for_config(valueObj[key]);\n        }\n        return newValueObj;\n    }\n    /* Consider arrays */\n    if (Array.isArray(valueObj)) {\n        return valueObj.map(function (item) { return get_value_for_config(item); });\n    }\n    /* Otherwise return the value as is */\n    return valueObj;\n}\nfunction get_dragen_config_path() {\n    return \"dragen_config.toml\";\n}\nfunction dragen_to_config_toml(props) {\n    /* Part 1 - Generate the json blob */\n    var json_blob = {};\n    for (var key in props) {\n        /* Get props key value */\n        var value = props[key];\n        /* Skip null props */\n        if (value === null || value === undefined) {\n            continue;\n        }\n        /*  FIXME denovo to DeNovo */\n        /* Special cases */\n        /* 1. Fastq list rows we rename to 'fastq-list',\n            alignment data mounted at the base of the working directory\n        */\n        /* Sequence data */\n        if (key === \"fastq_list_rows\") {\n            json_blob[\"fastq-list\"] = get_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"bam_input\") {\n            json_blob[\"bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_input\") {\n            json_blob[\"cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_reference\") {\n            json_blob[\"cram-reference\"] = value.basename;\n            continue;\n        }\n        /* Tumor sequence data */\n        if (key === \"tumor_fastq_list_rows\") {\n            json_blob['tumor-fastq-list'] = get_tumor_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"tumor_bam_input\") {\n            json_blob[\"tumor-bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_input\") {\n            json_blob[\"tumor-cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_reference\") {\n            json_blob[\"tumor-cram-reference\"] = value.basename;\n            continue;\n        }\n        /* 2. If ref-tar is parsed through, we use ref-dir instead */\n        if (key === \"ref_tar\") {\n            json_blob['ref-dir'] = get_ref_mount() + value.basename.replace(/\\.tar\\.gz$/, \"\");\n            /*\n                If the ref_tar does not contain 'graph',\n                then we also need to add the parameter,\n                --validate-pangenome-reference=false,\n                this was in place when we wanted to align genome to linear somatic reference\n                however, we are no longer doing that so this parameter is not needed\n            */\n            if (!value.basename.includes(\"graph\")) {\n                json_blob['validate-pangenome-reference'] = false;\n            }\n            continue;\n        }\n        /* If the ora reference is parsed through, we also place the ora reference into the scratch space */\n        if (key === \"ora_reference\") {\n            /* Mounted at scratch mount, strip the .tar.gz from the basename */\n            json_blob['ora-reference'] = get_ora_ref_path(value);\n            continue;\n        }\n        /* If the nirvana reference is parsed through, we also place the nirvana reference into the scratch space */\n        if (key === \"variant_annotation_data\") {\n            /* Mounted at the scratch mount, strip the .tar.gz from the basename */\n            json_blob['variant-annotation-data'] = get_nirvana_ref_path(value);\n            continue;\n        }\n        /* 3. Check if key is in the boolean to numeric list */\n        if (key in DragenNumericBooleanType) {\n            json_blob[key.replace(/_/g, \"-\")] = value ? 1 :0;\n            continue;\n        }\n        /* 4. Check if key is a qc coverage object */\n        if (key === \"qc_coverage\") {\n            /*\n            We need to iterate through the qc coverage objects\n            and add them to the json blob\n            */\n            value.forEach(function (qcObject, index) {\n                json_blob[\"qc-coverage-region-\".concat(index + 1)] = qcObject.region.path;\n                json_blob[\"qc-coverage-reports-\".concat(index + 1)] = qcObject.report_type;\n                if (qcObject.thresholds !== null && qcObject.thresholds !== undefined) {\n                    json_blob[\"qc-coverage-region-\".concat(index + 1, \"-thresholds\")] = qcObject.thresholds.map(function (threshold) { return threshold.toString(); }).join(\",\");\n                }\n            });\n            continue;\n        }\n        /* 5. Get value for standard options */\n        if (props.hasOwnProperty(key)) {\n            /*  We replace snake case with hyphen */\n            json_blob[key.replace(/_/g, \"-\")] = get_value_for_config(value);\n        }\n    }\n    /* Part 2 - Convert the json blob to toml */\n    return json_to_toml(json_blob);\n}\nfunction generate_sequence_data_mount_points(sequence_data, tumor_sequence_data) {\n    /*\n    Create and add in the fastq list csv for the input fastqs\n    If the input is bam or cram, we also mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the sequence data */\n    if (\"fastq_list_rows\" in sequence_data && sequence_data.fastq_list_rows !== undefined) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _i = 0, _a = sequence_data.fastq_list_rows; _i < _a.length; _i++) {\n            var fastq_list_row = _a[_i];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in sequence_data && sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.bam_input.secondaryFiles) {\n            sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in sequence_data && sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.cram_input.secondaryFiles) {\n            sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (sequence_data.cram_reference.secondaryFiles) {\n                sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Can exist here if germline-only */\n    if (!tumor_sequence_data) {\n        /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n        return e;\n    }\n    /*  Add the tumor sequence data */\n    if (\"fastq_list_rows\" in tumor_sequence_data && tumor_sequence_data.fastq_list_rows !== undefined) {\n        /* Upload the csv */\n        e.push({\n            \"entryname\":get_tumor_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(tumor_sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _b = 0, _c = tumor_sequence_data.fastq_list_rows; _b < _c.length; _b++) {\n            var fastq_list_row = _c[_b];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in tumor_sequence_data && tumor_sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.bam_input.secondaryFiles) {\n            tumor_sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in tumor_sequence_data && tumor_sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.cram_input.secondaryFiles) {\n            tumor_sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (tumor_sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":tumor_sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_sequence_data.cram_reference.secondaryFiles) {\n                tumor_sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_alignment_data_mount_points(alignment_data, tumor_alignment_data) {\n    /*\n    If the input is bam or cram, we mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the alignment data data */\n    if (\"bam_input\" in alignment_data && alignment_data.bam_input !== undefined) {\n        /* Add in the bam file */\n        e.push({\n            \"entryname\":alignment_data.bam_input.basename,\n            /* Due to the secondary files, we need to manually add in each file object */\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.bam_input.secondaryFiles) {\n            alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in alignment_data && alignment_data.cram_input !== undefined) {\n        /* Add in the cram file */\n        e.push({\n            \"entryname\":alignment_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.cram_input.secondaryFiles) {\n            alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (alignment_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":alignment_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":alignment_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (alignment_data.cram_reference.secondaryFiles) {\n                alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Now repeat for tumor alignment data */\n    if (tumor_alignment_data) {\n        /*  Add the alignment data data */\n        if (\"bam_input\" in tumor_alignment_data && tumor_alignment_data.bam_input !== undefined) {\n            /* Add in the bam file */\n            e.push({\n                \"entryname\":tumor_alignment_data.bam_input.basename,\n                /* Due to the secondary files, we need to manually add in each file object */\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.bam_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.bam_input.secondaryFiles) {\n                tumor_alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n        else if (\"cram_input\" in tumor_alignment_data && tumor_alignment_data.cram_input !== undefined) {\n            /* Add in the cram file */\n            e.push({\n                \"entryname\":tumor_alignment_data.cram_input.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.cram_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.cram_input.secondaryFiles) {\n                tumor_alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n            /*  We also add in the reference file if its provided */\n            if (tumor_alignment_data.cram_reference !== undefined) {\n                e.push({\n                    \"entryname\":tumor_alignment_data.cram_reference.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":tumor_alignment_data.cram_reference.location\n                    }\n                });\n                /* Then add in each secondary file object */\n                if (tumor_alignment_data.cram_reference.secondaryFiles) {\n                    tumor_alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                        e.push({\n                            \"entryname\":secondary_file_iter_.basename,\n                            \"entry\":{\n                                \"class\":\"File\",\n                                \"location\":secondary_file_iter_.location\n                            }\n                        });\n                    });\n                }\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_mv_qc_files_script_mount_points(options_list) {\n    /*\n     If alignment_options.qc_coverage is defined, we generate a script to move the qc files to their name attribute\n    */\n    var qc_files_script = generate_mv_qc_files_script(options_list);\n    if (!qc_files_script) {\n        return [];\n    }\n    else {\n        return [\n            {\n                entryname:qc_files_script.basename,\n                /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n                entry:qc_files_script\n            }\n        ];\n    }\n}\nfunction strip_uri_from_name(name_with_uri) {\n    /*\n    Given a string as a uri, return all after the trailing hash\n     */\n    return name_with_uri.split('#').pop() || name_with_uri;\n}\nfunction generate_mv_qc_files_script(options_list) {\n    /*\n    Generate mv qc files script\n     */\n    /* Check if alignment_options.qc_coverage is defined */\n    if (!options_list.alignment_options.qc_coverage || options_list.alignment_options.qc_coverage.length === 0) {\n        return null;\n    }\n    /* Initialise vars */\n    var output_file_prefix = options_list.output_file_prefix;\n    var output_directory = options_list.output_directory;\n    /* Initialise the script */\n    var mv_qc_files_script = \"#!/usr/bin/env bash\\n\\n\";\n    mv_qc_files_script += \"# Exit on failure\\n\";\n    mv_qc_files_script += \"set -euo pipefail\\n\\n\";\n    mv_qc_files_script += \"# Log start\\n\";\n    mv_qc_files_script += \"echo \\\"Start Moving QC files\\\" 1>&2\\n\\n\";\n    /* Arrays to make */\n    var qc_files_suffixes = [\n        /* Germline */\n        \"contig_mean_cov.csv\",\n        \"cov_report.bed\",\n        \"coverage_metrics.csv\",\n        \"fine_hist.csv\",\n        \"hist.csv\",\n        \"overall_mean_cov.csv\",\n        \"read_cov_report.bed\",\n        /* Somatic */\n        \"contig_mean_cov_normal.csv\",\n        \"contig_mean_cov_tumor.csv\",\n        \"cov_report_normal.bed\",\n        \"cov_report_tumor.bed\",\n        \"coverage_metrics_normal.csv\",\n        \"coverage_metrics_tumor.csv\",\n        \"fine_hist_normal.csv\",\n        \"fine_hist_tumor.csv\",\n        \"hist_normal.csv\",\n        \"hist_tumor.csv\",\n        \"overall_mean_cov_normal.csv\",\n        \"overall_mean_cov_tumor.csv\",\n        \"read_cov_report_normal.bed\",\n        \"read_cov_report_tumor.bed\",\n        \"somatic_callable_regions.bed\",\n    ];\n    var qc_file_names = options_list.alignment_options.qc_coverage.map(function (qc_coverage) { return strip_uri_from_name(qc_coverage.name); });\n    /* Create the qc suffixes array */\n    mv_qc_files_script += \"# Initialise coverage arrays \\n\";\n    mv_qc_files_script += \"QC_SUFFIXES=( \\\\\\n\";\n    for (var _i = 0, qc_files_suffixes_1 = qc_files_suffixes; _i < qc_files_suffixes_1.length; _i++) {\n        var qc_suffix = qc_files_suffixes_1[_i];\n        mv_qc_files_script += \"  \\\"\".concat(qc_suffix, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* QC Array complete */\n    /* Create the array of qc names */\n    mv_qc_files_script += \"QC_COVERAGE_NAMES=( \\\\\\n\";\n    for (var _a = 0, qc_file_names_1 = qc_file_names; _a < qc_file_names_1.length; _a++) {\n        var qc_coverage_name = qc_file_names_1[_a];\n        mv_qc_files_script += \"  \\\"\".concat(qc_coverage_name, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* Now iterate through each qc name and suffix to move the files */\n    mv_qc_files_script += \"# Move the QC files to the output directory\\n\";\n    mv_qc_files_script += \"for qc_name_idx in \\\"${!QC_COVERAGE_NAMES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"  qc_name=\\\"${QC_COVERAGE_NAMES[$qc_name_idx]}\\\"\\n\";\n    mv_qc_files_script += \"  for qc_suffix in \\\"${QC_SUFFIXES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"    if [[ -f \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" ]]; then\\n\");\n    mv_qc_files_script += \"      mv \\\\\\n\";\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" \\\\\\n\");\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-${qc_name}_${qc_suffix}\\\"\\n\");\n    mv_qc_files_script += \"    fi\\n\";\n    mv_qc_files_script += \"  done\\n\";\n    mv_qc_files_script += \"done\\n\\n\";\n    mv_qc_files_script += \"# Log completion\\n\";\n    mv_qc_files_script += \"echo \\\"Finish Moving QC files\\\" 1>&2\\n\";\n    return {\n        class:\"File\",\n        basename:\"mv_qc_files.sh\",\n        contents:mv_qc_files_script\n    };\n}\nfunction dragen_merge_options(options_list) {\n    /*\n    Merge a list of objects, ignoring null or undefined values\n    Options are merged in the order they are provided\n    So if there are duplicate keys, the last one will be used\n    */\n    var merged_options = {};\n    for (var _i = 0, options_list_1 = options_list; _i < options_list_1.length; _i++) {\n        var options_object = options_list_1[_i];\n        if (options_object === null || options_object === undefined) {\n            continue;\n        }\n        for (var key in options_object) {\n            /*\n             Check if the key is null or undefined.\n            */\n            if (options_object[key] === undefined) {\n                continue;\n            }\n            /*\n              If the merged key does NOT exist in the merged options but the value is null we add it in\n            */\n            if ((!merged_options.hasOwnProperty(key)) && options_object[key] === null) {\n                merged_options[key] = null;\n                continue;\n            }\n            /*\n              If the merged key DOES exist in the merged options but the value is null we skip it\n            */\n            if (merged_options.hasOwnProperty(key) && options_object[key] === null) {\n                continue;\n            }\n            /*\n              If the key already exists in merged options, check if the\n              merged_options key is a dictionary, if so we need to recursively merge instead\n            */\n            if (merged_options.hasOwnProperty(key) &&\n                typeof merged_options[key] === 'object' &&\n                (merged_options[key] !== null) &&\n                !Array.isArray(merged_options[key])) {\n                /*\n                  Check the item key is also an object\n                */\n                if (typeof options_object[key] === 'object' && !Array.isArray(options_object[key])) {\n                    /*\n                      If the key is an object, we merge the two objects\n                      This is useful for options that have sub-options\n                      However we dont to override values in merged_options that are already set\n                      if the value in the options object is null,\n                      we can solve this by calling the dragen_merge_options function recursively\n                    */\n                    merged_options[key] = dragen_merge_options([\n                        merged_options[key],\n                        options_object[key]\n                    ]);\n                }\n                /*\n                  Otherwise we just override it.\n                */\n                else {\n                    merged_options[key] = options_object[key];\n                }\n                continue;\n            }\n            /*\n            Just a standard option.\n            */\n            if (options_object.hasOwnProperty(key)) {\n                merged_options[key] = options_object[key];\n            }\n        }\n    }\n    return merged_options;\n}\nfunction get_dragen_wgts_dna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name ? props.sample_name :\"\", \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction get_dragen_wgts_rna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name, \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_rna_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Set enable rna to true */\n        enable_rna:true,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction filter_object_by_keys(object1, object2) {\n    /**\n     * Return object 1 with only the keys that are in object 2\n     */\n    var filtered_object = {};\n    /* Dont need to filter if object1 is null or undefined */\n    if (object1 === null || object1 === undefined) {\n        return object2;\n    }\n    /* Iterate through object1 and check if the key is in object2 */\n    for (var key in object1) {\n        if (object2.hasOwnProperty(key)) {\n            filtered_object[key] = object1[key];\n        }\n    }\n    return filtered_object;\n}\nfunction get_dragen_wgts_dna_variant_calling_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /*\n        Naming things\n        */\n        sample_name:props.sample_name,\n        tumor_sample_name:props.tumor_sample_name,\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        tumor_sequence_data:props.tumor_sequence_data,\n        ref_tar:props.reference.tarball,\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:(props.tumor_sample_name ? props.tumor_sample_name :props.sample_name),\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:((props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") +\n            props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__\" +\n            \"dragen_wgts_dna_\" + (props.tumor_sample_name ? \"somatic\" :\"germline\") + \"_variant_calling\"),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        /* SNV caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        /* CNV caller options */\n        cnv_caller_options:props.cnv_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* SV caller options */\n        sv_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.sv_caller_options),\n            props.sv_caller_options,\n        ]),\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n        /* Targeted Caller options */\n        targeted_caller_options:props.targeted_caller_options,\n        /* Mrjd Options */\n        mrjd_options:props.mrjd_options,\n        /* TMB Options */\n        tmb_options:props.tmb_options,\n        /* MSI Options */\n        msi_options:props.msi_options,\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n    };\n}\nfunction get_dragen_wgts_rna_variant_calling_stage_options_from_pipeline(props) {\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Annotation file, used for a lot of the variant calling options */\n        annotation_file:props.annotation_file,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:props.sample_name,\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:(props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__dragen_wgts_rna_variant_calling\"),\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        gene_expression_quantification_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.gene_expression_quantification_options),\n            props.gene_expression_quantification_options,\n        ]),\n        gene_fusion_detection_options:props.gene_fusion_detection_options,\n        splice_variant_caller_options:props.splice_variant_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n    };\n}\n/**\n * Multiqc functions\n *\n */\nfunction get_wgts_dna_multiqc_output_filename(props) {\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc_report.html\";\n}\nfunction get_wgts_rna_multiqc_output_filename(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc_report.html\";\n}\nfunction get_wgts_dna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc\";\n}\nfunction get_wgts_rna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc\";\n}\nfunction get_wgts_dna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS DNA Pipeline ( \" +\n        (props.tumor_sample_name ? props.tumor_sample_name + \"/\" :\"\") +\n        props.sample_name + \" )\");\n}\nfunction get_wgts_rna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS RNA Pipeline ( \" +\n        props.sample_name +\n        \" )\");\n}\nfunction pick_first_non_null(object_list) {\n    for (var _i = 0, object_list_1 = object_list; _i < object_list_1.length; _i++) {\n        var object = object_list_1[_i];\n        if (object) {\n            return object;\n        }\n    }\n}\nfunction pick_all_non_null(object_list) {\n    var non_null_objects = [];\n    for (var _i = 0, object_list_2 = object_list; _i < object_list_2.length; _i++) {\n        var object = object_list_2[_i];\n        if (object) {\n            non_null_objects.push(object);\n        }\n    }\n    return non_null_objects;\n}\nfunction dragen_references_match(reference_list) {\n    /*\n    Determine if the two references match,\n    If one the references is null or undefined then still return true\n    Since we really just want to know if we have two different references\n    */\n    if (reference_list.length !== 2) {\n        throw new Error(\"dragen_references_match:reference_list must be of length 2\");\n    }\n    /* Check if either of the references are null or undefined */\n    if (!reference_list[0] || !reference_list[1]) {\n        return true;\n    }\n    return reference_list[0].tarball.location == reference_list[1].tarball.location;\n}\n/* Utility functions */\nfunction get_optional_attribute_from_object(input_object, attribute) {\n    /*\n    Get attribute from object, if attribute is not defined return null\n    Assume the input object is an object of key value pairs where we know the key is of type string\n    stackoverflow.com/questions/56833469/typescript-error-ts7053-element-implicitly-has-an-any-type\n    */\n    if (input_object.hasOwnProperty(attribute)) {\n        return input_object[attribute];\n    }\n    else {\n        return null;\n    }\n}\nfunction get_attribute_from_optional_input(input_object, attribute) {\n    /*\n    Get attribute from optional input -\n    If input is not defined, then return null\n    */\n    if (input_object === null || input_object === undefined) {\n        return null;\n    }\n    else {\n        return get_optional_attribute_from_object(input_object, attribute);\n    }\n}\nfunction is_not_null(input_obj) {\n    /*\n    Determine if input object is defined and is not null\n    */\n    return !(input_obj === null || input_obj === undefined);\n}\n"
          ],
          "class": "InlineJavascriptRequirement"
        },
        {
          "tmpdirMin": "${\n  /* 4 Tb */\n  return Math.pow(2, 22);\n}\n",
          "class": "ResourceRequirement"
        },
        {
          "types": [
            {
              "type": "record",
              "name": "#dragen-reference__1.0.0.yaml/dragen-reference",
              "fields": [
                {
                  "label": "name",
                  "doc": "The name of the reference genome, i.e hg38\n",
                  "type": "string",
                  "name": "#dragen-reference__1.0.0.yaml/dragen-reference/name"
                },
                {
                  "label": "structure",
                  "doc": "The structure of the reference genome, i.e. linear or graph\n",
                  "type": [
                    {
                      "type": "enum",
                      "symbols": [
                        "#dragen-reference__1.0.0.yaml/dragen-reference/structure/linear",
                        "#dragen-reference__1.0.0.yaml/dragen-reference/structure/graph"
                      ]
                    }
                  ],
                  "name": "#dragen-reference__1.0.0.yaml/dragen-reference/structure"
                },
                {
                  "label": "tarball",
                  "doc": "The reference tarball containing the reference genome and annotation files.\n",
                  "type": "File",
                  "name": "#dragen-reference__1.0.0.yaml/dragen-reference/tarball"
                }
              ]
            },
            {
              "$import": "#fastq-list-row__2.0.0.yaml/fastq-list-row"
            },
            {
              "$import": "#fastq-list-rows-input__2.0.0.yaml/fastq-list-rows-input"
            },
            {
              "$import": "#bam-input__1.0.0.yaml/bam-input"
            },
            {
              "$import": "#cram-input__1.0.0.yaml/cram-input"
            },
            {
              "$import": "#dragen-qc-coverage__1.0.0.yaml/dragen-qc-coverage"
            },
            {
              "type": "record",
              "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage",
              "fields": [
                {
                  "label": "alignment options",
                  "doc": "Specifies the alignment options\n",
                  "type": [
                    {
                      "$import": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options"
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/alignment_options"
                },
                {
                  "label": "cnv caller options",
                  "doc": "Specifies the CNV caller options\n",
                  "type": [
                    "null",
                    {
                      "type": "record",
                      "name": "#dragen-cnv-caller-options__4.4.0.yaml/dragen-cnv-caller-options",
                      "fields": [
                        {
                          "label": "cnv bypass contig check",
                          "doc": "Bypass contig check for self normalization.\n",
                          "type": [
                            "null",
                            "boolean"
                          ],
                          "name": "#dragen-cnv-caller-options__4.4.0.yaml/dragen-cnv-caller-options/cnv_bypass_contig_check"
                        },
                        {
                          "label": "cnv use somatic vc baf",
                          "doc": "If running in tumor-normal mode with the SNV caller enabled,\nuse this option to specify the germline heterozygous sites.\nFor more information on specifying b-allele loci,\nsee Specification of B-Allele Loci.\n",
                          "type": [
                            "null",
                            "boolean"
                          ],
                          "name": "#dragen-cnv-caller-options__4.4.0.yaml/dragen-cnv-caller-options/cnv_use_somatic_vc_baf"
                        },
                        {
                          "label": "enable cnv",
                          "doc": "Enables copy number variant (CNV).\n",
                          "type": [
                            "null",
                            "boolean"
                          ],
                          "name": "#dragen-cnv-caller-options__4.4.0.yaml/dragen-cnv-caller-options/enable_cnv"
                        },
                        {
                          "label": "enable hrd",
                          "doc": "Set to true to enable HRD scoring to quantify genomic instability.\n",
                          "type": [
                            "null",
                            "boolean"
                          ],
                          "name": "#dragen-cnv-caller-options__4.4.0.yaml/dragen-cnv-caller-options/enable_hrd"
                        },
                        {
                          "label": "hrd input ascn",
                          "doc": "Specify the allele-specific copy number file (*cnv.vcf.gz).\nThe CNV VCF file should include REF calls for proper HRD segmentation.\nSee the option --cnv-enable-ref-calls in the CNV section.\n",
                          "type": [
                            "null",
                            "File"
                          ],
                          "name": "#dragen-cnv-caller-options__4.4.0.yaml/dragen-cnv-caller-options/hrd_input_ascn"
                        },
                        {
                          "label": "hrd input tn",
                          "doc": "Specify the tumor normalized bin count file (*.tn.tsv.gz).\n",
                          "type": [
                            "null",
                            "File"
                          ],
                          "name": "#dragen-cnv-caller-options__4.4.0.yaml/dragen-cnv-caller-options/hrd_input_tn"
                        }
                      ]
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/cnv_caller_options"
                },
                {
                  "label": "lic instance id location",
                  "doc": "Use this option to override the default cloud instance ID location\n",
                  "type": [
                    "null",
                    "string",
                    "File"
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/lic_instance_id_location"
                },
                {
                  "label": "maf conversion options",
                  "doc": "Specifies the MAF conversion options\n",
                  "type": [
                    "null",
                    {
                      "type": "record",
                      "name": "#dragen-maf-conversion-options__4.4.0.yaml/dragen-maf-conversion-options",
                      "fields": [
                        {
                          "label": "enable maf output",
                          "doc": "Enables Mutation Annotation Format (MAF) output.\nThe default value is false.\n",
                          "type": [
                            "null",
                            "boolean"
                          ],
                          "name": "#dragen-maf-conversion-options__4.4.0.yaml/dragen-maf-conversion-options/enable_maf_output"
                        },
                        {
                          "label": "maf transcript source",
                          "doc": "Specifies desired transcript source for Mutation Annotation Format (MAF) output.\nOne of 'Refseq' or 'Ensembl'.\n",
                          "type": [
                            "null",
                            "string"
                          ],
                          "name": "#dragen-maf-conversion-options__4.4.0.yaml/dragen-maf-conversion-options/maf_transcript_source"
                        }
                      ]
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/maf_conversion_options"
                },
                {
                  "label": "mrjd options",
                  "doc": "Specifies the mrjd options\n",
                  "type": [
                    "null",
                    {
                      "type": "record",
                      "name": "#dragen-mrjd-options__4.4.0.yaml/dragen-mrjd-options",
                      "fields": [
                        {
                          "label": "Enable mrjd",
                          "doc": "Enable MRJD (Multi-Region Joint Detection) analysis.\n",
                          "type": [
                            "null",
                            "boolean"
                          ],
                          "name": "#dragen-mrjd-options__4.4.0.yaml/dragen-mrjd-options/enable_mrjd"
                        },
                        {
                          "label": "Enable high sensitivity mode",
                          "doc": "Enable high sensitivity mode for MRJD analysis.\n",
                          "type": [
                            "null",
                            "boolean"
                          ],
                          "name": "#dragen-mrjd-options__4.4.0.yaml/dragen-mrjd-options/mrjd_enable_high_sensitivity_mode"
                        }
                      ]
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/mrjd_options"
                },
                {
                  "label": "msi options",
                  "doc": "Specifies the msi options\n",
                  "type": [
                    "null",
                    {
                      "type": "record",
                      "name": "#dragen-msi-options__4.4.0.yaml/dragen-msi-options",
                      "fields": [
                        {
                          "label": "msi command",
                          "doc": "Mode of execution, one of tumor-only, tumor-normal, or collect-evidence\n",
                          "type": [
                            "null",
                            "string"
                          ],
                          "name": "#dragen-msi-options__4.4.0.yaml/dragen-msi-options/msi_command"
                        },
                        {
                          "label": "msi coverage threshold",
                          "doc": "Minimum coverage threshold for microsatellite sites (default: 40)\n",
                          "type": [
                            "null",
                            "int"
                          ],
                          "name": "#dragen-msi-options__4.4.0.yaml/dragen-msi-options/msi_coverage_threshold"
                        },
                        {
                          "label": "msi microsatellites file",
                          "doc": "Path to the microsatellites file\n",
                          "type": [
                            "null",
                            "File"
                          ],
                          "name": "#dragen-msi-options__4.4.0.yaml/dragen-msi-options/msi_microsatellites_file"
                        }
                      ]
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/msi_options"
                },
                {
                  "label": "nirvana annotation options",
                  "doc": "Specifies the Nirvana annotation options\n",
                  "type": [
                    "null",
                    {
                      "type": "record",
                      "name": "#dragen-nirvana-annotation-options__4.4.0.yaml/dragen-nirvana-annotation-options",
                      "fields": [
                        {
                          "label": "enable variant annotation",
                          "doc": "Enable Nirvana variant annotation on the output vcf/gvcf files.\nThe default is false.\n",
                          "type": [
                            "null",
                            "boolean"
                          ],
                          "name": "#dragen-nirvana-annotation-options__4.4.0.yaml/dragen-nirvana-annotation-options/enable_variant_annotation"
                        },
                        {
                          "label": "variant annotation assembly",
                          "doc": "The reference genome assembly used for Nirvana variant annotation.\nOne of 'GRCh37' / 'GRCh38'\n",
                          "type": [
                            "null",
                            "string"
                          ],
                          "name": "#dragen-nirvana-annotation-options__4.4.0.yaml/dragen-nirvana-annotation-options/variant_annotation_assembly"
                        },
                        {
                          "label": "variant annotation data",
                          "doc": "Tarball containing Nirvana data.\nIf not provided, but enable_variant_annotation is true, the data will be downloaded from Illumina's servers\n",
                          "type": [
                            "null",
                            "File"
                          ],
                          "name": "#dragen-nirvana-annotation-options__4.4.0.yaml/dragen-nirvana-annotation-options/variant_annotation_data"
                        }
                      ]
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/nirvana_annotation_options"
                },
                {
                  "label": "ora reference",
                  "doc": "Required if the primary data is in ORA format\n",
                  "type": [
                    "null",
                    "File"
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/ora_reference"
                },
                {
                  "label": "output directory",
                  "doc": "Specifies the output directory.\n",
                  "type": "string",
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/output_directory"
                },
                {
                  "label": "output file prefix",
                  "doc": "Outputs file name prefix to use for all files generated by the pipeline.\n",
                  "type": "string",
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/output_file_prefix"
                },
                {
                  "label": "ref tar",
                  "doc": "Specifies the tarball containing the reference hash table. If the reference is not already loaded into the DRAGEN card, the option automatically loads the reference.\nNote that the actual dragen command is '--ref-dir' but we first need to download and extract the tarball.\n",
                  "type": "File",
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/ref_tar"
                },
                {
                  "label": "sample name",
                  "doc": "The sample name to use for the variant calling.\n",
                  "type": "string",
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/sample_name"
                },
                {
                  "label": "sequence data",
                  "doc": "The sequence data to be aligned and called variants on.\nThis can either be a bam file, cram file or a list of fastq list row objects\n",
                  "type": [
                    {
                      "$import": "#fastq-list-rows-input__2.0.0.yaml/fastq-list-rows-input"
                    },
                    {
                      "$import": "#bam-input__1.0.0.yaml/bam-input"
                    },
                    {
                      "$import": "#cram-input__1.0.0.yaml/cram-input"
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/sequence_data"
                },
                {
                  "label": "snv variant calling options",
                  "doc": "Specifies the snv variant caller options.\n",
                  "type": [
                    {
                      "$import": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options"
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/snv_variant_caller_options"
                },
                {
                  "label": "sv caller options",
                  "doc": "Specifies the SV caller options\n",
                  "type": [
                    {
                      "$import": "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options"
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/sv_caller_options"
                },
                {
                  "label": "targeted caller options",
                  "doc": "Specifies the targeted caller options\n",
                  "type": [
                    "null",
                    {
                      "type": "record",
                      "name": "#dragen-targeted-caller-options__4.4.0.yaml/dragen-targeted-caller-options",
                      "fields": [
                        {
                          "label": "Enable Targeted Caller",
                          "doc": "The targeted caller can be enabled using the command line option --enable-targeted=true\nor a subset of targets can be enabled by providing a space-separated list of target names.\nThe supported target names for WGS are: cyp2b6, cyp2d6, cyp21a2, gba, hba, lpa, rh, and smn.\n",
                          "type": [
                            "null",
                            "boolean",
                            {
                              "type": "array",
                              "items": "string"
                            }
                          ],
                          "name": "#dragen-targeted-caller-options__4.4.0.yaml/dragen-targeted-caller-options/enable_targeted"
                        }
                      ]
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/targeted_caller_options"
                },
                {
                  "label": "tmb options",
                  "doc": "Specifies the tmb options\n",
                  "type": [
                    "null",
                    {
                      "type": "record",
                      "name": "#dragen-tmb-options__4.4.0.yaml/dragen-tmb-options",
                      "fields": [
                        {
                          "label": "enable tmb",
                          "doc": "Enable TMB (Tumor Mutation Burden) analysis.\n",
                          "type": [
                            "null",
                            "boolean"
                          ],
                          "name": "#dragen-tmb-options__4.4.0.yaml/dragen-tmb-options/enable_tmb"
                        },
                        {
                          "label": "tmb enable proxi filter",
                          "doc": "Enable proximity filter for TMB (default=true).\n",
                          "type": [
                            "null",
                            "boolean"
                          ],
                          "name": "#dragen-tmb-options__4.4.0.yaml/dragen-tmb-options/tmb_enable_proxi_filter"
                        },
                        {
                          "label": "tmb vaf threshold",
                          "doc": "Variant mininum allele frequency for usable variants (default=0.05)\n",
                          "type": [
                            "null",
                            "float"
                          ],
                          "name": "#dragen-tmb-options__4.4.0.yaml/dragen-tmb-options/tmb_vaf_threshold"
                        },
                        {
                          "label": "vc callability tumor thresh",
                          "doc": "Required read coverage to use a site (default=50).\n",
                          "type": [
                            "null",
                            "int"
                          ],
                          "name": "#dragen-tmb-options__4.4.0.yaml/dragen-tmb-options/vc_callability_tumor_thresh"
                        }
                      ]
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/tmb_options"
                },
                {
                  "label": "tumor sample name",
                  "doc": "The tumor sample name to use for the variant calling.\n",
                  "type": [
                    "null",
                    "string"
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/tumor_sample_name"
                },
                {
                  "label": "sequence data",
                  "doc": "The sequence data to be aligned and called variants on.\nThis can either be a bam file, cram file or a list of fastq list row objects\n",
                  "type": [
                    "null",
                    {
                      "$import": "#fastq-list-rows-input__2.0.0.yaml/fastq-list-rows-input"
                    },
                    {
                      "$import": "#bam-input__1.0.0.yaml/bam-input"
                    },
                    {
                      "$import": "#cram-input__1.0.0.yaml/cram-input"
                    }
                  ],
                  "name": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage/tumor_sequence_data"
                }
              ]
            }
          ],
          "class": "SchemaDefRequirement"
        }
      ],
      "baseCommand": [
        "bash",
        "run_dragen.sh"
      ],
      "arguments": [
        {
          "prefix": "--config-file=",
          "position": 1,
          "separate": false,
          "valueFrom": "$(get_dragen_config_path())"
        }
      ],
      "inputs": [
        {
          "label": "dragen-options",
          "type": [
            "null",
            "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage"
          ],
          "id": "#dragen-wgts-dna-variant-calling-step__4.4.6.cwl/dragen-variant-calling-step--4.4.6/dragen_options"
        }
      ],
      "outputs": [
        {
          "id": "#dragen-wgts-dna-variant-calling-step__4.4.6.cwl/dragen-variant-calling-step--4.4.6/output_directory",
          "type": "Directory",
          "outputBinding": {
            "glob": "$(inputs.dragen_options.output_directory)"
          }
        }
      ],
      "successCodes": [
        0
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "CommandLineTool",
      "id": "#get-dragen-default-configuration-json__4.4.6.cwl",
      "label": "get-dragen-default-configuration-json v(4.4.6)",
      "doc": "Documentation for get-dragen-default-configuration-json\nv4.4.0\n",
      "hints": [
        {
          "dockerPull": "079623148045.dkr.ecr.us-east-1.amazonaws.com/cp-prod/1df60bef-1edb-4efc-a50c-8e9625b5e60d:latest",
          "class": "DockerRequirement"
        },
        {
          "coresMin": 24,
          "ramMin": 256000,
          "class": "ResourceRequirement",
          "https://platform.illumina.com/rdf/ica/resources:tier": "standard",
          "https://platform.illumina.com/rdf/ica/resources:type": "fpga2",
          "https://platform.illumina.com/rdf/ica/resources:size": "medium"
        }
      ],
      "requirements": [
        {
          "expressionLib": [
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Globals */\n/*\nList of options that are booleans but where the values are expressed as a number\n*/\nvar DragenNumericBooleanType = [\n    \"global\",\n    \"all\"\n];\nvar DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH = '/opt/instance-identity';\n/*  Functions */\nfunction get_scratch_mount() {\n    /*\n    Return the path of the scratch directory space\n    */\n    return \"/scratch/\";\n}\nfunction get_intermediate_results_dir() {\n    /*\n    Get intermediate results directory as /scratch for dragen runs\n    */\n    return get_scratch_mount() + \"intermediate-results/\";\n}\nfunction get_name_root_from_tarball(basename) {\n    var tar_ball_regex = /(\\S+)\\.tar(?:\\.gz)?/g;\n    var tar_ball_expression = tar_ball_regex.exec(basename);\n    if (tar_ball_expression === null) {\n        throw new Error(\"Could not get nameroot from \".concat(basename));\n    }\n    return tar_ball_expression[1];\n}\nfunction get_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_ref_mount() {\n    /*\n    Get the reference mount point\n    */\n    return get_scratch_mount() + \"ref/\";\n}\nfunction get_ora_ref_mount() {\n    /*\n    Get the ORA reference mount point\n    */\n    return get_scratch_mount() + \"ora-reference/\";\n}\nfunction get_ora_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ora_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_nirvana_ref_mount() {\n    /*\n    Get the Nirvana reference mount point\n    */\n    return get_scratch_mount() + \"nirvana-reference/\";\n}\nfunction get_nirvana_ref_path(reference_input_obj) {\n    return get_nirvana_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_variant_annotation_data_mount(nirvana_annotation_options) {\n    if (!nirvana_annotation_options) {\n        return null;\n    }\n    if (!nirvana_annotation_options.variant_annotation_data) {\n        return null;\n    }\n    return get_attribute_from_optional_input(nirvana_annotation_options.variant_annotation_data, \"path\");\n}\nfunction get_dragen_bin_path() {\n    /*\n    Get dragen bin path\n    */\n    return \"/opt/edico/bin/dragen\";\n}\nfunction get_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"fastq_list.csv\";\n}\nfunction get_tumor_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"tumor_fastq_list.csv\";\n}\nfunction capitalizeFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction json_to_toml(json_data) {\n    /*  Convert JSON to TOML format */\n    /*  Much easier than the other way around */\n    /*  Initialize an empty string to store the TOML data */\n    var toml_data = '';\n    var global_keys_list = [];\n    /*  Iterate through each key in the JSON object to first find the 'global' keys */\n    for (var key in json_data) {\n        var value = json_data[key];\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            continue;\n        }\n        global_keys_list.push(key);\n    }\n    var _loop_1 = function (key) {\n        var value = json_data[key];\n        if (value === null) {\n            return \"continue\";\n        }\n        /*  If the value is an array, we need to make an entry for each item in the array */\n        else if (Array.isArray(value)) {\n            value.forEach(function (item) {\n                toml_data += \"\".concat(key, \" = \").concat(item, \"\\n\");\n            });\n        }\n        else {\n            /*  Regular append */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    };\n    /*  Add global keys to the TOML data first */\n    for (var _i = 0, global_keys_list_1 = global_keys_list; _i < global_keys_list_1.length; _i++) {\n        var key = global_keys_list_1[_i];\n        _loop_1(key);\n    }\n    /*  Iterate through each key in the JSON object */\n    for (var key in json_data) {\n        var value = json_data[key];\n        /*  Skip global keys */\n        if (global_keys_list.indexOf(key) !== -1) {\n            continue;\n        }\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"File\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is a directory, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"Directory\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is an object, treat it as a section */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            /*  Section header should have a capitalized first letter */\n            toml_data += \"[\".concat(capitalizeFirstLetter(key), \"]\\n\");\n            for (var sub_key in value) {\n                toml_data += \"\".concat(sub_key, \" = \").concat(value[sub_key], \"\\n\");\n            }\n        }\n        /*  If the value is a string, treat it as a key-value pair */\n        else {\n            /*  Otherwise, treat it as a key-value pair */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    }\n    /*  Return the TOML data */\n    return toml_data;\n}\n/* Convert TOML to JSON format */\nfunction toml_to_json(toml_str) {\n    /*\n    Convert TOML to JSON format.\n    This implementation uses a simple TOML parser for basic key-value pairs and sections.\n    For production use, consider using a library like `@iarna/toml` or `toml`.\n    */\n    var result = {};\n    var currentSection = null;\n    var lines = toml_str.split(/\\r?\\n/);\n    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n        var line = lines_1[_i];\n        line = line.trim();\n        if (!line || line.startsWith(\"#\"))\n            continue;\n        /*  Section header */\n        var sectionMatch = line.match(/^\\[(.+)\\]$/);\n        if (sectionMatch) {\n            /*  Make section lowercase */\n            currentSection = sectionMatch[1].toLowerCase().trim();\n            if (!result[currentSection]) {\n                result[currentSection] = {};\n            }\n            continue;\n        }\n        /*  Key-value pair */\n        var kvMatch = line.match(/^([^=]+)=(.*)$/);\n        if (kvMatch) {\n            var key = kvMatch[1].trim();\n            var value = kvMatch[2].trim();\n            /*  Check if value is empty */\n            if ((value === \"\")) {\n                value = null;\n            }\n            /*  Remove quotes if present */\n            else if ((value.startsWith('\"') && value.endsWith('\"')) ||\n                (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n                value = value.slice(1, -1);\n            }\n            else if (value === \"true\" || value === \"false\") {\n                value = value === \"true\";\n            }\n            else if (!isNaN(Number(value))) {\n                value = Number(value);\n            }\n            /* Set the key name by replacing hyphens with underscores */\n            key = key.replace(/-/g, '_');\n            /* Replace hyphens with underscores in the key */\n            if (currentSection) {\n                /* Check if the key exists in the current section */\n                if (result[currentSection].hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[currentSection][key])) {\n                        /* Push the entry */\n                        result[currentSection][key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[currentSection][key] !== undefined) {\n                            result[currentSection][key] = [result[currentSection][key], value];\n                        }\n                        else {\n                            result[currentSection][key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[currentSection][key] = value;\n                }\n            }\n            else {\n                /* Check if the key exists */\n                if (result.hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[key])) {\n                        /* Push the entry */\n                        result[key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[key] !== undefined) {\n                            result[key] = [result[key], value];\n                        }\n                        else {\n                            result[key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[key] = value;\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction build_fastq_list_csv_header(header_names) {\n    /*\n    Convert lowercase labels to uppercase values\n    i.e\n    [ \"rgid\", \"rglb\", \"rgsm\", \"lane\", \"read_1\", \"read_2\" ]\n    to\n    \"RGID,RGLB,RGSM,Lane,Read1File,Read2File\"\n    */\n    var modified_header_names = [];\n    for (var _i = 0, header_names_1 = header_names; _i < header_names_1.length; _i++) {\n        var header_name = header_names_1[_i];\n        if (header_name.indexOf(\"rg\") === 0) {\n            /*\n            rgid -> RGID\n            */\n            modified_header_names.push(header_name.toUpperCase());\n        }\n        else if (header_name.indexOf(\"read\") === 0) {\n            /*\n            read_1 -> Read1File\n            */\n            modified_header_names.push(\"Read\" + header_name.charAt(header_name.length - 1) + \"File\");\n        }\n        else {\n            /*\n            lane to Lane\n            */\n            modified_header_names.push(header_name[0].toUpperCase() + header_name.substr(1));\n        }\n    }\n    /*\n    Convert array to comma separated strings\n    */\n    return modified_header_names.join(\",\") + \"\\n\";\n}\nfunction get_fastq_list_row_as_csv_row(fastq_list_row, row_order) {\n    var fastq_list_row_values_array = [];\n    /*  This for loop is here to ensure were assigning values in the same order as the header */\n    for (var _i = 0, row_order_1 = row_order; _i < row_order_1.length; _i++) {\n        var item_index = row_order_1[_i];\n        var found_item = false;\n        /*  Find matching attribute in this row */\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            var fastq_list_row_field_value = fastq_list_row[fastq_list_row_field_name];\n            if (fastq_list_row_field_value === null) {\n                /*\n                Item not found, add an empty attribute for this cell in the csv\n                */\n                continue;\n            }\n            /*  The header value matches the name in the item */\n            if (fastq_list_row_field_name === item_index) {\n                /*\n                If the field value has a class attribute then it's either read_1 or read_2\n                */\n                if (fastq_list_row_field_value.hasOwnProperty(\"class\")) {\n                    var fastq_list_row_field_value_file = fastq_list_row_field_value;\n                    /*\n                    Assert that this is actually of class file\n                    */\n                    if (fastq_list_row_field_value_file.class !== \"File\") {\n                        continue;\n                    }\n                    /*  Read 1 and 2 files are mounted as rgid/filename */\n                    fastq_list_row_values_array.push(fastq_list_row.rgid + '/' + fastq_list_row_field_value_file.basename);\n                }\n                else {\n                    /*\n                    Push the string attribute to the fastq list csv row\n                    Replace any commas in the string with ' -'\n                    */\n                    fastq_list_row_values_array.push(fastq_list_row_field_value.toString().replace(/,/g, \" -\"));\n                }\n                found_item = true;\n                break;\n            }\n        }\n        if (!found_item) {\n            /*\n            Push blank cell if no item found\n            */\n            fastq_list_row_values_array.push(\"\");\n        }\n    }\n    /*\n    Convert to string and return as string\n    */\n    return fastq_list_row_values_array.join(\",\") + \"\\n\";\n}\nfunction generate_fastq_list_csv(fastq_list_rows) {\n    /*\n    Fastq list rows generation\n    */\n    var fastq_csv_file = {\n        class:\"File\",\n        basename:get_fastq_list_csv_path()\n    };\n    /*\n    Set the row order\n    */\n    var row_order = [];\n    /*\n    Set the array order\n    Make sure we iterate through all rows of the array\n    */\n    for (var _i = 0, fastq_list_rows_1 = fastq_list_rows; _i < fastq_list_rows_1.length; _i++) {\n        var fastq_list_row = fastq_list_rows_1[_i];\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            if (row_order.indexOf(fastq_list_row_field_name) === -1) {\n                row_order.push(fastq_list_row_field_name);\n            }\n        }\n    }\n    /*\n    Make header\n    */\n    fastq_csv_file.contents = build_fastq_list_csv_header(row_order);\n    /*\n    For each fastq list row,\n    collect the values of each attribute but in the order of the header\n    */\n    for (var _c = 0, fastq_list_rows_2 = fastq_list_rows; _c < fastq_list_rows_2.length; _c++) {\n        var fastq_list_row = fastq_list_rows_2[_c];\n        /*  Add csv row to file contents */\n        fastq_csv_file.contents += get_fastq_list_row_as_csv_row(fastq_list_row, row_order);\n    }\n    return fastq_csv_file;\n}\nfunction get_value_for_config(valueObj) {\n    /* If valueObj is an IFile, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"File\") {\n        return valueObj.path;\n    }\n    /* If valueObj is an IDirectory, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"Directory\") {\n        return valueObj.path;\n    }\n    /* Recursively call this function for nested objects */\n    if (typeof valueObj === 'object' && !Array.isArray(valueObj)) {\n        var newValueObj = {};\n        for (var key in valueObj) {\n            if (valueObj[key] === null || valueObj[key] === undefined) {\n                continue;\n            }\n            /* Special case - boolean to numeric */\n            if (key in DragenNumericBooleanType) {\n                newValueObj[key.replace(/_/g, \"-\")] = valueObj[key] ? 1 :0;\n                continue;\n            }\n            newValueObj[key.replace(/_/g, \"-\")] = get_value_for_config(valueObj[key]);\n        }\n        return newValueObj;\n    }\n    /* Consider arrays */\n    if (Array.isArray(valueObj)) {\n        return valueObj.map(function (item) { return get_value_for_config(item); });\n    }\n    /* Otherwise return the value as is */\n    return valueObj;\n}\nfunction get_dragen_config_path() {\n    return \"dragen_config.toml\";\n}\nfunction dragen_to_config_toml(props) {\n    /* Part 1 - Generate the json blob */\n    var json_blob = {};\n    for (var key in props) {\n        /* Get props key value */\n        var value = props[key];\n        /* Skip null props */\n        if (value === null || value === undefined) {\n            continue;\n        }\n        /*  FIXME denovo to DeNovo */\n        /* Special cases */\n        /* 1. Fastq list rows we rename to 'fastq-list',\n            alignment data mounted at the base of the working directory\n        */\n        /* Sequence data */\n        if (key === \"fastq_list_rows\") {\n            json_blob[\"fastq-list\"] = get_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"bam_input\") {\n            json_blob[\"bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_input\") {\n            json_blob[\"cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_reference\") {\n            json_blob[\"cram-reference\"] = value.basename;\n            continue;\n        }\n        /* Tumor sequence data */\n        if (key === \"tumor_fastq_list_rows\") {\n            json_blob['tumor-fastq-list'] = get_tumor_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"tumor_bam_input\") {\n            json_blob[\"tumor-bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_input\") {\n            json_blob[\"tumor-cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_reference\") {\n            json_blob[\"tumor-cram-reference\"] = value.basename;\n            continue;\n        }\n        /* 2. If ref-tar is parsed through, we use ref-dir instead */\n        if (key === \"ref_tar\") {\n            json_blob['ref-dir'] = get_ref_mount() + value.basename.replace(/\\.tar\\.gz$/, \"\");\n            /*\n                If the ref_tar does not contain 'graph',\n                then we also need to add the parameter,\n                --validate-pangenome-reference=false,\n                this was in place when we wanted to align genome to linear somatic reference\n                however, we are no longer doing that so this parameter is not needed\n            */\n            if (!value.basename.includes(\"graph\")) {\n                json_blob['validate-pangenome-reference'] = false;\n            }\n            continue;\n        }\n        /* If the ora reference is parsed through, we also place the ora reference into the scratch space */\n        if (key === \"ora_reference\") {\n            /* Mounted at scratch mount, strip the .tar.gz from the basename */\n            json_blob['ora-reference'] = get_ora_ref_path(value);\n            continue;\n        }\n        /* If the nirvana reference is parsed through, we also place the nirvana reference into the scratch space */\n        if (key === \"variant_annotation_data\") {\n            /* Mounted at the scratch mount, strip the .tar.gz from the basename */\n            json_blob['variant-annotation-data'] = get_nirvana_ref_path(value);\n            continue;\n        }\n        /* 3. Check if key is in the boolean to numeric list */\n        if (key in DragenNumericBooleanType) {\n            json_blob[key.replace(/_/g, \"-\")] = value ? 1 :0;\n            continue;\n        }\n        /* 4. Check if key is a qc coverage object */\n        if (key === \"qc_coverage\") {\n            /*\n            We need to iterate through the qc coverage objects\n            and add them to the json blob\n            */\n            value.forEach(function (qcObject, index) {\n                json_blob[\"qc-coverage-region-\".concat(index + 1)] = qcObject.region.path;\n                json_blob[\"qc-coverage-reports-\".concat(index + 1)] = qcObject.report_type;\n                if (qcObject.thresholds !== null && qcObject.thresholds !== undefined) {\n                    json_blob[\"qc-coverage-region-\".concat(index + 1, \"-thresholds\")] = qcObject.thresholds.map(function (threshold) { return threshold.toString(); }).join(\",\");\n                }\n            });\n            continue;\n        }\n        /* 5. Get value for standard options */\n        if (props.hasOwnProperty(key)) {\n            /*  We replace snake case with hyphen */\n            json_blob[key.replace(/_/g, \"-\")] = get_value_for_config(value);\n        }\n    }\n    /* Part 2 - Convert the json blob to toml */\n    return json_to_toml(json_blob);\n}\nfunction generate_sequence_data_mount_points(sequence_data, tumor_sequence_data) {\n    /*\n    Create and add in the fastq list csv for the input fastqs\n    If the input is bam or cram, we also mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the sequence data */\n    if (\"fastq_list_rows\" in sequence_data && sequence_data.fastq_list_rows !== undefined) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _i = 0, _a = sequence_data.fastq_list_rows; _i < _a.length; _i++) {\n            var fastq_list_row = _a[_i];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in sequence_data && sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.bam_input.secondaryFiles) {\n            sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in sequence_data && sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.cram_input.secondaryFiles) {\n            sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (sequence_data.cram_reference.secondaryFiles) {\n                sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Can exist here if germline-only */\n    if (!tumor_sequence_data) {\n        /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n        return e;\n    }\n    /*  Add the tumor sequence data */\n    if (\"fastq_list_rows\" in tumor_sequence_data && tumor_sequence_data.fastq_list_rows !== undefined) {\n        /* Upload the csv */\n        e.push({\n            \"entryname\":get_tumor_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(tumor_sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _b = 0, _c = tumor_sequence_data.fastq_list_rows; _b < _c.length; _b++) {\n            var fastq_list_row = _c[_b];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in tumor_sequence_data && tumor_sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.bam_input.secondaryFiles) {\n            tumor_sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in tumor_sequence_data && tumor_sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.cram_input.secondaryFiles) {\n            tumor_sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (tumor_sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":tumor_sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_sequence_data.cram_reference.secondaryFiles) {\n                tumor_sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_alignment_data_mount_points(alignment_data, tumor_alignment_data) {\n    /*\n    If the input is bam or cram, we mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the alignment data data */\n    if (\"bam_input\" in alignment_data && alignment_data.bam_input !== undefined) {\n        /* Add in the bam file */\n        e.push({\n            \"entryname\":alignment_data.bam_input.basename,\n            /* Due to the secondary files, we need to manually add in each file object */\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.bam_input.secondaryFiles) {\n            alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in alignment_data && alignment_data.cram_input !== undefined) {\n        /* Add in the cram file */\n        e.push({\n            \"entryname\":alignment_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.cram_input.secondaryFiles) {\n            alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (alignment_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":alignment_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":alignment_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (alignment_data.cram_reference.secondaryFiles) {\n                alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Now repeat for tumor alignment data */\n    if (tumor_alignment_data) {\n        /*  Add the alignment data data */\n        if (\"bam_input\" in tumor_alignment_data && tumor_alignment_data.bam_input !== undefined) {\n            /* Add in the bam file */\n            e.push({\n                \"entryname\":tumor_alignment_data.bam_input.basename,\n                /* Due to the secondary files, we need to manually add in each file object */\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.bam_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.bam_input.secondaryFiles) {\n                tumor_alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n        else if (\"cram_input\" in tumor_alignment_data && tumor_alignment_data.cram_input !== undefined) {\n            /* Add in the cram file */\n            e.push({\n                \"entryname\":tumor_alignment_data.cram_input.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.cram_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.cram_input.secondaryFiles) {\n                tumor_alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n            /*  We also add in the reference file if its provided */\n            if (tumor_alignment_data.cram_reference !== undefined) {\n                e.push({\n                    \"entryname\":tumor_alignment_data.cram_reference.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":tumor_alignment_data.cram_reference.location\n                    }\n                });\n                /* Then add in each secondary file object */\n                if (tumor_alignment_data.cram_reference.secondaryFiles) {\n                    tumor_alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                        e.push({\n                            \"entryname\":secondary_file_iter_.basename,\n                            \"entry\":{\n                                \"class\":\"File\",\n                                \"location\":secondary_file_iter_.location\n                            }\n                        });\n                    });\n                }\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_mv_qc_files_script_mount_points(options_list) {\n    /*\n     If alignment_options.qc_coverage is defined, we generate a script to move the qc files to their name attribute\n    */\n    var qc_files_script = generate_mv_qc_files_script(options_list);\n    if (!qc_files_script) {\n        return [];\n    }\n    else {\n        return [\n            {\n                entryname:qc_files_script.basename,\n                /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n                entry:qc_files_script\n            }\n        ];\n    }\n}\nfunction strip_uri_from_name(name_with_uri) {\n    /*\n    Given a string as a uri, return all after the trailing hash\n     */\n    return name_with_uri.split('#').pop() || name_with_uri;\n}\nfunction generate_mv_qc_files_script(options_list) {\n    /*\n    Generate mv qc files script\n     */\n    /* Check if alignment_options.qc_coverage is defined */\n    if (!options_list.alignment_options.qc_coverage || options_list.alignment_options.qc_coverage.length === 0) {\n        return null;\n    }\n    /* Initialise vars */\n    var output_file_prefix = options_list.output_file_prefix;\n    var output_directory = options_list.output_directory;\n    /* Initialise the script */\n    var mv_qc_files_script = \"#!/usr/bin/env bash\\n\\n\";\n    mv_qc_files_script += \"# Exit on failure\\n\";\n    mv_qc_files_script += \"set -euo pipefail\\n\\n\";\n    mv_qc_files_script += \"# Log start\\n\";\n    mv_qc_files_script += \"echo \\\"Start Moving QC files\\\" 1>&2\\n\\n\";\n    /* Arrays to make */\n    var qc_files_suffixes = [\n        /* Germline */\n        \"contig_mean_cov.csv\",\n        \"cov_report.bed\",\n        \"coverage_metrics.csv\",\n        \"fine_hist.csv\",\n        \"hist.csv\",\n        \"overall_mean_cov.csv\",\n        \"read_cov_report.bed\",\n        /* Somatic */\n        \"contig_mean_cov_normal.csv\",\n        \"contig_mean_cov_tumor.csv\",\n        \"cov_report_normal.bed\",\n        \"cov_report_tumor.bed\",\n        \"coverage_metrics_normal.csv\",\n        \"coverage_metrics_tumor.csv\",\n        \"fine_hist_normal.csv\",\n        \"fine_hist_tumor.csv\",\n        \"hist_normal.csv\",\n        \"hist_tumor.csv\",\n        \"overall_mean_cov_normal.csv\",\n        \"overall_mean_cov_tumor.csv\",\n        \"read_cov_report_normal.bed\",\n        \"read_cov_report_tumor.bed\",\n        \"somatic_callable_regions.bed\",\n    ];\n    var qc_file_names = options_list.alignment_options.qc_coverage.map(function (qc_coverage) { return strip_uri_from_name(qc_coverage.name); });\n    /* Create the qc suffixes array */\n    mv_qc_files_script += \"# Initialise coverage arrays \\n\";\n    mv_qc_files_script += \"QC_SUFFIXES=( \\\\\\n\";\n    for (var _i = 0, qc_files_suffixes_1 = qc_files_suffixes; _i < qc_files_suffixes_1.length; _i++) {\n        var qc_suffix = qc_files_suffixes_1[_i];\n        mv_qc_files_script += \"  \\\"\".concat(qc_suffix, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* QC Array complete */\n    /* Create the array of qc names */\n    mv_qc_files_script += \"QC_COVERAGE_NAMES=( \\\\\\n\";\n    for (var _a = 0, qc_file_names_1 = qc_file_names; _a < qc_file_names_1.length; _a++) {\n        var qc_coverage_name = qc_file_names_1[_a];\n        mv_qc_files_script += \"  \\\"\".concat(qc_coverage_name, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* Now iterate through each qc name and suffix to move the files */\n    mv_qc_files_script += \"# Move the QC files to the output directory\\n\";\n    mv_qc_files_script += \"for qc_name_idx in \\\"${!QC_COVERAGE_NAMES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"  qc_name=\\\"${QC_COVERAGE_NAMES[$qc_name_idx]}\\\"\\n\";\n    mv_qc_files_script += \"  for qc_suffix in \\\"${QC_SUFFIXES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"    if [[ -f \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" ]]; then\\n\");\n    mv_qc_files_script += \"      mv \\\\\\n\";\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" \\\\\\n\");\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-${qc_name}_${qc_suffix}\\\"\\n\");\n    mv_qc_files_script += \"    fi\\n\";\n    mv_qc_files_script += \"  done\\n\";\n    mv_qc_files_script += \"done\\n\\n\";\n    mv_qc_files_script += \"# Log completion\\n\";\n    mv_qc_files_script += \"echo \\\"Finish Moving QC files\\\" 1>&2\\n\";\n    return {\n        class:\"File\",\n        basename:\"mv_qc_files.sh\",\n        contents:mv_qc_files_script\n    };\n}\nfunction dragen_merge_options(options_list) {\n    /*\n    Merge a list of objects, ignoring null or undefined values\n    Options are merged in the order they are provided\n    So if there are duplicate keys, the last one will be used\n    */\n    var merged_options = {};\n    for (var _i = 0, options_list_1 = options_list; _i < options_list_1.length; _i++) {\n        var options_object = options_list_1[_i];\n        if (options_object === null || options_object === undefined) {\n            continue;\n        }\n        for (var key in options_object) {\n            /*\n             Check if the key is null or undefined.\n            */\n            if (options_object[key] === undefined) {\n                continue;\n            }\n            /*\n              If the merged key does NOT exist in the merged options but the value is null we add it in\n            */\n            if ((!merged_options.hasOwnProperty(key)) && options_object[key] === null) {\n                merged_options[key] = null;\n                continue;\n            }\n            /*\n              If the merged key DOES exist in the merged options but the value is null we skip it\n            */\n            if (merged_options.hasOwnProperty(key) && options_object[key] === null) {\n                continue;\n            }\n            /*\n              If the key already exists in merged options, check if the\n              merged_options key is a dictionary, if so we need to recursively merge instead\n            */\n            if (merged_options.hasOwnProperty(key) &&\n                typeof merged_options[key] === 'object' &&\n                (merged_options[key] !== null) &&\n                !Array.isArray(merged_options[key])) {\n                /*\n                  Check the item key is also an object\n                */\n                if (typeof options_object[key] === 'object' && !Array.isArray(options_object[key])) {\n                    /*\n                      If the key is an object, we merge the two objects\n                      This is useful for options that have sub-options\n                      However we dont to override values in merged_options that are already set\n                      if the value in the options object is null,\n                      we can solve this by calling the dragen_merge_options function recursively\n                    */\n                    merged_options[key] = dragen_merge_options([\n                        merged_options[key],\n                        options_object[key]\n                    ]);\n                }\n                /*\n                  Otherwise we just override it.\n                */\n                else {\n                    merged_options[key] = options_object[key];\n                }\n                continue;\n            }\n            /*\n            Just a standard option.\n            */\n            if (options_object.hasOwnProperty(key)) {\n                merged_options[key] = options_object[key];\n            }\n        }\n    }\n    return merged_options;\n}\nfunction get_dragen_wgts_dna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name ? props.sample_name :\"\", \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction get_dragen_wgts_rna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name, \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_rna_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Set enable rna to true */\n        enable_rna:true,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction filter_object_by_keys(object1, object2) {\n    /**\n     * Return object 1 with only the keys that are in object 2\n     */\n    var filtered_object = {};\n    /* Dont need to filter if object1 is null or undefined */\n    if (object1 === null || object1 === undefined) {\n        return object2;\n    }\n    /* Iterate through object1 and check if the key is in object2 */\n    for (var key in object1) {\n        if (object2.hasOwnProperty(key)) {\n            filtered_object[key] = object1[key];\n        }\n    }\n    return filtered_object;\n}\nfunction get_dragen_wgts_dna_variant_calling_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /*\n        Naming things\n        */\n        sample_name:props.sample_name,\n        tumor_sample_name:props.tumor_sample_name,\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        tumor_sequence_data:props.tumor_sequence_data,\n        ref_tar:props.reference.tarball,\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:(props.tumor_sample_name ? props.tumor_sample_name :props.sample_name),\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:((props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") +\n            props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__\" +\n            \"dragen_wgts_dna_\" + (props.tumor_sample_name ? \"somatic\" :\"germline\") + \"_variant_calling\"),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        /* SNV caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        /* CNV caller options */\n        cnv_caller_options:props.cnv_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* SV caller options */\n        sv_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.sv_caller_options),\n            props.sv_caller_options,\n        ]),\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n        /* Targeted Caller options */\n        targeted_caller_options:props.targeted_caller_options,\n        /* Mrjd Options */\n        mrjd_options:props.mrjd_options,\n        /* TMB Options */\n        tmb_options:props.tmb_options,\n        /* MSI Options */\n        msi_options:props.msi_options,\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n    };\n}\nfunction get_dragen_wgts_rna_variant_calling_stage_options_from_pipeline(props) {\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Annotation file, used for a lot of the variant calling options */\n        annotation_file:props.annotation_file,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:props.sample_name,\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:(props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__dragen_wgts_rna_variant_calling\"),\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        gene_expression_quantification_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.gene_expression_quantification_options),\n            props.gene_expression_quantification_options,\n        ]),\n        gene_fusion_detection_options:props.gene_fusion_detection_options,\n        splice_variant_caller_options:props.splice_variant_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n    };\n}\n/**\n * Multiqc functions\n *\n */\nfunction get_wgts_dna_multiqc_output_filename(props) {\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc_report.html\";\n}\nfunction get_wgts_rna_multiqc_output_filename(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc_report.html\";\n}\nfunction get_wgts_dna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc\";\n}\nfunction get_wgts_rna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc\";\n}\nfunction get_wgts_dna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS DNA Pipeline ( \" +\n        (props.tumor_sample_name ? props.tumor_sample_name + \"/\" :\"\") +\n        props.sample_name + \" )\");\n}\nfunction get_wgts_rna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS RNA Pipeline ( \" +\n        props.sample_name +\n        \" )\");\n}\nfunction pick_first_non_null(object_list) {\n    for (var _i = 0, object_list_1 = object_list; _i < object_list_1.length; _i++) {\n        var object = object_list_1[_i];\n        if (object) {\n            return object;\n        }\n    }\n}\nfunction pick_all_non_null(object_list) {\n    var non_null_objects = [];\n    for (var _i = 0, object_list_2 = object_list; _i < object_list_2.length; _i++) {\n        var object = object_list_2[_i];\n        if (object) {\n            non_null_objects.push(object);\n        }\n    }\n    return non_null_objects;\n}\nfunction dragen_references_match(reference_list) {\n    /*\n    Determine if the two references match,\n    If one the references is null or undefined then still return true\n    Since we really just want to know if we have two different references\n    */\n    if (reference_list.length !== 2) {\n        throw new Error(\"dragen_references_match:reference_list must be of length 2\");\n    }\n    /* Check if either of the references are null or undefined */\n    if (!reference_list[0] || !reference_list[1]) {\n        return true;\n    }\n    return reference_list[0].tarball.location == reference_list[1].tarball.location;\n}\n/* Utility functions */\nfunction get_optional_attribute_from_object(input_object, attribute) {\n    /*\n    Get attribute from object, if attribute is not defined return null\n    Assume the input object is an object of key value pairs where we know the key is of type string\n    stackoverflow.com/questions/56833469/typescript-error-ts7053-element-implicitly-has-an-any-type\n    */\n    if (input_object.hasOwnProperty(attribute)) {\n        return input_object[attribute];\n    }\n    else {\n        return null;\n    }\n}\nfunction get_attribute_from_optional_input(input_object, attribute) {\n    /*\n    Get attribute from optional input -\n    If input is not defined, then return null\n    */\n    if (input_object === null || input_object === undefined) {\n        return null;\n    }\n    else {\n        return get_optional_attribute_from_object(input_object, attribute);\n    }\n}\nfunction is_not_null(input_obj) {\n    /*\n    Determine if input object is defined and is not null\n    */\n    return !(input_obj === null || input_obj === undefined);\n}\n"
          ],
          "class": "InlineJavascriptRequirement"
        }
      ],
      "baseCommand": [
        "cat",
        "/opt/edico/config/dragen-user-defaults.cfg"
      ],
      "stdout": "stdout.txt",
      "inputs": [],
      "outputs": [
        {
          "label": "dragen default configuration options",
          "doc": "The default configuration options for the DRAGEN pipeline.\nThis is a JSON object that contains the default values for all\nthe configuration options that can be set in the DRAGEN pipeline.\nWe use this to set the default values for the configuration, and then overwrite it with\nother options we provide in the workflow and then write back to toml when running the dragen tool!\n",
          "type": "string",
          "outputBinding": {
            "glob": "stdout.txt",
            "loadContents": true,
            "outputEval": "${\n  /* Take the output from the stdout file and convert it to JSON, and then to string */\n  return JSON.stringify(toml_to_json(self[0].contents));\n}\n"
          },
          "id": "#get-dragen-default-configuration-json__4.4.6.cwl/get-dragen-default-configuration-json--4.4.6/dragen_default_configuration_options"
        }
      ],
      "successCodes": [
        0
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "CommandLineTool",
      "id": "#multiqc__1.25.1.cwl",
      "label": "multiqc v(1.25.0)",
      "doc": "Documentation for multiqc v1.25.0\nUse patch that includes https://github.com/ewels/MultiQC/pull/1969\n",
      "hints": [
        {
          "dockerPull": "ghcr.io/multiqc/multiqc:v1.25.1",
          "class": "DockerRequirement"
        },
        {
          "coresMin": 2,
          "ramMin": 4000,
          "class": "ResourceRequirement",
          "https://platform.illumina.com/rdf/ica/resources:tier": "standard",
          "https://platform.illumina.com/rdf/ica/resources:type": "standard",
          "https://platform.illumina.com/rdf/ica/resources:size": "small"
        }
      ],
      "requirements": [
        {
          "class": "InlineJavascriptRequirement"
        }
      ],
      "baseCommand": [
        "multiqc"
      ],
      "inputs": [
        {
          "label": "cl config",
          "doc": "Override config from the cli\n",
          "type": [
            "null",
            "string"
          ],
          "inputBinding": {
            "prefix": "--cl-config"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/cl_config"
        },
        {
          "label": "comment",
          "doc": "Custom comment, will be printed at the top of the report.\n",
          "type": [
            "null",
            "string"
          ],
          "inputBinding": {
            "prefix": "--comment"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/comment"
        },
        {
          "label": "config",
          "doc": "Configuration file for bclconvert\n",
          "type": [
            "null",
            "File"
          ],
          "streamable": true,
          "inputBinding": {
            "prefix": "--config"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/config"
        },
        {
          "label": "input directories",
          "doc": "The list of directories to place in the analysis\n",
          "type": {
            "type": "array",
            "items": "Directory"
          },
          "inputBinding": {
            "position": 100
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/input_directories"
        },
        {
          "label": "output directory",
          "doc": "The output directory\n",
          "type": "string",
          "inputBinding": {
            "prefix": "--outdir",
            "valueFrom": "$(runtime.outdir)/$(self)"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/output_directory_name"
        },
        {
          "label": "output filename",
          "doc": "Report filename in html format.\nDefaults to 'multiqc-report.html\"\n",
          "type": "string",
          "inputBinding": {
            "prefix": "--filename"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/output_filename"
        },
        {
          "label": "title",
          "doc": "Report title.\nPrinted as page header, used for filename if not otherwise specified.\n",
          "type": "string",
          "inputBinding": {
            "prefix": "--title"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/title"
        }
      ],
      "outputs": [
        {
          "label": "output directory",
          "doc": "Directory that contains all multiqc analysis data\n",
          "type": "Directory",
          "outputBinding": {
            "glob": "$(inputs.output_directory_name)"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/output_directory"
        },
        {
          "label": "output file",
          "doc": "Output html file\n",
          "type": "File",
          "outputBinding": {
            "glob": "$(inputs.output_directory_name)/$(inputs.output_filename)"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/output_file"
        }
      ],
      "successCodes": [
        0
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "CommandLineTool",
      "id": "#rename-rgsm-in-alignment-header__1.0.0.cwl",
      "label": "rename-rgsm-in-alignment-header v(1.0.0)",
      "doc": "Documentation for rename-rgsm-in-alignment-header v1.0.0\n",
      "hints": [
        {
          "dockerPull": "ubuntu:latest",
          "class": "DockerRequirement"
        },
        {
          "coresMin": 2,
          "ramMin": 4000,
          "class": "ResourceRequirement",
          "https://platform.illumina.com/rdf/ica/resources:tier": "standard/economy",
          "https://platform.illumina.com/rdf/ica/resources:type": "standard/standardHiCpu/standardHiMem/standardHiIo/fpga",
          "https://platform.illumina.com/rdf/ica/resources:size": "small/medium/large/xlarge/xxlarge"
        }
      ],
      "requirements": [
        {
          "types": [
            {
              "$import": "#bam-input__1.0.0.yaml/bam-input"
            },
            {
              "$import": "#cram-input__1.0.0.yaml/cram-input"
            }
          ],
          "class": "SchemaDefRequirement"
        }
      ],
      "baseCommand": [
        "samtools",
        "reheader"
      ],
      "arguments": [
        "--no-PG"
      ],
      "inputs": [
        {
          "label": "alignment file",
          "doc": "The alignment file to be modified. This can be either a CRAM or BAM file.\n",
          "type": [
            "#bam-input__1.0.0.yaml/bam-input",
            "#cram-input__1.0.0.yaml/cram-input"
          ],
          "inputBinding": {
            "position": 2
          },
          "id": "#rename-rgsm-in-alignment-header__1.0.0.cwl/rename-rgsm-in-alignment-header--1.0.0/alignment_file"
        },
        {
          "label": "rgsm",
          "doc": "The RGSM tag to be added to the header of the alignment file",
          "type": "string",
          "inputBinding": {
            "prefix": "--command",
            "valueFrom": "perl -pe 's%(@RG.*SM:)[\\w-_\\.]+\\s(.*)%\\1${self}\\2%'"
          },
          "id": "#rename-rgsm-in-alignment-header__1.0.0.cwl/rename-rgsm-in-alignment-header--1.0.0/rgsm"
        }
      ],
      "stdout": "${\n  // Output file name is the same as the input file name\n  if (inputs.alignment_file.cram_input) {\n    return inputs.sequence_data.cram_input.basename;\n  } else if (inputs.alignment_file.bam_input) {\n    return inputs.alignment_file.bam_input.basename;\n  } else {\n    throw new Error(\"No input file provided\");\n  }\n}\n",
      "outputs": [
        {
          "type": "File",
          "outputBinding": {
            "glob": "stdout",
            "loadContents": false
          },
          "id": "#rename-rgsm-in-alignment-header__1.0.0.cwl/rename-rgsm-in-alignment-header--1.0.0/alignment_file_out_renamed"
        }
      ],
      "successCodes": [
        0
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "Workflow",
      "id": "#main",
      "label": "dragen-wgts-dna-pipeline v(4.4.6)",
      "doc": "Dragen dragen-wgts-dna-pipeline v4.4.6\n\nPerforms the following steps:\n  * If input is a bam file (for tumor or normal), reheader the bam file such that the rgsm value matches\n    the output_prefix value. We can't do this inside the dragen container since it doesn't have the samtools binary installed.\n    Instead we run a seperate step to reheader the bam file.\n  * If tumor sequence data is provided and normal sequence data are provided, run the dragen-somatic tool.\n  * If only the normal sequence data are provided, run the dragen-germline tool.\n\nInputs:\n  This pipeline differs from our previous dragen-germline and dragen-somatic pipeline by instead grouping inputs.\n  This makes overall workflow cwl file much smaller, and the workflow graphs much more readable.\n  It also means appending input options is much easier since it involves updating just one schema yaml file,\n    rather than the workflow inputs, workflow steps and the tool inputs.\n  Most of the grunt work is done in the dragen tools typescript file to convert input options into a configuration file.\n\nOutputs:\n  The outputs are the same as the previous dragen-germline and dragen-somatic pipelines.\n  The outputs are:\n    * Dragen somatic output directory (if tumor sequence data are provided)\n    * Dragen germline output directory (always)\n    * Multiqc output directory (always)\n",
      "requirements": [
        {
          "expressionLib": [
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Globals */\n/*\nList of options that are booleans but where the values are expressed as a number\n*/\nvar DragenNumericBooleanType = [\n    \"global\",\n    \"all\"\n];\nvar DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH = '/opt/instance-identity';\n/*  Functions */\nfunction get_scratch_mount() {\n    /*\n    Return the path of the scratch directory space\n    */\n    return \"/scratch/\";\n}\nfunction get_intermediate_results_dir() {\n    /*\n    Get intermediate results directory as /scratch for dragen runs\n    */\n    return get_scratch_mount() + \"intermediate-results/\";\n}\nfunction get_name_root_from_tarball(basename) {\n    var tar_ball_regex = /(\\S+)\\.tar(?:\\.gz)?/g;\n    var tar_ball_expression = tar_ball_regex.exec(basename);\n    if (tar_ball_expression === null) {\n        throw new Error(\"Could not get nameroot from \".concat(basename));\n    }\n    return tar_ball_expression[1];\n}\nfunction get_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_ref_mount() {\n    /*\n    Get the reference mount point\n    */\n    return get_scratch_mount() + \"ref/\";\n}\nfunction get_ora_ref_mount() {\n    /*\n    Get the ORA reference mount point\n    */\n    return get_scratch_mount() + \"ora-reference/\";\n}\nfunction get_ora_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ora_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_nirvana_ref_mount() {\n    /*\n    Get the Nirvana reference mount point\n    */\n    return get_scratch_mount() + \"nirvana-reference/\";\n}\nfunction get_nirvana_ref_path(reference_input_obj) {\n    return get_nirvana_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_variant_annotation_data_mount(nirvana_annotation_options) {\n    if (!nirvana_annotation_options) {\n        return null;\n    }\n    if (!nirvana_annotation_options.variant_annotation_data) {\n        return null;\n    }\n    return get_attribute_from_optional_input(nirvana_annotation_options.variant_annotation_data, \"path\");\n}\nfunction get_dragen_bin_path() {\n    /*\n    Get dragen bin path\n    */\n    return \"/opt/edico/bin/dragen\";\n}\nfunction get_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"fastq_list.csv\";\n}\nfunction get_tumor_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"tumor_fastq_list.csv\";\n}\nfunction capitalizeFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction json_to_toml(json_data) {\n    /*  Convert JSON to TOML format */\n    /*  Much easier than the other way around */\n    /*  Initialize an empty string to store the TOML data */\n    var toml_data = '';\n    var global_keys_list = [];\n    /*  Iterate through each key in the JSON object to first find the 'global' keys */\n    for (var key in json_data) {\n        var value = json_data[key];\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            continue;\n        }\n        global_keys_list.push(key);\n    }\n    var _loop_1 = function (key) {\n        var value = json_data[key];\n        if (value === null) {\n            return \"continue\";\n        }\n        /*  If the value is an array, we need to make an entry for each item in the array */\n        else if (Array.isArray(value)) {\n            value.forEach(function (item) {\n                toml_data += \"\".concat(key, \" = \").concat(item, \"\\n\");\n            });\n        }\n        else {\n            /*  Regular append */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    };\n    /*  Add global keys to the TOML data first */\n    for (var _i = 0, global_keys_list_1 = global_keys_list; _i < global_keys_list_1.length; _i++) {\n        var key = global_keys_list_1[_i];\n        _loop_1(key);\n    }\n    /*  Iterate through each key in the JSON object */\n    for (var key in json_data) {\n        var value = json_data[key];\n        /*  Skip global keys */\n        if (global_keys_list.indexOf(key) !== -1) {\n            continue;\n        }\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"File\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is a directory, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"Directory\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is an object, treat it as a section */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            /*  Section header should have a capitalized first letter */\n            toml_data += \"[\".concat(capitalizeFirstLetter(key), \"]\\n\");\n            for (var sub_key in value) {\n                toml_data += \"\".concat(sub_key, \" = \").concat(value[sub_key], \"\\n\");\n            }\n        }\n        /*  If the value is a string, treat it as a key-value pair */\n        else {\n            /*  Otherwise, treat it as a key-value pair */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    }\n    /*  Return the TOML data */\n    return toml_data;\n}\n/* Convert TOML to JSON format */\nfunction toml_to_json(toml_str) {\n    /*\n    Convert TOML to JSON format.\n    This implementation uses a simple TOML parser for basic key-value pairs and sections.\n    For production use, consider using a library like `@iarna/toml` or `toml`.\n    */\n    var result = {};\n    var currentSection = null;\n    var lines = toml_str.split(/\\r?\\n/);\n    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n        var line = lines_1[_i];\n        line = line.trim();\n        if (!line || line.startsWith(\"#\"))\n            continue;\n        /*  Section header */\n        var sectionMatch = line.match(/^\\[(.+)\\]$/);\n        if (sectionMatch) {\n            /*  Make section lowercase */\n            currentSection = sectionMatch[1].toLowerCase().trim();\n            if (!result[currentSection]) {\n                result[currentSection] = {};\n            }\n            continue;\n        }\n        /*  Key-value pair */\n        var kvMatch = line.match(/^([^=]+)=(.*)$/);\n        if (kvMatch) {\n            var key = kvMatch[1].trim();\n            var value = kvMatch[2].trim();\n            /*  Check if value is empty */\n            if ((value === \"\")) {\n                value = null;\n            }\n            /*  Remove quotes if present */\n            else if ((value.startsWith('\"') && value.endsWith('\"')) ||\n                (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n                value = value.slice(1, -1);\n            }\n            else if (value === \"true\" || value === \"false\") {\n                value = value === \"true\";\n            }\n            else if (!isNaN(Number(value))) {\n                value = Number(value);\n            }\n            /* Set the key name by replacing hyphens with underscores */\n            key = key.replace(/-/g, '_');\n            /* Replace hyphens with underscores in the key */\n            if (currentSection) {\n                /* Check if the key exists in the current section */\n                if (result[currentSection].hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[currentSection][key])) {\n                        /* Push the entry */\n                        result[currentSection][key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[currentSection][key] !== undefined) {\n                            result[currentSection][key] = [result[currentSection][key], value];\n                        }\n                        else {\n                            result[currentSection][key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[currentSection][key] = value;\n                }\n            }\n            else {\n                /* Check if the key exists */\n                if (result.hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[key])) {\n                        /* Push the entry */\n                        result[key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[key] !== undefined) {\n                            result[key] = [result[key], value];\n                        }\n                        else {\n                            result[key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[key] = value;\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction build_fastq_list_csv_header(header_names) {\n    /*\n    Convert lowercase labels to uppercase values\n    i.e\n    [ \"rgid\", \"rglb\", \"rgsm\", \"lane\", \"read_1\", \"read_2\" ]\n    to\n    \"RGID,RGLB,RGSM,Lane,Read1File,Read2File\"\n    */\n    var modified_header_names = [];\n    for (var _i = 0, header_names_1 = header_names; _i < header_names_1.length; _i++) {\n        var header_name = header_names_1[_i];\n        if (header_name.indexOf(\"rg\") === 0) {\n            /*\n            rgid -> RGID\n            */\n            modified_header_names.push(header_name.toUpperCase());\n        }\n        else if (header_name.indexOf(\"read\") === 0) {\n            /*\n            read_1 -> Read1File\n            */\n            modified_header_names.push(\"Read\" + header_name.charAt(header_name.length - 1) + \"File\");\n        }\n        else {\n            /*\n            lane to Lane\n            */\n            modified_header_names.push(header_name[0].toUpperCase() + header_name.substr(1));\n        }\n    }\n    /*\n    Convert array to comma separated strings\n    */\n    return modified_header_names.join(\",\") + \"\\n\";\n}\nfunction get_fastq_list_row_as_csv_row(fastq_list_row, row_order) {\n    var fastq_list_row_values_array = [];\n    /*  This for loop is here to ensure were assigning values in the same order as the header */\n    for (var _i = 0, row_order_1 = row_order; _i < row_order_1.length; _i++) {\n        var item_index = row_order_1[_i];\n        var found_item = false;\n        /*  Find matching attribute in this row */\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            var fastq_list_row_field_value = fastq_list_row[fastq_list_row_field_name];\n            if (fastq_list_row_field_value === null) {\n                /*\n                Item not found, add an empty attribute for this cell in the csv\n                */\n                continue;\n            }\n            /*  The header value matches the name in the item */\n            if (fastq_list_row_field_name === item_index) {\n                /*\n                If the field value has a class attribute then it's either read_1 or read_2\n                */\n                if (fastq_list_row_field_value.hasOwnProperty(\"class\")) {\n                    var fastq_list_row_field_value_file = fastq_list_row_field_value;\n                    /*\n                    Assert that this is actually of class file\n                    */\n                    if (fastq_list_row_field_value_file.class !== \"File\") {\n                        continue;\n                    }\n                    /*  Read 1 and 2 files are mounted as rgid/filename */\n                    fastq_list_row_values_array.push(fastq_list_row.rgid + '/' + fastq_list_row_field_value_file.basename);\n                }\n                else {\n                    /*\n                    Push the string attribute to the fastq list csv row\n                    Replace any commas in the string with ' -'\n                    */\n                    fastq_list_row_values_array.push(fastq_list_row_field_value.toString().replace(/,/g, \" -\"));\n                }\n                found_item = true;\n                break;\n            }\n        }\n        if (!found_item) {\n            /*\n            Push blank cell if no item found\n            */\n            fastq_list_row_values_array.push(\"\");\n        }\n    }\n    /*\n    Convert to string and return as string\n    */\n    return fastq_list_row_values_array.join(\",\") + \"\\n\";\n}\nfunction generate_fastq_list_csv(fastq_list_rows) {\n    /*\n    Fastq list rows generation\n    */\n    var fastq_csv_file = {\n        class:\"File\",\n        basename:get_fastq_list_csv_path()\n    };\n    /*\n    Set the row order\n    */\n    var row_order = [];\n    /*\n    Set the array order\n    Make sure we iterate through all rows of the array\n    */\n    for (var _i = 0, fastq_list_rows_1 = fastq_list_rows; _i < fastq_list_rows_1.length; _i++) {\n        var fastq_list_row = fastq_list_rows_1[_i];\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            if (row_order.indexOf(fastq_list_row_field_name) === -1) {\n                row_order.push(fastq_list_row_field_name);\n            }\n        }\n    }\n    /*\n    Make header\n    */\n    fastq_csv_file.contents = build_fastq_list_csv_header(row_order);\n    /*\n    For each fastq list row,\n    collect the values of each attribute but in the order of the header\n    */\n    for (var _c = 0, fastq_list_rows_2 = fastq_list_rows; _c < fastq_list_rows_2.length; _c++) {\n        var fastq_list_row = fastq_list_rows_2[_c];\n        /*  Add csv row to file contents */\n        fastq_csv_file.contents += get_fastq_list_row_as_csv_row(fastq_list_row, row_order);\n    }\n    return fastq_csv_file;\n}\nfunction get_value_for_config(valueObj) {\n    /* If valueObj is an IFile, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"File\") {\n        return valueObj.path;\n    }\n    /* If valueObj is an IDirectory, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"Directory\") {\n        return valueObj.path;\n    }\n    /* Recursively call this function for nested objects */\n    if (typeof valueObj === 'object' && !Array.isArray(valueObj)) {\n        var newValueObj = {};\n        for (var key in valueObj) {\n            if (valueObj[key] === null || valueObj[key] === undefined) {\n                continue;\n            }\n            /* Special case - boolean to numeric */\n            if (key in DragenNumericBooleanType) {\n                newValueObj[key.replace(/_/g, \"-\")] = valueObj[key] ? 1 :0;\n                continue;\n            }\n            newValueObj[key.replace(/_/g, \"-\")] = get_value_for_config(valueObj[key]);\n        }\n        return newValueObj;\n    }\n    /* Consider arrays */\n    if (Array.isArray(valueObj)) {\n        return valueObj.map(function (item) { return get_value_for_config(item); });\n    }\n    /* Otherwise return the value as is */\n    return valueObj;\n}\nfunction get_dragen_config_path() {\n    return \"dragen_config.toml\";\n}\nfunction dragen_to_config_toml(props) {\n    /* Part 1 - Generate the json blob */\n    var json_blob = {};\n    for (var key in props) {\n        /* Get props key value */\n        var value = props[key];\n        /* Skip null props */\n        if (value === null || value === undefined) {\n            continue;\n        }\n        /*  FIXME denovo to DeNovo */\n        /* Special cases */\n        /* 1. Fastq list rows we rename to 'fastq-list',\n            alignment data mounted at the base of the working directory\n        */\n        /* Sequence data */\n        if (key === \"fastq_list_rows\") {\n            json_blob[\"fastq-list\"] = get_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"bam_input\") {\n            json_blob[\"bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_input\") {\n            json_blob[\"cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_reference\") {\n            json_blob[\"cram-reference\"] = value.basename;\n            continue;\n        }\n        /* Tumor sequence data */\n        if (key === \"tumor_fastq_list_rows\") {\n            json_blob['tumor-fastq-list'] = get_tumor_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"tumor_bam_input\") {\n            json_blob[\"tumor-bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_input\") {\n            json_blob[\"tumor-cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_reference\") {\n            json_blob[\"tumor-cram-reference\"] = value.basename;\n            continue;\n        }\n        /* 2. If ref-tar is parsed through, we use ref-dir instead */\n        if (key === \"ref_tar\") {\n            json_blob['ref-dir'] = get_ref_mount() + value.basename.replace(/\\.tar\\.gz$/, \"\");\n            /*\n                If the ref_tar does not contain 'graph',\n                then we also need to add the parameter,\n                --validate-pangenome-reference=false,\n                this was in place when we wanted to align genome to linear somatic reference\n                however, we are no longer doing that so this parameter is not needed\n            */\n            if (!value.basename.includes(\"graph\")) {\n                json_blob['validate-pangenome-reference'] = false;\n            }\n            continue;\n        }\n        /* If the ora reference is parsed through, we also place the ora reference into the scratch space */\n        if (key === \"ora_reference\") {\n            /* Mounted at scratch mount, strip the .tar.gz from the basename */\n            json_blob['ora-reference'] = get_ora_ref_path(value);\n            continue;\n        }\n        /* If the nirvana reference is parsed through, we also place the nirvana reference into the scratch space */\n        if (key === \"variant_annotation_data\") {\n            /* Mounted at the scratch mount, strip the .tar.gz from the basename */\n            json_blob['variant-annotation-data'] = get_nirvana_ref_path(value);\n            continue;\n        }\n        /* 3. Check if key is in the boolean to numeric list */\n        if (key in DragenNumericBooleanType) {\n            json_blob[key.replace(/_/g, \"-\")] = value ? 1 :0;\n            continue;\n        }\n        /* 4. Check if key is a qc coverage object */\n        if (key === \"qc_coverage\") {\n            /*\n            We need to iterate through the qc coverage objects\n            and add them to the json blob\n            */\n            value.forEach(function (qcObject, index) {\n                json_blob[\"qc-coverage-region-\".concat(index + 1)] = qcObject.region.path;\n                json_blob[\"qc-coverage-reports-\".concat(index + 1)] = qcObject.report_type;\n                if (qcObject.thresholds !== null && qcObject.thresholds !== undefined) {\n                    json_blob[\"qc-coverage-region-\".concat(index + 1, \"-thresholds\")] = qcObject.thresholds.map(function (threshold) { return threshold.toString(); }).join(\",\");\n                }\n            });\n            continue;\n        }\n        /* 5. Get value for standard options */\n        if (props.hasOwnProperty(key)) {\n            /*  We replace snake case with hyphen */\n            json_blob[key.replace(/_/g, \"-\")] = get_value_for_config(value);\n        }\n    }\n    /* Part 2 - Convert the json blob to toml */\n    return json_to_toml(json_blob);\n}\nfunction generate_sequence_data_mount_points(sequence_data, tumor_sequence_data) {\n    /*\n    Create and add in the fastq list csv for the input fastqs\n    If the input is bam or cram, we also mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the sequence data */\n    if (\"fastq_list_rows\" in sequence_data && sequence_data.fastq_list_rows !== undefined) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _i = 0, _a = sequence_data.fastq_list_rows; _i < _a.length; _i++) {\n            var fastq_list_row = _a[_i];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in sequence_data && sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.bam_input.secondaryFiles) {\n            sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in sequence_data && sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.cram_input.secondaryFiles) {\n            sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (sequence_data.cram_reference.secondaryFiles) {\n                sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Can exist here if germline-only */\n    if (!tumor_sequence_data) {\n        /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n        return e;\n    }\n    /*  Add the tumor sequence data */\n    if (\"fastq_list_rows\" in tumor_sequence_data && tumor_sequence_data.fastq_list_rows !== undefined) {\n        /* Upload the csv */\n        e.push({\n            \"entryname\":get_tumor_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(tumor_sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _b = 0, _c = tumor_sequence_data.fastq_list_rows; _b < _c.length; _b++) {\n            var fastq_list_row = _c[_b];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in tumor_sequence_data && tumor_sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.bam_input.secondaryFiles) {\n            tumor_sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in tumor_sequence_data && tumor_sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.cram_input.secondaryFiles) {\n            tumor_sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (tumor_sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":tumor_sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_sequence_data.cram_reference.secondaryFiles) {\n                tumor_sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_alignment_data_mount_points(alignment_data, tumor_alignment_data) {\n    /*\n    If the input is bam or cram, we mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the alignment data data */\n    if (\"bam_input\" in alignment_data && alignment_data.bam_input !== undefined) {\n        /* Add in the bam file */\n        e.push({\n            \"entryname\":alignment_data.bam_input.basename,\n            /* Due to the secondary files, we need to manually add in each file object */\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.bam_input.secondaryFiles) {\n            alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in alignment_data && alignment_data.cram_input !== undefined) {\n        /* Add in the cram file */\n        e.push({\n            \"entryname\":alignment_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.cram_input.secondaryFiles) {\n            alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (alignment_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":alignment_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":alignment_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (alignment_data.cram_reference.secondaryFiles) {\n                alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Now repeat for tumor alignment data */\n    if (tumor_alignment_data) {\n        /*  Add the alignment data data */\n        if (\"bam_input\" in tumor_alignment_data && tumor_alignment_data.bam_input !== undefined) {\n            /* Add in the bam file */\n            e.push({\n                \"entryname\":tumor_alignment_data.bam_input.basename,\n                /* Due to the secondary files, we need to manually add in each file object */\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.bam_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.bam_input.secondaryFiles) {\n                tumor_alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n        else if (\"cram_input\" in tumor_alignment_data && tumor_alignment_data.cram_input !== undefined) {\n            /* Add in the cram file */\n            e.push({\n                \"entryname\":tumor_alignment_data.cram_input.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.cram_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.cram_input.secondaryFiles) {\n                tumor_alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n            /*  We also add in the reference file if its provided */\n            if (tumor_alignment_data.cram_reference !== undefined) {\n                e.push({\n                    \"entryname\":tumor_alignment_data.cram_reference.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":tumor_alignment_data.cram_reference.location\n                    }\n                });\n                /* Then add in each secondary file object */\n                if (tumor_alignment_data.cram_reference.secondaryFiles) {\n                    tumor_alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                        e.push({\n                            \"entryname\":secondary_file_iter_.basename,\n                            \"entry\":{\n                                \"class\":\"File\",\n                                \"location\":secondary_file_iter_.location\n                            }\n                        });\n                    });\n                }\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_mv_qc_files_script_mount_points(options_list) {\n    /*\n     If alignment_options.qc_coverage is defined, we generate a script to move the qc files to their name attribute\n    */\n    var qc_files_script = generate_mv_qc_files_script(options_list);\n    if (!qc_files_script) {\n        return [];\n    }\n    else {\n        return [\n            {\n                entryname:qc_files_script.basename,\n                /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n                entry:qc_files_script\n            }\n        ];\n    }\n}\nfunction strip_uri_from_name(name_with_uri) {\n    /*\n    Given a string as a uri, return all after the trailing hash\n     */\n    return name_with_uri.split('#').pop() || name_with_uri;\n}\nfunction generate_mv_qc_files_script(options_list) {\n    /*\n    Generate mv qc files script\n     */\n    /* Check if alignment_options.qc_coverage is defined */\n    if (!options_list.alignment_options.qc_coverage || options_list.alignment_options.qc_coverage.length === 0) {\n        return null;\n    }\n    /* Initialise vars */\n    var output_file_prefix = options_list.output_file_prefix;\n    var output_directory = options_list.output_directory;\n    /* Initialise the script */\n    var mv_qc_files_script = \"#!/usr/bin/env bash\\n\\n\";\n    mv_qc_files_script += \"# Exit on failure\\n\";\n    mv_qc_files_script += \"set -euo pipefail\\n\\n\";\n    mv_qc_files_script += \"# Log start\\n\";\n    mv_qc_files_script += \"echo \\\"Start Moving QC files\\\" 1>&2\\n\\n\";\n    /* Arrays to make */\n    var qc_files_suffixes = [\n        /* Germline */\n        \"contig_mean_cov.csv\",\n        \"cov_report.bed\",\n        \"coverage_metrics.csv\",\n        \"fine_hist.csv\",\n        \"hist.csv\",\n        \"overall_mean_cov.csv\",\n        \"read_cov_report.bed\",\n        /* Somatic */\n        \"contig_mean_cov_normal.csv\",\n        \"contig_mean_cov_tumor.csv\",\n        \"cov_report_normal.bed\",\n        \"cov_report_tumor.bed\",\n        \"coverage_metrics_normal.csv\",\n        \"coverage_metrics_tumor.csv\",\n        \"fine_hist_normal.csv\",\n        \"fine_hist_tumor.csv\",\n        \"hist_normal.csv\",\n        \"hist_tumor.csv\",\n        \"overall_mean_cov_normal.csv\",\n        \"overall_mean_cov_tumor.csv\",\n        \"read_cov_report_normal.bed\",\n        \"read_cov_report_tumor.bed\",\n        \"somatic_callable_regions.bed\",\n    ];\n    var qc_file_names = options_list.alignment_options.qc_coverage.map(function (qc_coverage) { return strip_uri_from_name(qc_coverage.name); });\n    /* Create the qc suffixes array */\n    mv_qc_files_script += \"# Initialise coverage arrays \\n\";\n    mv_qc_files_script += \"QC_SUFFIXES=( \\\\\\n\";\n    for (var _i = 0, qc_files_suffixes_1 = qc_files_suffixes; _i < qc_files_suffixes_1.length; _i++) {\n        var qc_suffix = qc_files_suffixes_1[_i];\n        mv_qc_files_script += \"  \\\"\".concat(qc_suffix, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* QC Array complete */\n    /* Create the array of qc names */\n    mv_qc_files_script += \"QC_COVERAGE_NAMES=( \\\\\\n\";\n    for (var _a = 0, qc_file_names_1 = qc_file_names; _a < qc_file_names_1.length; _a++) {\n        var qc_coverage_name = qc_file_names_1[_a];\n        mv_qc_files_script += \"  \\\"\".concat(qc_coverage_name, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* Now iterate through each qc name and suffix to move the files */\n    mv_qc_files_script += \"# Move the QC files to the output directory\\n\";\n    mv_qc_files_script += \"for qc_name_idx in \\\"${!QC_COVERAGE_NAMES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"  qc_name=\\\"${QC_COVERAGE_NAMES[$qc_name_idx]}\\\"\\n\";\n    mv_qc_files_script += \"  for qc_suffix in \\\"${QC_SUFFIXES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"    if [[ -f \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" ]]; then\\n\");\n    mv_qc_files_script += \"      mv \\\\\\n\";\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" \\\\\\n\");\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-${qc_name}_${qc_suffix}\\\"\\n\");\n    mv_qc_files_script += \"    fi\\n\";\n    mv_qc_files_script += \"  done\\n\";\n    mv_qc_files_script += \"done\\n\\n\";\n    mv_qc_files_script += \"# Log completion\\n\";\n    mv_qc_files_script += \"echo \\\"Finish Moving QC files\\\" 1>&2\\n\";\n    return {\n        class:\"File\",\n        basename:\"mv_qc_files.sh\",\n        contents:mv_qc_files_script\n    };\n}\nfunction dragen_merge_options(options_list) {\n    /*\n    Merge a list of objects, ignoring null or undefined values\n    Options are merged in the order they are provided\n    So if there are duplicate keys, the last one will be used\n    */\n    var merged_options = {};\n    for (var _i = 0, options_list_1 = options_list; _i < options_list_1.length; _i++) {\n        var options_object = options_list_1[_i];\n        if (options_object === null || options_object === undefined) {\n            continue;\n        }\n        for (var key in options_object) {\n            /*\n             Check if the key is null or undefined.\n            */\n            if (options_object[key] === undefined) {\n                continue;\n            }\n            /*\n              If the merged key does NOT exist in the merged options but the value is null we add it in\n            */\n            if ((!merged_options.hasOwnProperty(key)) && options_object[key] === null) {\n                merged_options[key] = null;\n                continue;\n            }\n            /*\n              If the merged key DOES exist in the merged options but the value is null we skip it\n            */\n            if (merged_options.hasOwnProperty(key) && options_object[key] === null) {\n                continue;\n            }\n            /*\n              If the key already exists in merged options, check if the\n              merged_options key is a dictionary, if so we need to recursively merge instead\n            */\n            if (merged_options.hasOwnProperty(key) &&\n                typeof merged_options[key] === 'object' &&\n                (merged_options[key] !== null) &&\n                !Array.isArray(merged_options[key])) {\n                /*\n                  Check the item key is also an object\n                */\n                if (typeof options_object[key] === 'object' && !Array.isArray(options_object[key])) {\n                    /*\n                      If the key is an object, we merge the two objects\n                      This is useful for options that have sub-options\n                      However we dont to override values in merged_options that are already set\n                      if the value in the options object is null,\n                      we can solve this by calling the dragen_merge_options function recursively\n                    */\n                    merged_options[key] = dragen_merge_options([\n                        merged_options[key],\n                        options_object[key]\n                    ]);\n                }\n                /*\n                  Otherwise we just override it.\n                */\n                else {\n                    merged_options[key] = options_object[key];\n                }\n                continue;\n            }\n            /*\n            Just a standard option.\n            */\n            if (options_object.hasOwnProperty(key)) {\n                merged_options[key] = options_object[key];\n            }\n        }\n    }\n    return merged_options;\n}\nfunction get_dragen_wgts_dna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name ? props.sample_name :\"\", \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction get_dragen_wgts_rna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name, \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_rna_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Set enable rna to true */\n        enable_rna:true,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction filter_object_by_keys(object1, object2) {\n    /**\n     * Return object 1 with only the keys that are in object 2\n     */\n    var filtered_object = {};\n    /* Dont need to filter if object1 is null or undefined */\n    if (object1 === null || object1 === undefined) {\n        return object2;\n    }\n    /* Iterate through object1 and check if the key is in object2 */\n    for (var key in object1) {\n        if (object2.hasOwnProperty(key)) {\n            filtered_object[key] = object1[key];\n        }\n    }\n    return filtered_object;\n}\nfunction get_dragen_wgts_dna_variant_calling_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /*\n        Naming things\n        */\n        sample_name:props.sample_name,\n        tumor_sample_name:props.tumor_sample_name,\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        tumor_sequence_data:props.tumor_sequence_data,\n        ref_tar:props.reference.tarball,\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:(props.tumor_sample_name ? props.tumor_sample_name :props.sample_name),\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:((props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") +\n            props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__\" +\n            \"dragen_wgts_dna_\" + (props.tumor_sample_name ? \"somatic\" :\"germline\") + \"_variant_calling\"),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        /* SNV caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        /* CNV caller options */\n        cnv_caller_options:props.cnv_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* SV caller options */\n        sv_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.sv_caller_options),\n            props.sv_caller_options,\n        ]),\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n        /* Targeted Caller options */\n        targeted_caller_options:props.targeted_caller_options,\n        /* Mrjd Options */\n        mrjd_options:props.mrjd_options,\n        /* TMB Options */\n        tmb_options:props.tmb_options,\n        /* MSI Options */\n        msi_options:props.msi_options,\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n    };\n}\nfunction get_dragen_wgts_rna_variant_calling_stage_options_from_pipeline(props) {\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Annotation file, used for a lot of the variant calling options */\n        annotation_file:props.annotation_file,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:props.sample_name,\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:(props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__dragen_wgts_rna_variant_calling\"),\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        gene_expression_quantification_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.gene_expression_quantification_options),\n            props.gene_expression_quantification_options,\n        ]),\n        gene_fusion_detection_options:props.gene_fusion_detection_options,\n        splice_variant_caller_options:props.splice_variant_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n    };\n}\n/**\n * Multiqc functions\n *\n */\nfunction get_wgts_dna_multiqc_output_filename(props) {\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc_report.html\";\n}\nfunction get_wgts_rna_multiqc_output_filename(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc_report.html\";\n}\nfunction get_wgts_dna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc\";\n}\nfunction get_wgts_rna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc\";\n}\nfunction get_wgts_dna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS DNA Pipeline ( \" +\n        (props.tumor_sample_name ? props.tumor_sample_name + \"/\" :\"\") +\n        props.sample_name + \" )\");\n}\nfunction get_wgts_rna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS RNA Pipeline ( \" +\n        props.sample_name +\n        \" )\");\n}\nfunction pick_first_non_null(object_list) {\n    for (var _i = 0, object_list_1 = object_list; _i < object_list_1.length; _i++) {\n        var object = object_list_1[_i];\n        if (object) {\n            return object;\n        }\n    }\n}\nfunction pick_all_non_null(object_list) {\n    var non_null_objects = [];\n    for (var _i = 0, object_list_2 = object_list; _i < object_list_2.length; _i++) {\n        var object = object_list_2[_i];\n        if (object) {\n            non_null_objects.push(object);\n        }\n    }\n    return non_null_objects;\n}\nfunction dragen_references_match(reference_list) {\n    /*\n    Determine if the two references match,\n    If one the references is null or undefined then still return true\n    Since we really just want to know if we have two different references\n    */\n    if (reference_list.length !== 2) {\n        throw new Error(\"dragen_references_match:reference_list must be of length 2\");\n    }\n    /* Check if either of the references are null or undefined */\n    if (!reference_list[0] || !reference_list[1]) {\n        return true;\n    }\n    return reference_list[0].tarball.location == reference_list[1].tarball.location;\n}\n/* Utility functions */\nfunction get_optional_attribute_from_object(input_object, attribute) {\n    /*\n    Get attribute from object, if attribute is not defined return null\n    Assume the input object is an object of key value pairs where we know the key is of type string\n    stackoverflow.com/questions/56833469/typescript-error-ts7053-element-implicitly-has-an-any-type\n    */\n    if (input_object.hasOwnProperty(attribute)) {\n        return input_object[attribute];\n    }\n    else {\n        return null;\n    }\n}\nfunction get_attribute_from_optional_input(input_object, attribute) {\n    /*\n    Get attribute from optional input -\n    If input is not defined, then return null\n    */\n    if (input_object === null || input_object === undefined) {\n        return null;\n    }\n    else {\n        return get_optional_attribute_from_object(input_object, attribute);\n    }\n}\nfunction is_not_null(input_obj) {\n    /*\n    Determine if input object is defined and is not null\n    */\n    return !(input_obj === null || input_obj === undefined);\n}\n"
          ],
          "class": "InlineJavascriptRequirement"
        },
        {
          "class": "MultipleInputFeatureRequirement"
        },
        {
          "class": "ScatterFeatureRequirement"
        },
        {
          "types": [
            {
              "$import": "#dragen-reference__1.0.0.yaml/dragen-reference"
            },
            {
              "$import": "#fastq-list-row__2.0.0.yaml/fastq-list-row"
            },
            {
              "$import": "#fastq-list-rows-input__2.0.0.yaml/fastq-list-rows-input"
            },
            {
              "$import": "#bam-input__1.0.0.yaml/bam-input"
            },
            {
              "$import": "#cram-input__1.0.0.yaml/cram-input"
            },
            {
              "type": "record",
              "name": "#bam-output__1.0.0.yaml/bam-output",
              "fields": [
                {
                  "type": "File",
                  "label": "bam-output",
                  "doc": "Bam input file",
                  "secondaryFiles": [
                    {
                      "pattern": ".bai",
                      "required": true
                    }
                  ],
                  "name": "#bam-output__1.0.0.yaml/bam-output/bam_output"
                }
              ]
            },
            {
              "type": "record",
              "name": "#cram-output__1.0.0.yaml/cram-output",
              "fields": [
                {
                  "type": "File",
                  "secondaryFiles": [
                    {
                      "pattern": ".crai",
                      "required": true
                    }
                  ],
                  "name": "#cram-output__1.0.0.yaml/cram-output/cram_output"
                }
              ]
            },
            {
              "$import": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options"
            },
            {
              "$import": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options"
            },
            {
              "$import": "#dragen-qc-coverage__1.0.0.yaml/dragen-qc-coverage"
            },
            {
              "$import": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options"
            },
            {
              "$import": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options"
            },
            {
              "$import": "#dragen-cnv-caller-options__4.4.0.yaml/dragen-cnv-caller-options"
            },
            {
              "$import": "#dragen-maf-conversion-options__4.4.0.yaml/dragen-maf-conversion-options"
            },
            {
              "$import": "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options"
            },
            {
              "$import": "#dragen-nirvana-annotation-options__4.4.0.yaml/dragen-nirvana-annotation-options"
            },
            {
              "$import": "#dragen-targeted-caller-options__4.4.0.yaml/dragen-targeted-caller-options"
            },
            {
              "$import": "#dragen-mrjd-options__4.4.0.yaml/dragen-mrjd-options"
            },
            {
              "$import": "#dragen-tmb-options__4.4.0.yaml/dragen-tmb-options"
            },
            {
              "$import": "#dragen-msi-options__4.4.0.yaml/dragen-msi-options"
            },
            {
              "type": "record",
              "name": "#dragen-wgts-options-alignment-stage__4.4.0.yaml/dragen-wgts-options-alignment-stage",
              "fields": [
                {
                  "label": "alignment options",
                  "doc": "Specifies the alignment options\n",
                  "type": [
                    {
                      "$import": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options"
                    }
                  ],
                  "name": "#dragen-wgts-options-alignment-stage__4.4.0.yaml/dragen-wgts-options-alignment-stage/alignment_options"
                },
                {
                  "label": "enable rna",
                  "doc": "Specifies whether the sample is RNA or DNA. This option is used to determine the alignment algorithm to use.\nIf set to true, the sample is treated as RNA and the appropriate alignment algorithm is used.\n",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "name": "#dragen-wgts-options-alignment-stage__4.4.0.yaml/dragen-wgts-options-alignment-stage/enable_rna"
                },
                {
                  "label": "lic instance id location",
                  "doc": "Use this option to override the default cloud instance ID location\n",
                  "type": [
                    "null",
                    "string",
                    "File"
                  ],
                  "name": "#dragen-wgts-options-alignment-stage__4.4.0.yaml/dragen-wgts-options-alignment-stage/lic_instance_id_location"
                },
                {
                  "label": "ora reference",
                  "doc": "The ora reference to use for decompression of fastq files.\n",
                  "type": [
                    "null",
                    "File"
                  ],
                  "name": "#dragen-wgts-options-alignment-stage__4.4.0.yaml/dragen-wgts-options-alignment-stage/ora_reference"
                },
                {
                  "label": "output directory",
                  "doc": "Specifies the output directory.\n",
                  "type": "string",
                  "name": "#dragen-wgts-options-alignment-stage__4.4.0.yaml/dragen-wgts-options-alignment-stage/output_directory"
                },
                {
                  "label": "output file prefix",
                  "doc": "Outputs file name prefix to use for all files generated by the pipeline.\n",
                  "type": "string",
                  "name": "#dragen-wgts-options-alignment-stage__4.4.0.yaml/dragen-wgts-options-alignment-stage/output_file_prefix"
                },
                {
                  "label": "ref tar",
                  "doc": "Specifies the tarball containing the reference hash table. If the reference is not already loaded into the DRAGEN card, the option automatically loads the reference.\nNote that the actual dragen command is '--ref-dir' but we first need to download and extract the tarball.\n",
                  "type": "File",
                  "name": "#dragen-wgts-options-alignment-stage__4.4.0.yaml/dragen-wgts-options-alignment-stage/ref_tar"
                },
                {
                  "label": "sequence data",
                  "doc": "The sequence data to be aligned and called variants on.\nThis can either be a bam file, cram file or a list of fastq list row objects\n",
                  "type": [
                    {
                      "$import": "#fastq-list-rows-input__2.0.0.yaml/fastq-list-rows-input"
                    },
                    {
                      "$import": "#bam-input__1.0.0.yaml/bam-input"
                    },
                    {
                      "$import": "#cram-input__1.0.0.yaml/cram-input"
                    }
                  ],
                  "name": "#dragen-wgts-options-alignment-stage__4.4.0.yaml/dragen-wgts-options-alignment-stage/sequence_data"
                }
              ]
            },
            {
              "$import": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage"
            }
          ],
          "class": "SchemaDefRequirement"
        },
        {
          "class": "StepInputExpressionRequirement"
        },
        {
          "class": "SubworkflowFeatureRequirement"
        }
      ],
      "inputs": [
        {
          "label": "alignment options",
          "doc": "The options to be used for alignment.\nThis is a JSON object that contains the options to be used for alignment.\nThis is passed to the Dragen alignment tool.\n",
          "type": [
            "null",
            "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options"
          ],
          "id": "#main/alignment_options"
        },
        {
          "label": "cnv calling options",
          "doc": "The options to be used for cnv calling.\nThis is a JSON object that contains the options to be used for cnv calling.\nThis is passed to the variant calling pipeline, make sure to add 'enable_cnv' to the cnv caller options\nAs it is not enabled by default\n",
          "type": [
            "null",
            "#dragen-cnv-caller-options__4.4.0.yaml/dragen-cnv-caller-options"
          ],
          "id": "#main/cnv_caller_options"
        },
        {
          "label": "license instance id location",
          "doc": "Path to the lic instance id location,\ndefault is '/opt/instance-identity',\nbut user can either provide an alternative location\nin the docker image or provide their own file.\n",
          "type": [
            "null",
            "File",
            "string"
          ],
          "default": "/opt/instance-identity",
          "id": "#main/lic_instance_id_location"
        },
        {
          "label": "maf conversion options",
          "doc": "The options to be used for maf conversion.\nThis is a JSON object that contains the options to be used for maf conversion.\nThis is passed to the variant calling pipeline, make sure to add 'enable_maf_output' to the maf conversion options\nAs it is not enabled by default.\n",
          "type": [
            "null",
            "#dragen-maf-conversion-options__4.4.0.yaml/dragen-maf-conversion-options"
          ],
          "id": "#main/maf_conversion_options"
        },
        {
          "label": "mrjd options",
          "doc": "The options to be used for multi-region-joint-detection.\nMake sure to add 'enable_mrjd' to the mrjd options\nAs it is not enabled by default.\nThese parameters are parsed only to the germline variant calling stage.\n",
          "type": [
            "null",
            "#dragen-mrjd-options__4.4.0.yaml/dragen-mrjd-options"
          ],
          "id": "#main/mrjd_options"
        },
        {
          "label": "nirvana annotation options",
          "doc": "The options to be used for nirvana annotation.\nThis is a JSON object that contains the options to be used for nirvana annotation.\nThis is passed to the variant calling pipeline, make sure to add 'enable_variant_annotation' to the nirvana annotation options\nAs it is not enabled by default.\n",
          "type": [
            "null",
            "#dragen-nirvana-annotation-options__4.4.0.yaml/dragen-nirvana-annotation-options"
          ],
          "id": "#main/nirvana_annotation_options"
        },
        {
          "label": "reference",
          "doc": "The ora reference used to decompress the input fastq files,\nrequired if any of the fastqs are ora-compressed\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/ora_reference"
        },
        {
          "label": "reference",
          "doc": "The reference genome to be used for alignment and variant calling.\n",
          "type": "#dragen-reference__1.0.0.yaml/dragen-reference",
          "id": "#main/reference"
        },
        {
          "label": "sample name",
          "doc": "The sample name to be used for alignment and variant calling.\nThis is used to name the output files\n",
          "type": "string",
          "id": "#main/sample_name"
        },
        {
          "label": "sequence data",
          "doc": "The sequence data to be aligned and called variants on.\nThis can either be a bam file, cram file or a list of fastq list row objects\n",
          "type": [
            "#fastq-list-rows-input__2.0.0.yaml/fastq-list-rows-input",
            "#bam-input__1.0.0.yaml/bam-input",
            "#cram-input__1.0.0.yaml/cram-input"
          ],
          "id": "#main/sequence_data"
        },
        {
          "label": "variant calling options",
          "doc": "The options to be used for variant calling.\nThis is a JSON object that contains the options to be used for variant calling.\nThis is passed to the Dragen variant calling tool.\n",
          "type": [
            "null",
            "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options"
          ],
          "id": "#main/snv_variant_caller_options"
        },
        {
          "label": "somatic alignment options",
          "doc": "The options to be used for alignment of the tumor sample.\nThis is a JSON object that contains the options to be used for alignment.\nThis is passed to the Dragen alignment tool.\nFor the somatic alignment, both alignment options and somatic alignment options are first merged before being provided to dragen\n",
          "type": [
            "null",
            "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options"
          ],
          "id": "#main/somatic_alignment_options"
        },
        {
          "label": "somatic cnv calling options",
          "doc": "The options to be used for cnv calling in the somatic variant calling stage.\nThis is a JSON object that contains the options to be used for cnv calling.\nThis is passed to the variant calling pipeline, make sure to add 'enable_cnv' to the cnv caller options\nAs it is not enabled by default.\nFor the somatic cnv-caller, both cnv-caller options and somatic cnv-caller options are first merged before being provided to dragen\n",
          "type": [
            "null",
            "#dragen-cnv-caller-options__4.4.0.yaml/dragen-cnv-caller-options"
          ],
          "id": "#main/somatic_cnv_caller_options"
        },
        {
          "label": "somatic maf conversion options",
          "doc": "The options to be used for maf conversion in the somatic maf conversion stage.\nThis is a JSON object that contains the options to be used for maf conversion.\nThis is passed to the variant calling pipeline, make sure to add 'enable_maf_output' to the maf conversion options\nAs it is not enabled by default.\nFor the somatic maf conversion, both maf conversion options and somatic maf conversion options are first merged before being provided to dragen\n",
          "type": [
            "null",
            "#dragen-maf-conversion-options__4.4.0.yaml/dragen-maf-conversion-options"
          ],
          "id": "#main/somatic_maf_conversion_options"
        },
        {
          "label": "somatic msi options",
          "doc": "The options to be used for msi calling in the somatic variant calling stage.\nPlease set msi_command to \"tumor-normal\" to enable the msi calling, all other options are optional\n",
          "type": [
            "null",
            "#dragen-msi-options__4.4.0.yaml/dragen-msi-options"
          ],
          "id": "#main/somatic_msi_options"
        },
        {
          "label": "somatic annotation options",
          "doc": "The options to be used for nirvana annotation.\nThis is a JSON object that contains the options to be used for nirvana annotation.\nThis is passed to the variant calling pipeline, make sure to add 'enable_variant_annotation' to the nirvana annotation options\nAs it is not enabled by default.\n",
          "type": [
            "null",
            "#dragen-nirvana-annotation-options__4.4.0.yaml/dragen-nirvana-annotation-options"
          ],
          "id": "#main/somatic_nirvana_annotation_options"
        },
        {
          "label": "somatic reference",
          "doc": "The somatic reference genome to be used for alignment and variant calling.\nThis is only used if the somatic reference is different from the normal reference.\n",
          "type": [
            "null",
            "#dragen-reference__1.0.0.yaml/dragen-reference"
          ],
          "id": "#main/somatic_reference"
        },
        {
          "label": "somatic variant calling options",
          "doc": "The options to be used for alignment of the normal sample.\nThis is a JSON object that contains the options to be used for alignment.\nThis is passed to the Dragen alignment tool.\nFor the somatic variant-caller, both variant-caller options and somatic variant-caller options are first merged before being provided to dragen\n",
          "type": [
            "null",
            "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options"
          ],
          "id": "#main/somatic_snv_variant_caller_options"
        },
        {
          "label": "somatic sv calling options",
          "doc": "The options to be used for sv calling in the somatic variant calling stage.\nThis is a JSON object that contains the options to be used for sv calling.\nThis is passed to the variant calling pipeline, make sure to add 'enable_sv' to the sv caller options\nAs it is not enabled by default.\nFor the somatic sv caller, both sv caller options and somatic sv caller options are first merged before being provided to dragen\n",
          "type": [
            "null",
            "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options"
          ],
          "id": "#main/somatic_sv_caller_options"
        },
        {
          "label": "somatic tmb options",
          "doc": "The options to be used for tmb calling in the somatic variant calling stage.\nPlease set 'enable_tmb' to true to enable the tmb calling, all other options are optional\n",
          "type": [
            "null",
            "#dragen-tmb-options__4.4.0.yaml/dragen-tmb-options"
          ],
          "id": "#main/somatic_tmb_options"
        },
        {
          "label": "sv calling options",
          "doc": "The options to be used for sv calling in the variant calling stage.\nThis is a JSON object that contains the options to be used for sv calling.\nThis is passed to the variant calling pipeline, make sure to add 'enable_sv' to the sv caller options\nAs it is not enabled by default.\n",
          "type": [
            "null",
            "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options"
          ],
          "id": "#main/sv_caller_options"
        },
        {
          "label": "targeted caller options",
          "doc": "The options to be used for targeted calling.\nThis is a JSON object that contains the options to be used for targeted calling.\nThis is passed to the variant calling pipeline, make sure to add 'enable_targeted_caller' to the targeted caller options\nAs it is not enabled by default.\n",
          "type": [
            "null",
            "#dragen-targeted-caller-options__4.4.0.yaml/dragen-targeted-caller-options"
          ],
          "id": "#main/targeted_caller_options"
        },
        {
          "label": "tumor sample name",
          "doc": "The tumor sample name to be used for alignment and variant calling.\nThis is used to name the output files\n",
          "type": [
            "null",
            "string"
          ],
          "id": "#main/tumor_sample_name"
        },
        {
          "label": "tumor sequence data",
          "doc": "The sequence data to be aligned and called variants on.\nThis can either be a bam file, cram file or a list of fastq list row objects\nOnly specify the tumor sequence data IF you want to run the somatic variant calling pipeline.\n",
          "type": [
            "null",
            "#fastq-list-rows-input__2.0.0.yaml/fastq-list-rows-input",
            "#bam-input__1.0.0.yaml/bam-input",
            "#cram-input__1.0.0.yaml/cram-input"
          ],
          "id": "#main/tumor_sequence_data"
        }
      ],
      "steps": [
        {
          "label": "run variant calling stage",
          "doc": "Run the variant calling stage on the germline alignment data\n",
          "in": [
            {
              "source": [
                "#main/sample_name",
                "#main/reference",
                "#main/ora_reference",
                "#main/run_reheader_sequence_data_step/alignment_file_out_renamed",
                "#main/sequence_data",
                "#main/run_get_default_alignment_options_schema_step/alignment_options_output",
                "#main/run_get_variant_calling_options_as_schemas_step/snv_variant_caller_options_output",
                "#main/cnv_caller_options",
                "#main/maf_conversion_options",
                "#main/run_get_variant_calling_options_as_schemas_step/sv_caller_options_output",
                "#main/run_nirvana_annotation_data_step/nirvana_assembly_tarball",
                "#main/nirvana_annotation_options",
                "#main/targeted_caller_options",
                "#main/mrjd_options",
                "#main/lic_instance_id_location",
                "#main/run_get_dragen_configuration_options_step/dragen_default_configuration_options"
              ],
              "valueFrom": "${\n  /*\n      // Sample Names\n      self[0] - sample_name\n\n      // References\n      self[1] - reference\n\n      // ORA Reference\n      self[2] - ora_reference\n\n      // Input sequence data\n      self[3] - run_reheader_sequence_data_step/alignment_file_out_renamed\n      self[4] - sequence_data\n\n      // Alignment options\n      self[5] - run_get_default_alignment_options_schema_step/alignment_options\n\n      // Variant caller options\n      self[6] - snv_variant_caller_options\n\n      // CNV caller options\n      self[7] - cnv_caller_options\n\n      // MAF conversion options\n      self[8] - maf_conversion_options\n\n      // SV caller options\n      self[9] - sv_caller_options\n\n      // Nirvana annotation options\n      self[10] - nirvana_assembly_tarball\n      self[11] - nirvana_annotation_options\n\n      // Targeted caller options\n      self[12] - targeted_caller_options\n\n      // MRJD options\n      self[13] - mrjd_options\n\n      // License file\n      self[14] - lic_instance_id_location\n\n      // Default Dragen Configuration\n      self[15] - default_configuration_options\n  */\n\n  /* If run rename rgsm step was never run, just leave the sequence data as is */\n  if (self[3] === null){\n    var sequence_data = self[4];\n  } else {\n    /* Otherwise merge */\n    /* Initialise the object */\n    var reheadered_object = {};\n    /* Coerce into sequence_data format */\n    if (self[3].hasOwnProperty(\"class\") && self[3].class === \"File\") {\n      /* Determine if we have a cram or a bam file */\n      if (self[3].nameext === \".bam\"){\n        reheadered_object[\"bam_input\"] = self[3];\n      } else if (self[3].nameext === \".cram\"){\n        reheadered_object[\"cram_input\"] = self[3];\n      }\n    }\n    var sequence_data = dragen_merge_options([self[4], reheadered_object]);\n  }\n\n  /* If the nirvana assembly tarball was never downloaded, just set to null */\n  /* Or if weve set somatic_nirvana_annotation_options but not nirvana_annotation_options */\n  if (\n     self[10] === null ||\n     ( !self[11] || !self[11].enable_variant_annotation )\n  ) {\n     var nirvana_annotation_options = self[11];\n  } else {\n    /* Otherwise merge */\n    var nirvana_annotation_options = dragen_merge_options([self[11], {\"variant_annotation_data\": self[10]}]);\n  }\n\n  return get_dragen_wgts_dna_variant_calling_stage_options_from_pipeline(\n    {\n      \"sample_name\": self[0],\n      \"reference\": self[1],\n      \"ora_reference\": self[2],\n      \"sequence_data\": sequence_data,\n      \"alignment_options\": self[5],\n      \"snv_variant_caller_options\": self[6],\n      \"cnv_caller_options\": self[7],\n      \"maf_conversion_options\": self[8],\n      \"sv_caller_options\": self[9],\n      \"nirvana_annotation_options\": nirvana_annotation_options,\n      \"targeted_caller_options\": self[12],\n      \"mrjd_options\": self[13],\n      /* Add in the somatic tmb and msi options as null */\n      \"tmb_options\": null,\n      \"msi_options\": null,\n      /* License file */\n      \"lic_instance_id_location\": self[14],\n      /* Default Dragen Configuration */\n      \"default_configuration_options\": JSON.parse(self[15])\n    }\n  );\n}\n",
              "id": "#main/run_dragen_variant_calling_stage/dragen_options"
            }
          ],
          "out": [
            {
              "id": "#main/run_dragen_variant_calling_stage/output_directory"
            }
          ],
          "run": "#dragen-wgts-dna-variant-calling-stage__4.4.6.cwl",
          "id": "#main/run_dragen_variant_calling_stage"
        },
        {
          "label": "run variant calling stage tumor",
          "doc": "Run the variant calling stage on the somatic + germline alignment data\nThis is only run when the somatic inputs are provided\n",
          "when": "${\n  /* Only run when tumor sequence data is provided */\n  return inputs.run_condition;\n}\n",
          "in": [
            {
              "source": [
                "#main/sample_name",
                "#main/tumor_sample_name",
                "#main/somatic_reference",
                "#main/reference",
                "#main/ora_reference",
                "#main/run_reheader_sequence_data_step/alignment_file_out_renamed",
                "#main/sequence_data",
                "#main/run_reheader_sequence_data_step_tumor/alignment_file_out_renamed",
                "#main/tumor_sequence_data",
                "#main/somatic_alignment_options",
                "#main/run_get_default_alignment_options_schema_step/alignment_options_output",
                "#main/somatic_snv_variant_caller_options",
                "#main/run_get_variant_calling_options_as_schemas_step/snv_variant_caller_options_output",
                "#main/somatic_cnv_caller_options",
                "#main/cnv_caller_options",
                "#main/somatic_maf_conversion_options",
                "#main/maf_conversion_options",
                "#main/somatic_sv_caller_options",
                "#main/run_get_variant_calling_options_as_schemas_step/sv_caller_options_output",
                "#main/run_nirvana_annotation_data_step/nirvana_assembly_tarball",
                "#main/somatic_nirvana_annotation_options",
                "#main/nirvana_annotation_options",
                "#main/somatic_tmb_options",
                "#main/somatic_msi_options",
                "#main/lic_instance_id_location",
                "#main/run_get_dragen_configuration_options_step/dragen_default_configuration_options"
              ],
              "valueFrom": "${\n  /*\n      // Sample Names\n      self[0] - sample_name\n      self[1] - tumor_sample_name\n\n      // References\n      self[2] - somatic_reference\n      self[3] - reference\n\n      // ORA Reference\n      self[4] - ora_reference\n\n      // Input sequence data files\n      self[5] - sequence data reheadered\n      self[6] - sequence data original\n\n      // Tumor sequence data files\n      self[7] - tumor sequence data reheadered\n      self[8] - tumor sequence data\n\n      // Alignment data\n      self[9] - somatic alignment options\n      self[10] - alignment options\n\n      // Variant calling options\n      self[11] - somatic_snv_variant_caller_options\n      self[12] - snv_variant_caller_options\n\n      // CNV caller options\n      self[13] - somatic_cnv_caller_options\n      self[14] - cnv_caller_options\n\n      // MAF conversion options\n      self[15] - somatic_maf_conversion_options\n      self[16] - maf_conversion_options\n\n      // SV caller options\n      self[17] - somatic_sv_caller_options\n      self[18] - sv_caller_options\n\n      // Nirvana annotation options\n      self[19] - nirvana_assembly_tarball\n      self[20] - somatic_nirvana_annotation_options\n      self[21] - nirvana_annotation_options\n\n      // Somatic TMB options\n      self[22] - somatic_tmb_options\n\n      // Somatic MSI options\n      self[23] - somatic_msi_options\n\n      // License file\n      self[24] - lic_instance_id_location\n\n      // Default Dragen Configuration\n      self[25] - default_configuration_options\n  */\n\n  /* If run rename rgsm step was never run, just leave the sequence data as is */\n  if (self[5] === null){\n    var sequence_data = self[6];\n  } else {\n    /* Otherwise merge */\n    /* Initialise the object */\n    var reheadered_object = {};\n    /* Coerce into sequence_data format */\n    if (self[5].hasOwnProperty(\"class\") && self[5].class === \"File\") {\n      /* Determine if we have a cram or a bam file */\n      if (self[5].nameext == \".bam\"){\n        reheadered_object[\"bam_input\"] = self[5];\n      } else if (self[5].nameext == \".cram\"){\n        reheadered_object[\"cram_input\"] = self[5];\n      }\n    }\n    var sequence_data = dragen_merge_options([self[6], reheadered_object]);\n  }\n\n  /* If run rename rgsm step tumor was never run, just leave the sequence data as is */\n  if (self[7] === null){\n    var tumor_sequence_data = self[8];\n  } else {\n    /* Otherwise merge */\n    /* Initialise the object */\n    var reheadered_object = {};\n    /* Coerce into tumor_sequence_data format */\n    if (self[7].hasOwnProperty(\"class\") && self[7].class === \"File\") {\n      /* Determine if we have a cram or a bam file */\n      if (self[7].nameext == \".bam\"){\n        reheadered_object[\"bam_input\"] = self[7];\n      } else if (self[7].nameext == \".cram\"){\n        reheadered_object[\"cram_input\"] = self[7];\n      }\n    }\n    var tumor_sequence_data = dragen_merge_options([self[8], reheadered_object]);\n  }\n\n  /* If the nirvana assembly tarball was never downloaded, just set to null */\n  if (self[19] === null){\n     var nirvana_annotation_options = dragen_merge_options([self[21], self[20]]);\n  } else {\n    /* Otherwise merge */\n    var nirvana_annotation_options = dragen_merge_options([self[21], self[20], {\"variant_annotation_data\": self[19]}]);\n  }\n\n  return get_dragen_wgts_dna_variant_calling_stage_options_from_pipeline(\n    {\n      \"sample_name\": self[0],\n      \"tumor_sample_name\": self[1],\n      \"reference\": pick_first_non_null([self[2], self[3]]),\n      \"ora_reference\": self[4],\n      \"sequence_data\": sequence_data,\n      \"tumor_sequence_data\": tumor_sequence_data,\n      \"alignment_options\": dragen_merge_options([self[10], self[9]]),\n      \"snv_variant_caller_options\": dragen_merge_options([self[12], self[11]]),\n      \"cnv_caller_options\": dragen_merge_options([self[14], self[13]]),\n      \"maf_conversion_options\": dragen_merge_options([self[16], self[15]]),\n      \"sv_caller_options\": dragen_merge_options([self[18], self[17]]),\n      \"nirvana_annotation_options\": nirvana_annotation_options,\n      \"tmb_options\": self[22],\n      \"msi_options\": self[23],\n      /* Targeted caller options are not available in the somatic variant calling stage */\n      \"targeted_caller_options\": null,\n      /* MRJD options are not available in the somatic variant calling stage */\n      \"mrjd_options\": null,\n      /* Add in the license file */\n      \"lic_instance_id_location\": self[24],\n      \"default_configuration_options\": JSON.parse(self[25])\n    }\n  );\n}\n",
              "id": "#main/run_dragen_variant_calling_stage_tumor/dragen_options"
            },
            {
              "source": [
                "#main/tumor_sample_name"
              ],
              "valueFrom": "${\n  /* Return true if the tumor sample name is not null */\n  if(self){\n    return true;\n  } else {\n    return false;\n  };\n}\n",
              "id": "#main/run_dragen_variant_calling_stage_tumor/run_condition"
            }
          ],
          "out": [
            {
              "id": "#main/run_dragen_variant_calling_stage_tumor/output_directory"
            }
          ],
          "run": "#dragen-wgts-dna-variant-calling-stage__4.4.6.cwl",
          "id": "#main/run_dragen_variant_calling_stage_tumor"
        },
        {
          "label": "get default alignment options schema",
          "doc": "Get the default alignment options schema if the input is null\nWe need this before we accidentally filter out any relevant keys from the default configuration options\n",
          "in": [
            {
              "source": "#main/alignment_options",
              "valueFrom": "${\n  if(!self){\n    return {};\n  } else {\n    return self;\n  }\n}\n",
              "id": "#main/run_get_default_alignment_options_schema_step/alignment_options"
            }
          ],
          "out": [
            {
              "id": "#main/run_get_default_alignment_options_schema_step/alignment_options_output"
            }
          ],
          "run": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl",
          "id": "#main/run_get_default_alignment_options_schema_step"
        },
        {
          "label": "get dragen configuration options",
          "doc": "We first need to get the existing dragen configuration options under\n/opt/edico/config/dragen-user-defaults.cfg (in toml format), and parse this in as JSON format.\nWe can then use this in all our dragen tools to 'merge'\n",
          "in": [],
          "out": [
            {
              "id": "#main/run_get_dragen_configuration_options_step/dragen_default_configuration_options"
            }
          ],
          "run": "#get-dragen-default-configuration-json__4.4.6.cwl",
          "id": "#main/run_get_dragen_configuration_options_step"
        },
        {
          "label": "get default dna-variant-calling options schema",
          "doc": "Get the default dna-variant-calling options schema if the input is null\nWe need this before we accidentally filter out any relevant keys from the default configuration options\n",
          "in": [
            {
              "source": "#main/snv_variant_caller_options",
              "valueFrom": "${\n  if(!self){\n    return {};\n  } else {\n    return self;\n  }\n}\n",
              "id": "#main/run_get_variant_calling_options_as_schemas_step/snv_variant_caller_options"
            },
            {
              "source": "#main/sv_caller_options",
              "valueFrom": "${\n  if(!self){\n    return {};\n  } else {\n    return self;\n  }\n}\n",
              "id": "#main/run_get_variant_calling_options_as_schemas_step/sv_caller_options"
            }
          ],
          "out": [
            {
              "id": "#main/run_get_variant_calling_options_as_schemas_step/snv_variant_caller_options_output"
            },
            {
              "id": "#main/run_get_variant_calling_options_as_schemas_step/sv_caller_options_output"
            }
          ],
          "run": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl",
          "id": "#main/run_get_variant_calling_options_as_schemas_step"
        },
        {
          "label": "run multiqc",
          "doc": "Run multiqc on the outputs of the alignment and variant calling stages\n",
          "in": [
            {
              "pickValue": "all_non_null",
              "source": [
                "#main/run_dragen_variant_calling_stage/output_directory",
                "#main/run_dragen_variant_calling_stage_tumor/output_directory"
              ],
              "id": "#main/run_multiqc/input_directories"
            },
            {
              "source": [
                "#main/sample_name",
                "#main/tumor_sample_name"
              ],
              "valueFrom": "${\n  /* Return the output directory name */\n  return get_wgts_dna_multiqc_output_directory_name(\n    {\n      \"sample_name\": self[0],\n      \"tumor_sample_name\": self[1]\n    }\n  );\n}\n",
              "id": "#main/run_multiqc/output_directory_name"
            },
            {
              "source": [
                "#main/sample_name",
                "#main/tumor_sample_name"
              ],
              "valueFrom": "${\n  /* Return the output filename */\n  return get_wgts_dna_multiqc_output_filename(\n    {\n      \"sample_name\": self[0],\n      \"tumor_sample_name\": self[1]\n    }\n  );\n}\n",
              "id": "#main/run_multiqc/output_filename"
            },
            {
              "source": [
                "#main/sample_name",
                "#main/tumor_sample_name"
              ],
              "valueFrom": "${\n  /* Return the title */\n  return get_wgts_dna_multiqc_title(\n    {\n      \"sample_name\": self[0],\n      \"tumor_sample_name\": self[1]\n    }\n  );\n}\n",
              "id": "#main/run_multiqc/title"
            }
          ],
          "out": [
            {
              "id": "#main/run_multiqc/output_directory"
            }
          ],
          "run": "#multiqc__1.25.1.cwl",
          "id": "#main/run_multiqc"
        },
        {
          "label": "run nirvana annotation data step",
          "doc": "If either somatic_nirvana_annotation_options or nirvana_annotation_options enable_variant_annotation is true,\nBut the variant_annotation_data is not provided, we will need to download the nirvana annotation data first\n",
          "when": "${\n  /* Only run when tumor sequence data is provided and is a bam / cram file */\n  return inputs.run_condition;\n}\n",
          "in": [
            {
              "source": "#main/somatic_tmb_options",
              "valueFrom": "${\n  if (self && self.enable_tmb) {\n    return \"tmb\";\n  } else {\n    return \"all\";\n  }\n}\n",
              "id": "#main/run_nirvana_annotation_data_step/annotations_type"
            },
            {
              "source": [
                "#main/nirvana_annotation_options",
                "#main/somatic_nirvana_annotation_options"
              ],
              "valueFrom": "${\n  if (self[0] && self[0].variant_annotation_assembly){\n    return self[0].variant_annotation_assembly;\n  } else if (self[1] && self[1].variant_annotation_assembly){\n    return self[1].variant_annotation_assembly;\n  } else {\n    return null;\n  }\n}\n",
              "id": "#main/run_nirvana_annotation_data_step/genome_version"
            },
            {
              "source": [
                "#main/nirvana_annotation_options",
                "#main/somatic_nirvana_annotation_options"
              ],
              "valueFrom": "${\n  /* If neither nirvana annotation options nor somatic options are provided, return false */\n  if (!self[0] && !self[1]){\n    return false;\n  };\n  /*\n    If either nirvana annotation options or somatic options enable variant annotation,\n    but the variant annotation data has not been provided return true\n  */\n  if (\n    ( self[0] && self[0].enable_variant_annotation && !self[0].variant_annotation_data ) ||\n    ( self[1] && self[1].enable_variant_annotation && !self[1].variant_annotation_data )\n  ){\n    return true;\n  } else {\n    return false;\n  }\n}\n",
              "id": "#main/run_nirvana_annotation_data_step/run_condition"
            }
          ],
          "out": [
            {
              "id": "#main/run_nirvana_annotation_data_step/nirvana_assembly_tarball"
            }
          ],
          "run": "#dragen-nirvana-downloader__4.4.4.cwl",
          "id": "#main/run_nirvana_annotation_data_step"
        },
        {
          "label": "run reheader sequence data step",
          "doc": "If our sequence data files are bam / cram files, we will need to reheader them first before commencing the pipeline\n",
          "when": "${\n  /* Only run when our sequence data is a bam or cram file */\n  return inputs.run_condition;\n}\n",
          "in": [
            {
              "source": "#main/sequence_data",
              "valueFrom": "${\n  /* Does run_validation pass */\n  if (self.bam_input || self.cram_input){\n    if (self.bam_input){\n      return self.bam_input;\n    }\n    return self.cram_input;\n  }\n  /*\n    Otherwise we need to make up a bam_input record just to validate the inputs\n    since the **when** condition isnt evaluated until the input objects are validated\n  */\n  return {\n    \"class\": \"File\",\n    \"location\": \"https://example.com/empty.bam\",\n    \"basename\": \"empty.bam\",\n    \"secondaryFiles\": [\n       {\n          \"class\": \"File\",\n          \"location\": \"https://example.com/empty.bam.bai\",\n          \"basename\": \"empty.bam.bai\"\n       }\n    ]\n  }\n}\n",
              "id": "#main/run_reheader_sequence_data_step/alignment_file"
            },
            {
              "source": "#main/sample_name",
              "valueFrom": "${\n  /* Does run_validation pass */\n  if (self){\n    return self;\n  }\n  /* Otherwise just return nothing, this step wont run anyway */\n  return \"\";\n}\n",
              "id": "#main/run_reheader_sequence_data_step/rgsm"
            },
            {
              "source": "#main/sequence_data",
              "valueFrom": "${\n  if (self.bam_input || self.cram_input){\n    return true;\n  } else {\n    return false;\n  }\n}\n",
              "id": "#main/run_reheader_sequence_data_step/run_condition"
            }
          ],
          "out": [
            {
              "id": "#main/run_reheader_sequence_data_step/alignment_file_out_renamed"
            }
          ],
          "run": "#rename-rgsm-in-alignment-header__1.0.0.cwl",
          "id": "#main/run_reheader_sequence_data_step"
        },
        {
          "label": "run reheader sequence data step tumor",
          "doc": "If our tumor sequence data files are bam / cram files, we will need to reheader them first before commencing the pipeline\n",
          "when": "${\n  /* Only run when tumor sequence data is provided and is a bam / cram file */\n  return inputs.run_condition;\n}\n",
          "in": [
            {
              "source": "#main/tumor_sequence_data",
              "valueFrom": "${\n  /* Does run_validation pass */\n  if (self && (self.bam_input || self.cram_input)){\n    if (self.bam_input){\n      return self.bam_input;\n    }\n    return self.cram_input;\n  }\n\n  /*\n    Otherwise we need to make up a bam_input record just to validate the inputs\n    since the **when** condition isnt evaluated until the input objects are validated\n  */\n  return {\n    \"class\": \"File\",\n    \"location\": \"https://example.com/empty.bam\",\n    \"basename\": \"empty.bam\",\n    \"secondaryFiles\": [\n       {\n          \"class\": \"File\",\n          \"location\": \"https://example.com/empty.bam.bai\",\n          \"basename\": \"empty.bam.bai\"\n       }\n    ]\n  };\n}\n",
              "id": "#main/run_reheader_sequence_data_step_tumor/alignment_file"
            },
            {
              "source": "#main/tumor_sample_name",
              "valueFrom": "${\n  /* Does run_validation pass */\n  if (self){\n    return self;\n  }\n  /* Otherwise just return nothing, this step wont run anyway */\n  return \"\";\n}\n",
              "id": "#main/run_reheader_sequence_data_step_tumor/rgsm"
            },
            {
              "source": "#main/tumor_sequence_data",
              "valueFrom": "${\n  if (!self){\n    return false;\n  };\n  if (self.bam_input || self.cram_input){\n    return true;\n  } else {\n    return false;\n  }\n}\n",
              "id": "#main/run_reheader_sequence_data_step_tumor/run_condition"
            }
          ],
          "out": [
            {
              "id": "#main/run_reheader_sequence_data_step_tumor/alignment_file_out_renamed"
            }
          ],
          "run": "#rename-rgsm-in-alignment-header__1.0.0.cwl",
          "id": "#main/run_reheader_sequence_data_step_tumor"
        }
      ],
      "outputs": [
        {
          "type": "Directory",
          "outputSource": "#main/run_dragen_variant_calling_stage/output_directory",
          "label": "dragen variant calling output directory",
          "doc": "The outputs of the variant calling stage.\n",
          "id": "#main/dragen_variant_calling_output_directory"
        },
        {
          "type": [
            "null",
            "Directory"
          ],
          "outputSource": "#main/run_dragen_variant_calling_stage_tumor/output_directory",
          "label": "dragen variant calling output directory",
          "doc": "The outputs of the variant calling stage for the tumor sample.\n",
          "id": "#main/dragen_variant_calling_output_directory_tumor"
        },
        {
          "type": "Directory",
          "outputSource": "#main/run_multiqc/output_directory",
          "label": "multiqc output directory",
          "doc": "The outputs of the multiqc stage.\nThis contains the multiqc report and the multiqc config file.\n",
          "id": "#main/multiqc_output_directory"
        }
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "Workflow",
      "id": "#dragen-create-aligner-options-object__4.4.0.cwl",
      "label": "dragen-create-aligner-options-object v(4.4.0)",
      "doc": "Documentation for dragen-create-aligner-options-object\nv4.4.0\n",
      "requirements": [
        {
          "class": "InlineJavascriptRequirement"
        },
        {
          "class": "MultipleInputFeatureRequirement"
        },
        {
          "class": "ScatterFeatureRequirement"
        },
        {
          "types": [
            {
              "$import": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options"
            },
            {
              "$import": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options"
            }
          ],
          "class": "SchemaDefRequirement"
        },
        {
          "class": "StepInputExpressionRequirement"
        }
      ],
      "inputs": [
        {
          "label": "aligner options",
          "doc": "Input file, of varying format depending on the command run\n",
          "type": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options",
          "id": "#dragen-create-aligner-options-object__4.4.0.cwl/dragen-create-aligner-options-object--4.4.0/aligner_options"
        }
      ],
      "steps": [
        {
          "in": [
            {
              "source": "#dragen-create-aligner-options-object__4.4.0.cwl/dragen-create-aligner-options-object--4.4.0/aligner_options",
              "valueFrom": "${\n  return self;\n}\n",
              "id": "#dragen-create-aligner-options-object__4.4.0.cwl/dragen-create-aligner-options-object--4.4.0/parse_aligner_options/aligner_options_input"
            }
          ],
          "out": [
            {
              "id": "#dragen-create-aligner-options-object__4.4.0.cwl/dragen-create-aligner-options-object--4.4.0/parse_aligner_options/aligner_options_output"
            }
          ],
          "run": "#dragen-parse-aligner-schema__4.4.0.cwl",
          "id": "#dragen-create-aligner-options-object__4.4.0.cwl/dragen-create-aligner-options-object--4.4.0/parse_aligner_options"
        }
      ],
      "outputs": [
        {
          "label": "aligner options output",
          "doc": "Output file, of varying format depending on the command run\n",
          "outputSource": "#dragen-create-aligner-options-object__4.4.0.cwl/dragen-create-aligner-options-object--4.4.0/parse_aligner_options/aligner_options_output",
          "type": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options",
          "id": "#dragen-create-aligner-options-object__4.4.0.cwl/dragen-create-aligner-options-object--4.4.0/aligner_options_output"
        }
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "Workflow",
      "id": "#dragen-create-mapper-options-object__4.4.0.cwl",
      "label": "dragen-create-mapper-options-object v(4.4.0)",
      "doc": "Documentation for dragen-create-mapper-options-object\nv4.4.0\n",
      "requirements": [
        {
          "class": "InlineJavascriptRequirement"
        },
        {
          "class": "MultipleInputFeatureRequirement"
        },
        {
          "class": "ScatterFeatureRequirement"
        },
        {
          "types": [
            {
              "$import": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options"
            },
            {
              "$import": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options"
            }
          ],
          "class": "SchemaDefRequirement"
        },
        {
          "class": "StepInputExpressionRequirement"
        }
      ],
      "inputs": [
        {
          "label": "mapper options",
          "doc": "Mapping options\n",
          "type": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options",
          "id": "#dragen-create-mapper-options-object__4.4.0.cwl/dragen-create-mapper-options-object--4.4.0/mapper_options"
        }
      ],
      "steps": [
        {
          "in": [
            {
              "source": "#dragen-create-mapper-options-object__4.4.0.cwl/dragen-create-mapper-options-object--4.4.0/mapper_options",
              "valueFrom": "${\n  return self;\n}\n",
              "id": "#dragen-create-mapper-options-object__4.4.0.cwl/dragen-create-mapper-options-object--4.4.0/parse_mapper_options/mapper_options_input"
            }
          ],
          "out": [
            {
              "id": "#dragen-create-mapper-options-object__4.4.0.cwl/dragen-create-mapper-options-object--4.4.0/parse_mapper_options/mapper_options_output"
            }
          ],
          "run": "#dragen-parse-mapper-schema__4.4.0.cwl",
          "id": "#dragen-create-mapper-options-object__4.4.0.cwl/dragen-create-mapper-options-object--4.4.0/parse_mapper_options"
        }
      ],
      "outputs": [
        {
          "label": "mapper options output",
          "doc": "Output file, of varying format depending on the command run\n",
          "outputSource": "#dragen-create-mapper-options-object__4.4.0.cwl/dragen-create-mapper-options-object--4.4.0/parse_mapper_options/mapper_options_output",
          "type": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options",
          "id": "#dragen-create-mapper-options-object__4.4.0.cwl/dragen-create-mapper-options-object--4.4.0/mapper_options_output"
        }
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "Workflow",
      "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl",
      "label": "dragen-create-wgts-alignment-options-object v(4.4.0)",
      "doc": "Documentation for dragen-create-wgts-alignment-options-object\nv4.4.0\n",
      "requirements": [
        {
          "expressionLib": [
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Globals */\n/*\nList of options that are booleans but where the values are expressed as a number\n*/\nvar DragenNumericBooleanType = [\n    \"global\",\n    \"all\"\n];\nvar DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH = '/opt/instance-identity';\n/*  Functions */\nfunction get_scratch_mount() {\n    /*\n    Return the path of the scratch directory space\n    */\n    return \"/scratch/\";\n}\nfunction get_intermediate_results_dir() {\n    /*\n    Get intermediate results directory as /scratch for dragen runs\n    */\n    return get_scratch_mount() + \"intermediate-results/\";\n}\nfunction get_name_root_from_tarball(basename) {\n    var tar_ball_regex = /(\\S+)\\.tar(?:\\.gz)?/g;\n    var tar_ball_expression = tar_ball_regex.exec(basename);\n    if (tar_ball_expression === null) {\n        throw new Error(\"Could not get nameroot from \".concat(basename));\n    }\n    return tar_ball_expression[1];\n}\nfunction get_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_ref_mount() {\n    /*\n    Get the reference mount point\n    */\n    return get_scratch_mount() + \"ref/\";\n}\nfunction get_ora_ref_mount() {\n    /*\n    Get the ORA reference mount point\n    */\n    return get_scratch_mount() + \"ora-reference/\";\n}\nfunction get_ora_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ora_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_nirvana_ref_mount() {\n    /*\n    Get the Nirvana reference mount point\n    */\n    return get_scratch_mount() + \"nirvana-reference/\";\n}\nfunction get_nirvana_ref_path(reference_input_obj) {\n    return get_nirvana_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_variant_annotation_data_mount(nirvana_annotation_options) {\n    if (!nirvana_annotation_options) {\n        return null;\n    }\n    if (!nirvana_annotation_options.variant_annotation_data) {\n        return null;\n    }\n    return get_attribute_from_optional_input(nirvana_annotation_options.variant_annotation_data, \"path\");\n}\nfunction get_dragen_bin_path() {\n    /*\n    Get dragen bin path\n    */\n    return \"/opt/edico/bin/dragen\";\n}\nfunction get_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"fastq_list.csv\";\n}\nfunction get_tumor_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"tumor_fastq_list.csv\";\n}\nfunction capitalizeFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction json_to_toml(json_data) {\n    /*  Convert JSON to TOML format */\n    /*  Much easier than the other way around */\n    /*  Initialize an empty string to store the TOML data */\n    var toml_data = '';\n    var global_keys_list = [];\n    /*  Iterate through each key in the JSON object to first find the 'global' keys */\n    for (var key in json_data) {\n        var value = json_data[key];\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            continue;\n        }\n        global_keys_list.push(key);\n    }\n    var _loop_1 = function (key) {\n        var value = json_data[key];\n        if (value === null) {\n            return \"continue\";\n        }\n        /*  If the value is an array, we need to make an entry for each item in the array */\n        else if (Array.isArray(value)) {\n            value.forEach(function (item) {\n                toml_data += \"\".concat(key, \" = \").concat(item, \"\\n\");\n            });\n        }\n        else {\n            /*  Regular append */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    };\n    /*  Add global keys to the TOML data first */\n    for (var _i = 0, global_keys_list_1 = global_keys_list; _i < global_keys_list_1.length; _i++) {\n        var key = global_keys_list_1[_i];\n        _loop_1(key);\n    }\n    /*  Iterate through each key in the JSON object */\n    for (var key in json_data) {\n        var value = json_data[key];\n        /*  Skip global keys */\n        if (global_keys_list.indexOf(key) !== -1) {\n            continue;\n        }\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"File\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is a directory, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"Directory\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is an object, treat it as a section */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            /*  Section header should have a capitalized first letter */\n            toml_data += \"[\".concat(capitalizeFirstLetter(key), \"]\\n\");\n            for (var sub_key in value) {\n                toml_data += \"\".concat(sub_key, \" = \").concat(value[sub_key], \"\\n\");\n            }\n        }\n        /*  If the value is a string, treat it as a key-value pair */\n        else {\n            /*  Otherwise, treat it as a key-value pair */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    }\n    /*  Return the TOML data */\n    return toml_data;\n}\n/* Convert TOML to JSON format */\nfunction toml_to_json(toml_str) {\n    /*\n    Convert TOML to JSON format.\n    This implementation uses a simple TOML parser for basic key-value pairs and sections.\n    For production use, consider using a library like `@iarna/toml` or `toml`.\n    */\n    var result = {};\n    var currentSection = null;\n    var lines = toml_str.split(/\\r?\\n/);\n    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n        var line = lines_1[_i];\n        line = line.trim();\n        if (!line || line.startsWith(\"#\"))\n            continue;\n        /*  Section header */\n        var sectionMatch = line.match(/^\\[(.+)\\]$/);\n        if (sectionMatch) {\n            /*  Make section lowercase */\n            currentSection = sectionMatch[1].toLowerCase().trim();\n            if (!result[currentSection]) {\n                result[currentSection] = {};\n            }\n            continue;\n        }\n        /*  Key-value pair */\n        var kvMatch = line.match(/^([^=]+)=(.*)$/);\n        if (kvMatch) {\n            var key = kvMatch[1].trim();\n            var value = kvMatch[2].trim();\n            /*  Check if value is empty */\n            if ((value === \"\")) {\n                value = null;\n            }\n            /*  Remove quotes if present */\n            else if ((value.startsWith('\"') && value.endsWith('\"')) ||\n                (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n                value = value.slice(1, -1);\n            }\n            else if (value === \"true\" || value === \"false\") {\n                value = value === \"true\";\n            }\n            else if (!isNaN(Number(value))) {\n                value = Number(value);\n            }\n            /* Set the key name by replacing hyphens with underscores */\n            key = key.replace(/-/g, '_');\n            /* Replace hyphens with underscores in the key */\n            if (currentSection) {\n                /* Check if the key exists in the current section */\n                if (result[currentSection].hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[currentSection][key])) {\n                        /* Push the entry */\n                        result[currentSection][key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[currentSection][key] !== undefined) {\n                            result[currentSection][key] = [result[currentSection][key], value];\n                        }\n                        else {\n                            result[currentSection][key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[currentSection][key] = value;\n                }\n            }\n            else {\n                /* Check if the key exists */\n                if (result.hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[key])) {\n                        /* Push the entry */\n                        result[key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[key] !== undefined) {\n                            result[key] = [result[key], value];\n                        }\n                        else {\n                            result[key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[key] = value;\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction build_fastq_list_csv_header(header_names) {\n    /*\n    Convert lowercase labels to uppercase values\n    i.e\n    [ \"rgid\", \"rglb\", \"rgsm\", \"lane\", \"read_1\", \"read_2\" ]\n    to\n    \"RGID,RGLB,RGSM,Lane,Read1File,Read2File\"\n    */\n    var modified_header_names = [];\n    for (var _i = 0, header_names_1 = header_names; _i < header_names_1.length; _i++) {\n        var header_name = header_names_1[_i];\n        if (header_name.indexOf(\"rg\") === 0) {\n            /*\n            rgid -> RGID\n            */\n            modified_header_names.push(header_name.toUpperCase());\n        }\n        else if (header_name.indexOf(\"read\") === 0) {\n            /*\n            read_1 -> Read1File\n            */\n            modified_header_names.push(\"Read\" + header_name.charAt(header_name.length - 1) + \"File\");\n        }\n        else {\n            /*\n            lane to Lane\n            */\n            modified_header_names.push(header_name[0].toUpperCase() + header_name.substr(1));\n        }\n    }\n    /*\n    Convert array to comma separated strings\n    */\n    return modified_header_names.join(\",\") + \"\\n\";\n}\nfunction get_fastq_list_row_as_csv_row(fastq_list_row, row_order) {\n    var fastq_list_row_values_array = [];\n    /*  This for loop is here to ensure were assigning values in the same order as the header */\n    for (var _i = 0, row_order_1 = row_order; _i < row_order_1.length; _i++) {\n        var item_index = row_order_1[_i];\n        var found_item = false;\n        /*  Find matching attribute in this row */\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            var fastq_list_row_field_value = fastq_list_row[fastq_list_row_field_name];\n            if (fastq_list_row_field_value === null) {\n                /*\n                Item not found, add an empty attribute for this cell in the csv\n                */\n                continue;\n            }\n            /*  The header value matches the name in the item */\n            if (fastq_list_row_field_name === item_index) {\n                /*\n                If the field value has a class attribute then it's either read_1 or read_2\n                */\n                if (fastq_list_row_field_value.hasOwnProperty(\"class\")) {\n                    var fastq_list_row_field_value_file = fastq_list_row_field_value;\n                    /*\n                    Assert that this is actually of class file\n                    */\n                    if (fastq_list_row_field_value_file.class !== \"File\") {\n                        continue;\n                    }\n                    /*  Read 1 and 2 files are mounted as rgid/filename */\n                    fastq_list_row_values_array.push(fastq_list_row.rgid + '/' + fastq_list_row_field_value_file.basename);\n                }\n                else {\n                    /*\n                    Push the string attribute to the fastq list csv row\n                    Replace any commas in the string with ' -'\n                    */\n                    fastq_list_row_values_array.push(fastq_list_row_field_value.toString().replace(/,/g, \" -\"));\n                }\n                found_item = true;\n                break;\n            }\n        }\n        if (!found_item) {\n            /*\n            Push blank cell if no item found\n            */\n            fastq_list_row_values_array.push(\"\");\n        }\n    }\n    /*\n    Convert to string and return as string\n    */\n    return fastq_list_row_values_array.join(\",\") + \"\\n\";\n}\nfunction generate_fastq_list_csv(fastq_list_rows) {\n    /*\n    Fastq list rows generation\n    */\n    var fastq_csv_file = {\n        class:\"File\",\n        basename:get_fastq_list_csv_path()\n    };\n    /*\n    Set the row order\n    */\n    var row_order = [];\n    /*\n    Set the array order\n    Make sure we iterate through all rows of the array\n    */\n    for (var _i = 0, fastq_list_rows_1 = fastq_list_rows; _i < fastq_list_rows_1.length; _i++) {\n        var fastq_list_row = fastq_list_rows_1[_i];\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            if (row_order.indexOf(fastq_list_row_field_name) === -1) {\n                row_order.push(fastq_list_row_field_name);\n            }\n        }\n    }\n    /*\n    Make header\n    */\n    fastq_csv_file.contents = build_fastq_list_csv_header(row_order);\n    /*\n    For each fastq list row,\n    collect the values of each attribute but in the order of the header\n    */\n    for (var _c = 0, fastq_list_rows_2 = fastq_list_rows; _c < fastq_list_rows_2.length; _c++) {\n        var fastq_list_row = fastq_list_rows_2[_c];\n        /*  Add csv row to file contents */\n        fastq_csv_file.contents += get_fastq_list_row_as_csv_row(fastq_list_row, row_order);\n    }\n    return fastq_csv_file;\n}\nfunction get_value_for_config(valueObj) {\n    /* If valueObj is an IFile, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"File\") {\n        return valueObj.path;\n    }\n    /* If valueObj is an IDirectory, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"Directory\") {\n        return valueObj.path;\n    }\n    /* Recursively call this function for nested objects */\n    if (typeof valueObj === 'object' && !Array.isArray(valueObj)) {\n        var newValueObj = {};\n        for (var key in valueObj) {\n            if (valueObj[key] === null || valueObj[key] === undefined) {\n                continue;\n            }\n            /* Special case - boolean to numeric */\n            if (key in DragenNumericBooleanType) {\n                newValueObj[key.replace(/_/g, \"-\")] = valueObj[key] ? 1 :0;\n                continue;\n            }\n            newValueObj[key.replace(/_/g, \"-\")] = get_value_for_config(valueObj[key]);\n        }\n        return newValueObj;\n    }\n    /* Consider arrays */\n    if (Array.isArray(valueObj)) {\n        return valueObj.map(function (item) { return get_value_for_config(item); });\n    }\n    /* Otherwise return the value as is */\n    return valueObj;\n}\nfunction get_dragen_config_path() {\n    return \"dragen_config.toml\";\n}\nfunction dragen_to_config_toml(props) {\n    /* Part 1 - Generate the json blob */\n    var json_blob = {};\n    for (var key in props) {\n        /* Get props key value */\n        var value = props[key];\n        /* Skip null props */\n        if (value === null || value === undefined) {\n            continue;\n        }\n        /*  FIXME denovo to DeNovo */\n        /* Special cases */\n        /* 1. Fastq list rows we rename to 'fastq-list',\n            alignment data mounted at the base of the working directory\n        */\n        /* Sequence data */\n        if (key === \"fastq_list_rows\") {\n            json_blob[\"fastq-list\"] = get_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"bam_input\") {\n            json_blob[\"bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_input\") {\n            json_blob[\"cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_reference\") {\n            json_blob[\"cram-reference\"] = value.basename;\n            continue;\n        }\n        /* Tumor sequence data */\n        if (key === \"tumor_fastq_list_rows\") {\n            json_blob['tumor-fastq-list'] = get_tumor_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"tumor_bam_input\") {\n            json_blob[\"tumor-bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_input\") {\n            json_blob[\"tumor-cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_reference\") {\n            json_blob[\"tumor-cram-reference\"] = value.basename;\n            continue;\n        }\n        /* 2. If ref-tar is parsed through, we use ref-dir instead */\n        if (key === \"ref_tar\") {\n            json_blob['ref-dir'] = get_ref_mount() + value.basename.replace(/\\.tar\\.gz$/, \"\");\n            /*\n                If the ref_tar does not contain 'graph',\n                then we also need to add the parameter,\n                --validate-pangenome-reference=false,\n                this was in place when we wanted to align genome to linear somatic reference\n                however, we are no longer doing that so this parameter is not needed\n            */\n            if (!value.basename.includes(\"graph\")) {\n                json_blob['validate-pangenome-reference'] = false;\n            }\n            continue;\n        }\n        /* If the ora reference is parsed through, we also place the ora reference into the scratch space */\n        if (key === \"ora_reference\") {\n            /* Mounted at scratch mount, strip the .tar.gz from the basename */\n            json_blob['ora-reference'] = get_ora_ref_path(value);\n            continue;\n        }\n        /* If the nirvana reference is parsed through, we also place the nirvana reference into the scratch space */\n        if (key === \"variant_annotation_data\") {\n            /* Mounted at the scratch mount, strip the .tar.gz from the basename */\n            json_blob['variant-annotation-data'] = get_nirvana_ref_path(value);\n            continue;\n        }\n        /* 3. Check if key is in the boolean to numeric list */\n        if (key in DragenNumericBooleanType) {\n            json_blob[key.replace(/_/g, \"-\")] = value ? 1 :0;\n            continue;\n        }\n        /* 4. Check if key is a qc coverage object */\n        if (key === \"qc_coverage\") {\n            /*\n            We need to iterate through the qc coverage objects\n            and add them to the json blob\n            */\n            value.forEach(function (qcObject, index) {\n                json_blob[\"qc-coverage-region-\".concat(index + 1)] = qcObject.region.path;\n                json_blob[\"qc-coverage-reports-\".concat(index + 1)] = qcObject.report_type;\n                if (qcObject.thresholds !== null && qcObject.thresholds !== undefined) {\n                    json_blob[\"qc-coverage-region-\".concat(index + 1, \"-thresholds\")] = qcObject.thresholds.map(function (threshold) { return threshold.toString(); }).join(\",\");\n                }\n            });\n            continue;\n        }\n        /* 5. Get value for standard options */\n        if (props.hasOwnProperty(key)) {\n            /*  We replace snake case with hyphen */\n            json_blob[key.replace(/_/g, \"-\")] = get_value_for_config(value);\n        }\n    }\n    /* Part 2 - Convert the json blob to toml */\n    return json_to_toml(json_blob);\n}\nfunction generate_sequence_data_mount_points(sequence_data, tumor_sequence_data) {\n    /*\n    Create and add in the fastq list csv for the input fastqs\n    If the input is bam or cram, we also mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the sequence data */\n    if (\"fastq_list_rows\" in sequence_data && sequence_data.fastq_list_rows !== undefined) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _i = 0, _a = sequence_data.fastq_list_rows; _i < _a.length; _i++) {\n            var fastq_list_row = _a[_i];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in sequence_data && sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.bam_input.secondaryFiles) {\n            sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in sequence_data && sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.cram_input.secondaryFiles) {\n            sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (sequence_data.cram_reference.secondaryFiles) {\n                sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Can exist here if germline-only */\n    if (!tumor_sequence_data) {\n        /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n        return e;\n    }\n    /*  Add the tumor sequence data */\n    if (\"fastq_list_rows\" in tumor_sequence_data && tumor_sequence_data.fastq_list_rows !== undefined) {\n        /* Upload the csv */\n        e.push({\n            \"entryname\":get_tumor_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(tumor_sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _b = 0, _c = tumor_sequence_data.fastq_list_rows; _b < _c.length; _b++) {\n            var fastq_list_row = _c[_b];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in tumor_sequence_data && tumor_sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.bam_input.secondaryFiles) {\n            tumor_sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in tumor_sequence_data && tumor_sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.cram_input.secondaryFiles) {\n            tumor_sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (tumor_sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":tumor_sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_sequence_data.cram_reference.secondaryFiles) {\n                tumor_sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_alignment_data_mount_points(alignment_data, tumor_alignment_data) {\n    /*\n    If the input is bam or cram, we mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the alignment data data */\n    if (\"bam_input\" in alignment_data && alignment_data.bam_input !== undefined) {\n        /* Add in the bam file */\n        e.push({\n            \"entryname\":alignment_data.bam_input.basename,\n            /* Due to the secondary files, we need to manually add in each file object */\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.bam_input.secondaryFiles) {\n            alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in alignment_data && alignment_data.cram_input !== undefined) {\n        /* Add in the cram file */\n        e.push({\n            \"entryname\":alignment_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.cram_input.secondaryFiles) {\n            alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (alignment_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":alignment_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":alignment_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (alignment_data.cram_reference.secondaryFiles) {\n                alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Now repeat for tumor alignment data */\n    if (tumor_alignment_data) {\n        /*  Add the alignment data data */\n        if (\"bam_input\" in tumor_alignment_data && tumor_alignment_data.bam_input !== undefined) {\n            /* Add in the bam file */\n            e.push({\n                \"entryname\":tumor_alignment_data.bam_input.basename,\n                /* Due to the secondary files, we need to manually add in each file object */\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.bam_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.bam_input.secondaryFiles) {\n                tumor_alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n        else if (\"cram_input\" in tumor_alignment_data && tumor_alignment_data.cram_input !== undefined) {\n            /* Add in the cram file */\n            e.push({\n                \"entryname\":tumor_alignment_data.cram_input.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.cram_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.cram_input.secondaryFiles) {\n                tumor_alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n            /*  We also add in the reference file if its provided */\n            if (tumor_alignment_data.cram_reference !== undefined) {\n                e.push({\n                    \"entryname\":tumor_alignment_data.cram_reference.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":tumor_alignment_data.cram_reference.location\n                    }\n                });\n                /* Then add in each secondary file object */\n                if (tumor_alignment_data.cram_reference.secondaryFiles) {\n                    tumor_alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                        e.push({\n                            \"entryname\":secondary_file_iter_.basename,\n                            \"entry\":{\n                                \"class\":\"File\",\n                                \"location\":secondary_file_iter_.location\n                            }\n                        });\n                    });\n                }\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_mv_qc_files_script_mount_points(options_list) {\n    /*\n     If alignment_options.qc_coverage is defined, we generate a script to move the qc files to their name attribute\n    */\n    var qc_files_script = generate_mv_qc_files_script(options_list);\n    if (!qc_files_script) {\n        return [];\n    }\n    else {\n        return [\n            {\n                entryname:qc_files_script.basename,\n                /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n                entry:qc_files_script\n            }\n        ];\n    }\n}\nfunction strip_uri_from_name(name_with_uri) {\n    /*\n    Given a string as a uri, return all after the trailing hash\n     */\n    return name_with_uri.split('#').pop() || name_with_uri;\n}\nfunction generate_mv_qc_files_script(options_list) {\n    /*\n    Generate mv qc files script\n     */\n    /* Check if alignment_options.qc_coverage is defined */\n    if (!options_list.alignment_options.qc_coverage || options_list.alignment_options.qc_coverage.length === 0) {\n        return null;\n    }\n    /* Initialise vars */\n    var output_file_prefix = options_list.output_file_prefix;\n    var output_directory = options_list.output_directory;\n    /* Initialise the script */\n    var mv_qc_files_script = \"#!/usr/bin/env bash\\n\\n\";\n    mv_qc_files_script += \"# Exit on failure\\n\";\n    mv_qc_files_script += \"set -euo pipefail\\n\\n\";\n    mv_qc_files_script += \"# Log start\\n\";\n    mv_qc_files_script += \"echo \\\"Start Moving QC files\\\" 1>&2\\n\\n\";\n    /* Arrays to make */\n    var qc_files_suffixes = [\n        /* Germline */\n        \"contig_mean_cov.csv\",\n        \"cov_report.bed\",\n        \"coverage_metrics.csv\",\n        \"fine_hist.csv\",\n        \"hist.csv\",\n        \"overall_mean_cov.csv\",\n        \"read_cov_report.bed\",\n        /* Somatic */\n        \"contig_mean_cov_normal.csv\",\n        \"contig_mean_cov_tumor.csv\",\n        \"cov_report_normal.bed\",\n        \"cov_report_tumor.bed\",\n        \"coverage_metrics_normal.csv\",\n        \"coverage_metrics_tumor.csv\",\n        \"fine_hist_normal.csv\",\n        \"fine_hist_tumor.csv\",\n        \"hist_normal.csv\",\n        \"hist_tumor.csv\",\n        \"overall_mean_cov_normal.csv\",\n        \"overall_mean_cov_tumor.csv\",\n        \"read_cov_report_normal.bed\",\n        \"read_cov_report_tumor.bed\",\n        \"somatic_callable_regions.bed\",\n    ];\n    var qc_file_names = options_list.alignment_options.qc_coverage.map(function (qc_coverage) { return strip_uri_from_name(qc_coverage.name); });\n    /* Create the qc suffixes array */\n    mv_qc_files_script += \"# Initialise coverage arrays \\n\";\n    mv_qc_files_script += \"QC_SUFFIXES=( \\\\\\n\";\n    for (var _i = 0, qc_files_suffixes_1 = qc_files_suffixes; _i < qc_files_suffixes_1.length; _i++) {\n        var qc_suffix = qc_files_suffixes_1[_i];\n        mv_qc_files_script += \"  \\\"\".concat(qc_suffix, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* QC Array complete */\n    /* Create the array of qc names */\n    mv_qc_files_script += \"QC_COVERAGE_NAMES=( \\\\\\n\";\n    for (var _a = 0, qc_file_names_1 = qc_file_names; _a < qc_file_names_1.length; _a++) {\n        var qc_coverage_name = qc_file_names_1[_a];\n        mv_qc_files_script += \"  \\\"\".concat(qc_coverage_name, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* Now iterate through each qc name and suffix to move the files */\n    mv_qc_files_script += \"# Move the QC files to the output directory\\n\";\n    mv_qc_files_script += \"for qc_name_idx in \\\"${!QC_COVERAGE_NAMES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"  qc_name=\\\"${QC_COVERAGE_NAMES[$qc_name_idx]}\\\"\\n\";\n    mv_qc_files_script += \"  for qc_suffix in \\\"${QC_SUFFIXES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"    if [[ -f \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" ]]; then\\n\");\n    mv_qc_files_script += \"      mv \\\\\\n\";\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" \\\\\\n\");\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-${qc_name}_${qc_suffix}\\\"\\n\");\n    mv_qc_files_script += \"    fi\\n\";\n    mv_qc_files_script += \"  done\\n\";\n    mv_qc_files_script += \"done\\n\\n\";\n    mv_qc_files_script += \"# Log completion\\n\";\n    mv_qc_files_script += \"echo \\\"Finish Moving QC files\\\" 1>&2\\n\";\n    return {\n        class:\"File\",\n        basename:\"mv_qc_files.sh\",\n        contents:mv_qc_files_script\n    };\n}\nfunction dragen_merge_options(options_list) {\n    /*\n    Merge a list of objects, ignoring null or undefined values\n    Options are merged in the order they are provided\n    So if there are duplicate keys, the last one will be used\n    */\n    var merged_options = {};\n    for (var _i = 0, options_list_1 = options_list; _i < options_list_1.length; _i++) {\n        var options_object = options_list_1[_i];\n        if (options_object === null || options_object === undefined) {\n            continue;\n        }\n        for (var key in options_object) {\n            /*\n             Check if the key is null or undefined.\n            */\n            if (options_object[key] === undefined) {\n                continue;\n            }\n            /*\n              If the merged key does NOT exist in the merged options but the value is null we add it in\n            */\n            if ((!merged_options.hasOwnProperty(key)) && options_object[key] === null) {\n                merged_options[key] = null;\n                continue;\n            }\n            /*\n              If the merged key DOES exist in the merged options but the value is null we skip it\n            */\n            if (merged_options.hasOwnProperty(key) && options_object[key] === null) {\n                continue;\n            }\n            /*\n              If the key already exists in merged options, check if the\n              merged_options key is a dictionary, if so we need to recursively merge instead\n            */\n            if (merged_options.hasOwnProperty(key) &&\n                typeof merged_options[key] === 'object' &&\n                (merged_options[key] !== null) &&\n                !Array.isArray(merged_options[key])) {\n                /*\n                  Check the item key is also an object\n                */\n                if (typeof options_object[key] === 'object' && !Array.isArray(options_object[key])) {\n                    /*\n                      If the key is an object, we merge the two objects\n                      This is useful for options that have sub-options\n                      However we dont to override values in merged_options that are already set\n                      if the value in the options object is null,\n                      we can solve this by calling the dragen_merge_options function recursively\n                    */\n                    merged_options[key] = dragen_merge_options([\n                        merged_options[key],\n                        options_object[key]\n                    ]);\n                }\n                /*\n                  Otherwise we just override it.\n                */\n                else {\n                    merged_options[key] = options_object[key];\n                }\n                continue;\n            }\n            /*\n            Just a standard option.\n            */\n            if (options_object.hasOwnProperty(key)) {\n                merged_options[key] = options_object[key];\n            }\n        }\n    }\n    return merged_options;\n}\nfunction get_dragen_wgts_dna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name ? props.sample_name :\"\", \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction get_dragen_wgts_rna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name, \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_rna_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Set enable rna to true */\n        enable_rna:true,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction filter_object_by_keys(object1, object2) {\n    /**\n     * Return object 1 with only the keys that are in object 2\n     */\n    var filtered_object = {};\n    /* Dont need to filter if object1 is null or undefined */\n    if (object1 === null || object1 === undefined) {\n        return object2;\n    }\n    /* Iterate through object1 and check if the key is in object2 */\n    for (var key in object1) {\n        if (object2.hasOwnProperty(key)) {\n            filtered_object[key] = object1[key];\n        }\n    }\n    return filtered_object;\n}\nfunction get_dragen_wgts_dna_variant_calling_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /*\n        Naming things\n        */\n        sample_name:props.sample_name,\n        tumor_sample_name:props.tumor_sample_name,\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        tumor_sequence_data:props.tumor_sequence_data,\n        ref_tar:props.reference.tarball,\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:(props.tumor_sample_name ? props.tumor_sample_name :props.sample_name),\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:((props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") +\n            props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__\" +\n            \"dragen_wgts_dna_\" + (props.tumor_sample_name ? \"somatic\" :\"germline\") + \"_variant_calling\"),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        /* SNV caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        /* CNV caller options */\n        cnv_caller_options:props.cnv_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* SV caller options */\n        sv_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.sv_caller_options),\n            props.sv_caller_options,\n        ]),\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n        /* Targeted Caller options */\n        targeted_caller_options:props.targeted_caller_options,\n        /* Mrjd Options */\n        mrjd_options:props.mrjd_options,\n        /* TMB Options */\n        tmb_options:props.tmb_options,\n        /* MSI Options */\n        msi_options:props.msi_options,\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n    };\n}\nfunction get_dragen_wgts_rna_variant_calling_stage_options_from_pipeline(props) {\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Annotation file, used for a lot of the variant calling options */\n        annotation_file:props.annotation_file,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:props.sample_name,\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:(props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__dragen_wgts_rna_variant_calling\"),\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        gene_expression_quantification_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.gene_expression_quantification_options),\n            props.gene_expression_quantification_options,\n        ]),\n        gene_fusion_detection_options:props.gene_fusion_detection_options,\n        splice_variant_caller_options:props.splice_variant_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n    };\n}\n/**\n * Multiqc functions\n *\n */\nfunction get_wgts_dna_multiqc_output_filename(props) {\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc_report.html\";\n}\nfunction get_wgts_rna_multiqc_output_filename(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc_report.html\";\n}\nfunction get_wgts_dna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc\";\n}\nfunction get_wgts_rna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc\";\n}\nfunction get_wgts_dna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS DNA Pipeline ( \" +\n        (props.tumor_sample_name ? props.tumor_sample_name + \"/\" :\"\") +\n        props.sample_name + \" )\");\n}\nfunction get_wgts_rna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS RNA Pipeline ( \" +\n        props.sample_name +\n        \" )\");\n}\nfunction pick_first_non_null(object_list) {\n    for (var _i = 0, object_list_1 = object_list; _i < object_list_1.length; _i++) {\n        var object = object_list_1[_i];\n        if (object) {\n            return object;\n        }\n    }\n}\nfunction pick_all_non_null(object_list) {\n    var non_null_objects = [];\n    for (var _i = 0, object_list_2 = object_list; _i < object_list_2.length; _i++) {\n        var object = object_list_2[_i];\n        if (object) {\n            non_null_objects.push(object);\n        }\n    }\n    return non_null_objects;\n}\nfunction dragen_references_match(reference_list) {\n    /*\n    Determine if the two references match,\n    If one the references is null or undefined then still return true\n    Since we really just want to know if we have two different references\n    */\n    if (reference_list.length !== 2) {\n        throw new Error(\"dragen_references_match:reference_list must be of length 2\");\n    }\n    /* Check if either of the references are null or undefined */\n    if (!reference_list[0] || !reference_list[1]) {\n        return true;\n    }\n    return reference_list[0].tarball.location == reference_list[1].tarball.location;\n}\n/* Utility functions */\nfunction get_optional_attribute_from_object(input_object, attribute) {\n    /*\n    Get attribute from object, if attribute is not defined return null\n    Assume the input object is an object of key value pairs where we know the key is of type string\n    stackoverflow.com/questions/56833469/typescript-error-ts7053-element-implicitly-has-an-any-type\n    */\n    if (input_object.hasOwnProperty(attribute)) {\n        return input_object[attribute];\n    }\n    else {\n        return null;\n    }\n}\nfunction get_attribute_from_optional_input(input_object, attribute) {\n    /*\n    Get attribute from optional input -\n    If input is not defined, then return null\n    */\n    if (input_object === null || input_object === undefined) {\n        return null;\n    }\n    else {\n        return get_optional_attribute_from_object(input_object, attribute);\n    }\n}\nfunction is_not_null(input_obj) {\n    /*\n    Determine if input object is defined and is not null\n    */\n    return !(input_obj === null || input_obj === undefined);\n}\n"
          ],
          "class": "InlineJavascriptRequirement"
        },
        {
          "class": "MultipleInputFeatureRequirement"
        },
        {
          "class": "ScatterFeatureRequirement"
        },
        {
          "types": [
            {
              "$import": "#dragen-reference__1.0.0.yaml/dragen-reference"
            },
            {
              "$import": "#fastq-list-rows-input__2.0.0.yaml/fastq-list-rows-input"
            },
            {
              "$import": "#bam-input__1.0.0.yaml/bam-input"
            },
            {
              "$import": "#cram-input__1.0.0.yaml/cram-input"
            },
            {
              "$import": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options"
            },
            {
              "$import": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options"
            },
            {
              "$import": "#dragen-qc-coverage__1.0.0.yaml/dragen-qc-coverage"
            },
            {
              "$import": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options"
            }
          ],
          "class": "SchemaDefRequirement"
        },
        {
          "class": "StepInputExpressionRequirement"
        },
        {
          "class": "SubworkflowFeatureRequirement"
        }
      ],
      "inputs": [
        {
          "label": "alignment options",
          "doc": "Alignment input options\n",
          "type": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options",
          "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/alignment_options"
        }
      ],
      "steps": [
        {
          "in": [
            {
              "source": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/alignment_options",
              "valueFrom": "${\n  if (!self.aligner) {\n    return {};\n  } else {\n    return self.aligner;\n  }\n}\n",
              "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_aligner_options_step/aligner_options"
            }
          ],
          "out": [
            {
              "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_aligner_options_step/aligner_options_output"
            }
          ],
          "run": "#dragen-create-aligner-options-object__4.4.0.cwl",
          "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_aligner_options_step"
        },
        {
          "in": [
            {
              "source": [
                "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/alignment_options",
                "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_mapper_options_step/mapper_options_output",
                "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_aligner_options_step/aligner_options_output"
              ],
              "valueFrom": "${\n  /*\n    self[0] - alignment_options\n    self[1] - mapper_options\n    self[2] - aligner_options\n  */\n  /* check alignment options are empty */\n  if (!self[0]) {\n    return {\n      \"mapper\": self[1],\n      \"aligner\": self[2]\n    }\n  }\n  /* alignment options are non empty */\n  else {\n    /* check mapper options are empty */\n    if (!self[0].mapper){\n      var mapper = self[1];\n    } else {\n      var mapper = self[0].mapper;\n    }\n    /* check aligner options are empty */\n    if (!self[0].aligner){\n      var aligner = self[2];\n    } else {\n      var aligner = self[0].aligner;\n    }\n    /* Merge object */\n    return dragen_merge_options([\n      self[0],\n      {\n        \"mapper\": mapper,\n        \"aligner\": aligner\n      }\n    ]);\n  }\n}\n",
              "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_alignment_options/dragen_wgts_alignment_options"
            }
          ],
          "out": [
            {
              "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_alignment_options/dragen_wgts_alignment_options_output"
            }
          ],
          "run": "#dragen-wgts-parse-alignment-schema__4.4.0.cwl",
          "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_alignment_options"
        },
        {
          "in": [
            {
              "source": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/alignment_options",
              "valueFrom": "${\n  if (!self.mapper) {\n    return {};\n  } else {\n    return self.mapper;\n  }\n}\n",
              "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_mapper_options_step/mapper_options"
            }
          ],
          "out": [
            {
              "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_mapper_options_step/mapper_options_output"
            }
          ],
          "run": "#dragen-create-mapper-options-object__4.4.0.cwl",
          "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_mapper_options_step"
        }
      ],
      "outputs": [
        {
          "label": "alignment options output",
          "doc": "Output file, of varying format depending on the command run\n",
          "outputSource": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/coerce_alignment_options/dragen_wgts_alignment_options_output",
          "type": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options",
          "id": "#dragen-create-wgts-alignment-options-object__4.4.0.cwl/dragen-create-wgts-alignment-options-object--4.4.0/alignment_options_output"
        }
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "Workflow",
      "id": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl",
      "label": "dragen-create-wgts-dna-variant-calling-options-object v(4.4.0)",
      "doc": "Documentation for dragen-create-wgts-dna-variant-calling-options-object\nv4.4.0\n",
      "requirements": [
        {
          "expressionLib": [
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Globals */\n/*\nList of options that are booleans but where the values are expressed as a number\n*/\nvar DragenNumericBooleanType = [\n    \"global\",\n    \"all\"\n];\nvar DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH = '/opt/instance-identity';\n/*  Functions */\nfunction get_scratch_mount() {\n    /*\n    Return the path of the scratch directory space\n    */\n    return \"/scratch/\";\n}\nfunction get_intermediate_results_dir() {\n    /*\n    Get intermediate results directory as /scratch for dragen runs\n    */\n    return get_scratch_mount() + \"intermediate-results/\";\n}\nfunction get_name_root_from_tarball(basename) {\n    var tar_ball_regex = /(\\S+)\\.tar(?:\\.gz)?/g;\n    var tar_ball_expression = tar_ball_regex.exec(basename);\n    if (tar_ball_expression === null) {\n        throw new Error(\"Could not get nameroot from \".concat(basename));\n    }\n    return tar_ball_expression[1];\n}\nfunction get_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_ref_mount() {\n    /*\n    Get the reference mount point\n    */\n    return get_scratch_mount() + \"ref/\";\n}\nfunction get_ora_ref_mount() {\n    /*\n    Get the ORA reference mount point\n    */\n    return get_scratch_mount() + \"ora-reference/\";\n}\nfunction get_ora_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ora_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_nirvana_ref_mount() {\n    /*\n    Get the Nirvana reference mount point\n    */\n    return get_scratch_mount() + \"nirvana-reference/\";\n}\nfunction get_nirvana_ref_path(reference_input_obj) {\n    return get_nirvana_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_variant_annotation_data_mount(nirvana_annotation_options) {\n    if (!nirvana_annotation_options) {\n        return null;\n    }\n    if (!nirvana_annotation_options.variant_annotation_data) {\n        return null;\n    }\n    return get_attribute_from_optional_input(nirvana_annotation_options.variant_annotation_data, \"path\");\n}\nfunction get_dragen_bin_path() {\n    /*\n    Get dragen bin path\n    */\n    return \"/opt/edico/bin/dragen\";\n}\nfunction get_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"fastq_list.csv\";\n}\nfunction get_tumor_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"tumor_fastq_list.csv\";\n}\nfunction capitalizeFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction json_to_toml(json_data) {\n    /*  Convert JSON to TOML format */\n    /*  Much easier than the other way around */\n    /*  Initialize an empty string to store the TOML data */\n    var toml_data = '';\n    var global_keys_list = [];\n    /*  Iterate through each key in the JSON object to first find the 'global' keys */\n    for (var key in json_data) {\n        var value = json_data[key];\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            continue;\n        }\n        global_keys_list.push(key);\n    }\n    var _loop_1 = function (key) {\n        var value = json_data[key];\n        if (value === null) {\n            return \"continue\";\n        }\n        /*  If the value is an array, we need to make an entry for each item in the array */\n        else if (Array.isArray(value)) {\n            value.forEach(function (item) {\n                toml_data += \"\".concat(key, \" = \").concat(item, \"\\n\");\n            });\n        }\n        else {\n            /*  Regular append */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    };\n    /*  Add global keys to the TOML data first */\n    for (var _i = 0, global_keys_list_1 = global_keys_list; _i < global_keys_list_1.length; _i++) {\n        var key = global_keys_list_1[_i];\n        _loop_1(key);\n    }\n    /*  Iterate through each key in the JSON object */\n    for (var key in json_data) {\n        var value = json_data[key];\n        /*  Skip global keys */\n        if (global_keys_list.indexOf(key) !== -1) {\n            continue;\n        }\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"File\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is a directory, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"Directory\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is an object, treat it as a section */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            /*  Section header should have a capitalized first letter */\n            toml_data += \"[\".concat(capitalizeFirstLetter(key), \"]\\n\");\n            for (var sub_key in value) {\n                toml_data += \"\".concat(sub_key, \" = \").concat(value[sub_key], \"\\n\");\n            }\n        }\n        /*  If the value is a string, treat it as a key-value pair */\n        else {\n            /*  Otherwise, treat it as a key-value pair */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    }\n    /*  Return the TOML data */\n    return toml_data;\n}\n/* Convert TOML to JSON format */\nfunction toml_to_json(toml_str) {\n    /*\n    Convert TOML to JSON format.\n    This implementation uses a simple TOML parser for basic key-value pairs and sections.\n    For production use, consider using a library like `@iarna/toml` or `toml`.\n    */\n    var result = {};\n    var currentSection = null;\n    var lines = toml_str.split(/\\r?\\n/);\n    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n        var line = lines_1[_i];\n        line = line.trim();\n        if (!line || line.startsWith(\"#\"))\n            continue;\n        /*  Section header */\n        var sectionMatch = line.match(/^\\[(.+)\\]$/);\n        if (sectionMatch) {\n            /*  Make section lowercase */\n            currentSection = sectionMatch[1].toLowerCase().trim();\n            if (!result[currentSection]) {\n                result[currentSection] = {};\n            }\n            continue;\n        }\n        /*  Key-value pair */\n        var kvMatch = line.match(/^([^=]+)=(.*)$/);\n        if (kvMatch) {\n            var key = kvMatch[1].trim();\n            var value = kvMatch[2].trim();\n            /*  Check if value is empty */\n            if ((value === \"\")) {\n                value = null;\n            }\n            /*  Remove quotes if present */\n            else if ((value.startsWith('\"') && value.endsWith('\"')) ||\n                (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n                value = value.slice(1, -1);\n            }\n            else if (value === \"true\" || value === \"false\") {\n                value = value === \"true\";\n            }\n            else if (!isNaN(Number(value))) {\n                value = Number(value);\n            }\n            /* Set the key name by replacing hyphens with underscores */\n            key = key.replace(/-/g, '_');\n            /* Replace hyphens with underscores in the key */\n            if (currentSection) {\n                /* Check if the key exists in the current section */\n                if (result[currentSection].hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[currentSection][key])) {\n                        /* Push the entry */\n                        result[currentSection][key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[currentSection][key] !== undefined) {\n                            result[currentSection][key] = [result[currentSection][key], value];\n                        }\n                        else {\n                            result[currentSection][key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[currentSection][key] = value;\n                }\n            }\n            else {\n                /* Check if the key exists */\n                if (result.hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[key])) {\n                        /* Push the entry */\n                        result[key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[key] !== undefined) {\n                            result[key] = [result[key], value];\n                        }\n                        else {\n                            result[key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[key] = value;\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction build_fastq_list_csv_header(header_names) {\n    /*\n    Convert lowercase labels to uppercase values\n    i.e\n    [ \"rgid\", \"rglb\", \"rgsm\", \"lane\", \"read_1\", \"read_2\" ]\n    to\n    \"RGID,RGLB,RGSM,Lane,Read1File,Read2File\"\n    */\n    var modified_header_names = [];\n    for (var _i = 0, header_names_1 = header_names; _i < header_names_1.length; _i++) {\n        var header_name = header_names_1[_i];\n        if (header_name.indexOf(\"rg\") === 0) {\n            /*\n            rgid -> RGID\n            */\n            modified_header_names.push(header_name.toUpperCase());\n        }\n        else if (header_name.indexOf(\"read\") === 0) {\n            /*\n            read_1 -> Read1File\n            */\n            modified_header_names.push(\"Read\" + header_name.charAt(header_name.length - 1) + \"File\");\n        }\n        else {\n            /*\n            lane to Lane\n            */\n            modified_header_names.push(header_name[0].toUpperCase() + header_name.substr(1));\n        }\n    }\n    /*\n    Convert array to comma separated strings\n    */\n    return modified_header_names.join(\",\") + \"\\n\";\n}\nfunction get_fastq_list_row_as_csv_row(fastq_list_row, row_order) {\n    var fastq_list_row_values_array = [];\n    /*  This for loop is here to ensure were assigning values in the same order as the header */\n    for (var _i = 0, row_order_1 = row_order; _i < row_order_1.length; _i++) {\n        var item_index = row_order_1[_i];\n        var found_item = false;\n        /*  Find matching attribute in this row */\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            var fastq_list_row_field_value = fastq_list_row[fastq_list_row_field_name];\n            if (fastq_list_row_field_value === null) {\n                /*\n                Item not found, add an empty attribute for this cell in the csv\n                */\n                continue;\n            }\n            /*  The header value matches the name in the item */\n            if (fastq_list_row_field_name === item_index) {\n                /*\n                If the field value has a class attribute then it's either read_1 or read_2\n                */\n                if (fastq_list_row_field_value.hasOwnProperty(\"class\")) {\n                    var fastq_list_row_field_value_file = fastq_list_row_field_value;\n                    /*\n                    Assert that this is actually of class file\n                    */\n                    if (fastq_list_row_field_value_file.class !== \"File\") {\n                        continue;\n                    }\n                    /*  Read 1 and 2 files are mounted as rgid/filename */\n                    fastq_list_row_values_array.push(fastq_list_row.rgid + '/' + fastq_list_row_field_value_file.basename);\n                }\n                else {\n                    /*\n                    Push the string attribute to the fastq list csv row\n                    Replace any commas in the string with ' -'\n                    */\n                    fastq_list_row_values_array.push(fastq_list_row_field_value.toString().replace(/,/g, \" -\"));\n                }\n                found_item = true;\n                break;\n            }\n        }\n        if (!found_item) {\n            /*\n            Push blank cell if no item found\n            */\n            fastq_list_row_values_array.push(\"\");\n        }\n    }\n    /*\n    Convert to string and return as string\n    */\n    return fastq_list_row_values_array.join(\",\") + \"\\n\";\n}\nfunction generate_fastq_list_csv(fastq_list_rows) {\n    /*\n    Fastq list rows generation\n    */\n    var fastq_csv_file = {\n        class:\"File\",\n        basename:get_fastq_list_csv_path()\n    };\n    /*\n    Set the row order\n    */\n    var row_order = [];\n    /*\n    Set the array order\n    Make sure we iterate through all rows of the array\n    */\n    for (var _i = 0, fastq_list_rows_1 = fastq_list_rows; _i < fastq_list_rows_1.length; _i++) {\n        var fastq_list_row = fastq_list_rows_1[_i];\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            if (row_order.indexOf(fastq_list_row_field_name) === -1) {\n                row_order.push(fastq_list_row_field_name);\n            }\n        }\n    }\n    /*\n    Make header\n    */\n    fastq_csv_file.contents = build_fastq_list_csv_header(row_order);\n    /*\n    For each fastq list row,\n    collect the values of each attribute but in the order of the header\n    */\n    for (var _c = 0, fastq_list_rows_2 = fastq_list_rows; _c < fastq_list_rows_2.length; _c++) {\n        var fastq_list_row = fastq_list_rows_2[_c];\n        /*  Add csv row to file contents */\n        fastq_csv_file.contents += get_fastq_list_row_as_csv_row(fastq_list_row, row_order);\n    }\n    return fastq_csv_file;\n}\nfunction get_value_for_config(valueObj) {\n    /* If valueObj is an IFile, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"File\") {\n        return valueObj.path;\n    }\n    /* If valueObj is an IDirectory, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"Directory\") {\n        return valueObj.path;\n    }\n    /* Recursively call this function for nested objects */\n    if (typeof valueObj === 'object' && !Array.isArray(valueObj)) {\n        var newValueObj = {};\n        for (var key in valueObj) {\n            if (valueObj[key] === null || valueObj[key] === undefined) {\n                continue;\n            }\n            /* Special case - boolean to numeric */\n            if (key in DragenNumericBooleanType) {\n                newValueObj[key.replace(/_/g, \"-\")] = valueObj[key] ? 1 :0;\n                continue;\n            }\n            newValueObj[key.replace(/_/g, \"-\")] = get_value_for_config(valueObj[key]);\n        }\n        return newValueObj;\n    }\n    /* Consider arrays */\n    if (Array.isArray(valueObj)) {\n        return valueObj.map(function (item) { return get_value_for_config(item); });\n    }\n    /* Otherwise return the value as is */\n    return valueObj;\n}\nfunction get_dragen_config_path() {\n    return \"dragen_config.toml\";\n}\nfunction dragen_to_config_toml(props) {\n    /* Part 1 - Generate the json blob */\n    var json_blob = {};\n    for (var key in props) {\n        /* Get props key value */\n        var value = props[key];\n        /* Skip null props */\n        if (value === null || value === undefined) {\n            continue;\n        }\n        /*  FIXME denovo to DeNovo */\n        /* Special cases */\n        /* 1. Fastq list rows we rename to 'fastq-list',\n            alignment data mounted at the base of the working directory\n        */\n        /* Sequence data */\n        if (key === \"fastq_list_rows\") {\n            json_blob[\"fastq-list\"] = get_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"bam_input\") {\n            json_blob[\"bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_input\") {\n            json_blob[\"cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_reference\") {\n            json_blob[\"cram-reference\"] = value.basename;\n            continue;\n        }\n        /* Tumor sequence data */\n        if (key === \"tumor_fastq_list_rows\") {\n            json_blob['tumor-fastq-list'] = get_tumor_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"tumor_bam_input\") {\n            json_blob[\"tumor-bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_input\") {\n            json_blob[\"tumor-cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_reference\") {\n            json_blob[\"tumor-cram-reference\"] = value.basename;\n            continue;\n        }\n        /* 2. If ref-tar is parsed through, we use ref-dir instead */\n        if (key === \"ref_tar\") {\n            json_blob['ref-dir'] = get_ref_mount() + value.basename.replace(/\\.tar\\.gz$/, \"\");\n            /*\n                If the ref_tar does not contain 'graph',\n                then we also need to add the parameter,\n                --validate-pangenome-reference=false,\n                this was in place when we wanted to align genome to linear somatic reference\n                however, we are no longer doing that so this parameter is not needed\n            */\n            if (!value.basename.includes(\"graph\")) {\n                json_blob['validate-pangenome-reference'] = false;\n            }\n            continue;\n        }\n        /* If the ora reference is parsed through, we also place the ora reference into the scratch space */\n        if (key === \"ora_reference\") {\n            /* Mounted at scratch mount, strip the .tar.gz from the basename */\n            json_blob['ora-reference'] = get_ora_ref_path(value);\n            continue;\n        }\n        /* If the nirvana reference is parsed through, we also place the nirvana reference into the scratch space */\n        if (key === \"variant_annotation_data\") {\n            /* Mounted at the scratch mount, strip the .tar.gz from the basename */\n            json_blob['variant-annotation-data'] = get_nirvana_ref_path(value);\n            continue;\n        }\n        /* 3. Check if key is in the boolean to numeric list */\n        if (key in DragenNumericBooleanType) {\n            json_blob[key.replace(/_/g, \"-\")] = value ? 1 :0;\n            continue;\n        }\n        /* 4. Check if key is a qc coverage object */\n        if (key === \"qc_coverage\") {\n            /*\n            We need to iterate through the qc coverage objects\n            and add them to the json blob\n            */\n            value.forEach(function (qcObject, index) {\n                json_blob[\"qc-coverage-region-\".concat(index + 1)] = qcObject.region.path;\n                json_blob[\"qc-coverage-reports-\".concat(index + 1)] = qcObject.report_type;\n                if (qcObject.thresholds !== null && qcObject.thresholds !== undefined) {\n                    json_blob[\"qc-coverage-region-\".concat(index + 1, \"-thresholds\")] = qcObject.thresholds.map(function (threshold) { return threshold.toString(); }).join(\",\");\n                }\n            });\n            continue;\n        }\n        /* 5. Get value for standard options */\n        if (props.hasOwnProperty(key)) {\n            /*  We replace snake case with hyphen */\n            json_blob[key.replace(/_/g, \"-\")] = get_value_for_config(value);\n        }\n    }\n    /* Part 2 - Convert the json blob to toml */\n    return json_to_toml(json_blob);\n}\nfunction generate_sequence_data_mount_points(sequence_data, tumor_sequence_data) {\n    /*\n    Create and add in the fastq list csv for the input fastqs\n    If the input is bam or cram, we also mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the sequence data */\n    if (\"fastq_list_rows\" in sequence_data && sequence_data.fastq_list_rows !== undefined) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _i = 0, _a = sequence_data.fastq_list_rows; _i < _a.length; _i++) {\n            var fastq_list_row = _a[_i];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in sequence_data && sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.bam_input.secondaryFiles) {\n            sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in sequence_data && sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.cram_input.secondaryFiles) {\n            sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (sequence_data.cram_reference.secondaryFiles) {\n                sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Can exist here if germline-only */\n    if (!tumor_sequence_data) {\n        /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n        return e;\n    }\n    /*  Add the tumor sequence data */\n    if (\"fastq_list_rows\" in tumor_sequence_data && tumor_sequence_data.fastq_list_rows !== undefined) {\n        /* Upload the csv */\n        e.push({\n            \"entryname\":get_tumor_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(tumor_sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _b = 0, _c = tumor_sequence_data.fastq_list_rows; _b < _c.length; _b++) {\n            var fastq_list_row = _c[_b];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in tumor_sequence_data && tumor_sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.bam_input.secondaryFiles) {\n            tumor_sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in tumor_sequence_data && tumor_sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.cram_input.secondaryFiles) {\n            tumor_sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (tumor_sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":tumor_sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_sequence_data.cram_reference.secondaryFiles) {\n                tumor_sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_alignment_data_mount_points(alignment_data, tumor_alignment_data) {\n    /*\n    If the input is bam or cram, we mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the alignment data data */\n    if (\"bam_input\" in alignment_data && alignment_data.bam_input !== undefined) {\n        /* Add in the bam file */\n        e.push({\n            \"entryname\":alignment_data.bam_input.basename,\n            /* Due to the secondary files, we need to manually add in each file object */\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.bam_input.secondaryFiles) {\n            alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in alignment_data && alignment_data.cram_input !== undefined) {\n        /* Add in the cram file */\n        e.push({\n            \"entryname\":alignment_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.cram_input.secondaryFiles) {\n            alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (alignment_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":alignment_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":alignment_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (alignment_data.cram_reference.secondaryFiles) {\n                alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Now repeat for tumor alignment data */\n    if (tumor_alignment_data) {\n        /*  Add the alignment data data */\n        if (\"bam_input\" in tumor_alignment_data && tumor_alignment_data.bam_input !== undefined) {\n            /* Add in the bam file */\n            e.push({\n                \"entryname\":tumor_alignment_data.bam_input.basename,\n                /* Due to the secondary files, we need to manually add in each file object */\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.bam_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.bam_input.secondaryFiles) {\n                tumor_alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n        else if (\"cram_input\" in tumor_alignment_data && tumor_alignment_data.cram_input !== undefined) {\n            /* Add in the cram file */\n            e.push({\n                \"entryname\":tumor_alignment_data.cram_input.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.cram_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.cram_input.secondaryFiles) {\n                tumor_alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n            /*  We also add in the reference file if its provided */\n            if (tumor_alignment_data.cram_reference !== undefined) {\n                e.push({\n                    \"entryname\":tumor_alignment_data.cram_reference.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":tumor_alignment_data.cram_reference.location\n                    }\n                });\n                /* Then add in each secondary file object */\n                if (tumor_alignment_data.cram_reference.secondaryFiles) {\n                    tumor_alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                        e.push({\n                            \"entryname\":secondary_file_iter_.basename,\n                            \"entry\":{\n                                \"class\":\"File\",\n                                \"location\":secondary_file_iter_.location\n                            }\n                        });\n                    });\n                }\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_mv_qc_files_script_mount_points(options_list) {\n    /*\n     If alignment_options.qc_coverage is defined, we generate a script to move the qc files to their name attribute\n    */\n    var qc_files_script = generate_mv_qc_files_script(options_list);\n    if (!qc_files_script) {\n        return [];\n    }\n    else {\n        return [\n            {\n                entryname:qc_files_script.basename,\n                /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n                entry:qc_files_script\n            }\n        ];\n    }\n}\nfunction strip_uri_from_name(name_with_uri) {\n    /*\n    Given a string as a uri, return all after the trailing hash\n     */\n    return name_with_uri.split('#').pop() || name_with_uri;\n}\nfunction generate_mv_qc_files_script(options_list) {\n    /*\n    Generate mv qc files script\n     */\n    /* Check if alignment_options.qc_coverage is defined */\n    if (!options_list.alignment_options.qc_coverage || options_list.alignment_options.qc_coverage.length === 0) {\n        return null;\n    }\n    /* Initialise vars */\n    var output_file_prefix = options_list.output_file_prefix;\n    var output_directory = options_list.output_directory;\n    /* Initialise the script */\n    var mv_qc_files_script = \"#!/usr/bin/env bash\\n\\n\";\n    mv_qc_files_script += \"# Exit on failure\\n\";\n    mv_qc_files_script += \"set -euo pipefail\\n\\n\";\n    mv_qc_files_script += \"# Log start\\n\";\n    mv_qc_files_script += \"echo \\\"Start Moving QC files\\\" 1>&2\\n\\n\";\n    /* Arrays to make */\n    var qc_files_suffixes = [\n        /* Germline */\n        \"contig_mean_cov.csv\",\n        \"cov_report.bed\",\n        \"coverage_metrics.csv\",\n        \"fine_hist.csv\",\n        \"hist.csv\",\n        \"overall_mean_cov.csv\",\n        \"read_cov_report.bed\",\n        /* Somatic */\n        \"contig_mean_cov_normal.csv\",\n        \"contig_mean_cov_tumor.csv\",\n        \"cov_report_normal.bed\",\n        \"cov_report_tumor.bed\",\n        \"coverage_metrics_normal.csv\",\n        \"coverage_metrics_tumor.csv\",\n        \"fine_hist_normal.csv\",\n        \"fine_hist_tumor.csv\",\n        \"hist_normal.csv\",\n        \"hist_tumor.csv\",\n        \"overall_mean_cov_normal.csv\",\n        \"overall_mean_cov_tumor.csv\",\n        \"read_cov_report_normal.bed\",\n        \"read_cov_report_tumor.bed\",\n        \"somatic_callable_regions.bed\",\n    ];\n    var qc_file_names = options_list.alignment_options.qc_coverage.map(function (qc_coverage) { return strip_uri_from_name(qc_coverage.name); });\n    /* Create the qc suffixes array */\n    mv_qc_files_script += \"# Initialise coverage arrays \\n\";\n    mv_qc_files_script += \"QC_SUFFIXES=( \\\\\\n\";\n    for (var _i = 0, qc_files_suffixes_1 = qc_files_suffixes; _i < qc_files_suffixes_1.length; _i++) {\n        var qc_suffix = qc_files_suffixes_1[_i];\n        mv_qc_files_script += \"  \\\"\".concat(qc_suffix, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* QC Array complete */\n    /* Create the array of qc names */\n    mv_qc_files_script += \"QC_COVERAGE_NAMES=( \\\\\\n\";\n    for (var _a = 0, qc_file_names_1 = qc_file_names; _a < qc_file_names_1.length; _a++) {\n        var qc_coverage_name = qc_file_names_1[_a];\n        mv_qc_files_script += \"  \\\"\".concat(qc_coverage_name, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* Now iterate through each qc name and suffix to move the files */\n    mv_qc_files_script += \"# Move the QC files to the output directory\\n\";\n    mv_qc_files_script += \"for qc_name_idx in \\\"${!QC_COVERAGE_NAMES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"  qc_name=\\\"${QC_COVERAGE_NAMES[$qc_name_idx]}\\\"\\n\";\n    mv_qc_files_script += \"  for qc_suffix in \\\"${QC_SUFFIXES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"    if [[ -f \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" ]]; then\\n\");\n    mv_qc_files_script += \"      mv \\\\\\n\";\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" \\\\\\n\");\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-${qc_name}_${qc_suffix}\\\"\\n\");\n    mv_qc_files_script += \"    fi\\n\";\n    mv_qc_files_script += \"  done\\n\";\n    mv_qc_files_script += \"done\\n\\n\";\n    mv_qc_files_script += \"# Log completion\\n\";\n    mv_qc_files_script += \"echo \\\"Finish Moving QC files\\\" 1>&2\\n\";\n    return {\n        class:\"File\",\n        basename:\"mv_qc_files.sh\",\n        contents:mv_qc_files_script\n    };\n}\nfunction dragen_merge_options(options_list) {\n    /*\n    Merge a list of objects, ignoring null or undefined values\n    Options are merged in the order they are provided\n    So if there are duplicate keys, the last one will be used\n    */\n    var merged_options = {};\n    for (var _i = 0, options_list_1 = options_list; _i < options_list_1.length; _i++) {\n        var options_object = options_list_1[_i];\n        if (options_object === null || options_object === undefined) {\n            continue;\n        }\n        for (var key in options_object) {\n            /*\n             Check if the key is null or undefined.\n            */\n            if (options_object[key] === undefined) {\n                continue;\n            }\n            /*\n              If the merged key does NOT exist in the merged options but the value is null we add it in\n            */\n            if ((!merged_options.hasOwnProperty(key)) && options_object[key] === null) {\n                merged_options[key] = null;\n                continue;\n            }\n            /*\n              If the merged key DOES exist in the merged options but the value is null we skip it\n            */\n            if (merged_options.hasOwnProperty(key) && options_object[key] === null) {\n                continue;\n            }\n            /*\n              If the key already exists in merged options, check if the\n              merged_options key is a dictionary, if so we need to recursively merge instead\n            */\n            if (merged_options.hasOwnProperty(key) &&\n                typeof merged_options[key] === 'object' &&\n                (merged_options[key] !== null) &&\n                !Array.isArray(merged_options[key])) {\n                /*\n                  Check the item key is also an object\n                */\n                if (typeof options_object[key] === 'object' && !Array.isArray(options_object[key])) {\n                    /*\n                      If the key is an object, we merge the two objects\n                      This is useful for options that have sub-options\n                      However we dont to override values in merged_options that are already set\n                      if the value in the options object is null,\n                      we can solve this by calling the dragen_merge_options function recursively\n                    */\n                    merged_options[key] = dragen_merge_options([\n                        merged_options[key],\n                        options_object[key]\n                    ]);\n                }\n                /*\n                  Otherwise we just override it.\n                */\n                else {\n                    merged_options[key] = options_object[key];\n                }\n                continue;\n            }\n            /*\n            Just a standard option.\n            */\n            if (options_object.hasOwnProperty(key)) {\n                merged_options[key] = options_object[key];\n            }\n        }\n    }\n    return merged_options;\n}\nfunction get_dragen_wgts_dna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name ? props.sample_name :\"\", \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction get_dragen_wgts_rna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name, \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_rna_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Set enable rna to true */\n        enable_rna:true,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction filter_object_by_keys(object1, object2) {\n    /**\n     * Return object 1 with only the keys that are in object 2\n     */\n    var filtered_object = {};\n    /* Dont need to filter if object1 is null or undefined */\n    if (object1 === null || object1 === undefined) {\n        return object2;\n    }\n    /* Iterate through object1 and check if the key is in object2 */\n    for (var key in object1) {\n        if (object2.hasOwnProperty(key)) {\n            filtered_object[key] = object1[key];\n        }\n    }\n    return filtered_object;\n}\nfunction get_dragen_wgts_dna_variant_calling_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /*\n        Naming things\n        */\n        sample_name:props.sample_name,\n        tumor_sample_name:props.tumor_sample_name,\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        tumor_sequence_data:props.tumor_sequence_data,\n        ref_tar:props.reference.tarball,\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:(props.tumor_sample_name ? props.tumor_sample_name :props.sample_name),\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:((props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") +\n            props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__\" +\n            \"dragen_wgts_dna_\" + (props.tumor_sample_name ? \"somatic\" :\"germline\") + \"_variant_calling\"),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        /* SNV caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        /* CNV caller options */\n        cnv_caller_options:props.cnv_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* SV caller options */\n        sv_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.sv_caller_options),\n            props.sv_caller_options,\n        ]),\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n        /* Targeted Caller options */\n        targeted_caller_options:props.targeted_caller_options,\n        /* Mrjd Options */\n        mrjd_options:props.mrjd_options,\n        /* TMB Options */\n        tmb_options:props.tmb_options,\n        /* MSI Options */\n        msi_options:props.msi_options,\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n    };\n}\nfunction get_dragen_wgts_rna_variant_calling_stage_options_from_pipeline(props) {\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Annotation file, used for a lot of the variant calling options */\n        annotation_file:props.annotation_file,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:props.sample_name,\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:(props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__dragen_wgts_rna_variant_calling\"),\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        gene_expression_quantification_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.gene_expression_quantification_options),\n            props.gene_expression_quantification_options,\n        ]),\n        gene_fusion_detection_options:props.gene_fusion_detection_options,\n        splice_variant_caller_options:props.splice_variant_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n    };\n}\n/**\n * Multiqc functions\n *\n */\nfunction get_wgts_dna_multiqc_output_filename(props) {\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc_report.html\";\n}\nfunction get_wgts_rna_multiqc_output_filename(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc_report.html\";\n}\nfunction get_wgts_dna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc\";\n}\nfunction get_wgts_rna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc\";\n}\nfunction get_wgts_dna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS DNA Pipeline ( \" +\n        (props.tumor_sample_name ? props.tumor_sample_name + \"/\" :\"\") +\n        props.sample_name + \" )\");\n}\nfunction get_wgts_rna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS RNA Pipeline ( \" +\n        props.sample_name +\n        \" )\");\n}\nfunction pick_first_non_null(object_list) {\n    for (var _i = 0, object_list_1 = object_list; _i < object_list_1.length; _i++) {\n        var object = object_list_1[_i];\n        if (object) {\n            return object;\n        }\n    }\n}\nfunction pick_all_non_null(object_list) {\n    var non_null_objects = [];\n    for (var _i = 0, object_list_2 = object_list; _i < object_list_2.length; _i++) {\n        var object = object_list_2[_i];\n        if (object) {\n            non_null_objects.push(object);\n        }\n    }\n    return non_null_objects;\n}\nfunction dragen_references_match(reference_list) {\n    /*\n    Determine if the two references match,\n    If one the references is null or undefined then still return true\n    Since we really just want to know if we have two different references\n    */\n    if (reference_list.length !== 2) {\n        throw new Error(\"dragen_references_match:reference_list must be of length 2\");\n    }\n    /* Check if either of the references are null or undefined */\n    if (!reference_list[0] || !reference_list[1]) {\n        return true;\n    }\n    return reference_list[0].tarball.location == reference_list[1].tarball.location;\n}\n/* Utility functions */\nfunction get_optional_attribute_from_object(input_object, attribute) {\n    /*\n    Get attribute from object, if attribute is not defined return null\n    Assume the input object is an object of key value pairs where we know the key is of type string\n    stackoverflow.com/questions/56833469/typescript-error-ts7053-element-implicitly-has-an-any-type\n    */\n    if (input_object.hasOwnProperty(attribute)) {\n        return input_object[attribute];\n    }\n    else {\n        return null;\n    }\n}\nfunction get_attribute_from_optional_input(input_object, attribute) {\n    /*\n    Get attribute from optional input -\n    If input is not defined, then return null\n    */\n    if (input_object === null || input_object === undefined) {\n        return null;\n    }\n    else {\n        return get_optional_attribute_from_object(input_object, attribute);\n    }\n}\nfunction is_not_null(input_obj) {\n    /*\n    Determine if input object is defined and is not null\n    */\n    return !(input_obj === null || input_obj === undefined);\n}\n"
          ],
          "class": "InlineJavascriptRequirement"
        },
        {
          "class": "MultipleInputFeatureRequirement"
        },
        {
          "class": "ScatterFeatureRequirement"
        },
        {
          "types": [
            {
              "$import": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options"
            },
            {
              "$import": "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options"
            }
          ],
          "class": "SchemaDefRequirement"
        },
        {
          "class": "StepInputExpressionRequirement"
        },
        {
          "class": "SubworkflowFeatureRequirement"
        }
      ],
      "inputs": [
        {
          "label": "dragen-cnv-caller-options",
          "doc": "dragen-cnv-caller-options\n",
          "type": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options",
          "id": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/snv_variant_caller_options"
        },
        {
          "label": "dragen-cnv-caller-options",
          "doc": "dragen-cnv-caller-options\n",
          "type": "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options",
          "id": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/sv_caller_options"
        }
      ],
      "steps": [
        {
          "in": [
            {
              "source": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/snv_variant_caller_options",
              "id": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/parse_snv_variant_caller_options/snv_variant_caller_options_input"
            }
          ],
          "out": [
            {
              "id": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/parse_snv_variant_caller_options/snv_variant_caller_options_output"
            }
          ],
          "run": "#dragen-parse-snv-variant-caller-schema__4.4.0.cwl",
          "id": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/parse_snv_variant_caller_options"
        },
        {
          "in": [
            {
              "source": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/sv_caller_options",
              "id": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/parse_sv_caller_options/sv_caller_options_input"
            }
          ],
          "out": [
            {
              "id": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/parse_sv_caller_options/sv_caller_options_output"
            }
          ],
          "run": "#dragen-parse-sv-caller-schema__4.4.0.cwl",
          "id": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/parse_sv_caller_options"
        }
      ],
      "outputs": [
        {
          "label": "snv_variant_caller_options_output",
          "doc": "snv_variant_caller_options_output\n",
          "outputSource": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/parse_snv_variant_caller_options/snv_variant_caller_options_output",
          "type": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options",
          "id": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/snv_variant_caller_options_output"
        },
        {
          "label": "sv_caller_options_output",
          "doc": "sv_caller_options_output\n",
          "outputSource": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/parse_sv_caller_options/sv_caller_options_output",
          "type": "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options",
          "id": "#dragen-create-wgts-dna-variant-calling-options-object__4.4.0.cwl/dragen-create-wgts-dna-variant-calling-options-object--4.4.0/sv_caller_options_output"
        }
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "Workflow",
      "id": "#dragen-wgts-dna-variant-calling-stage__4.4.6.cwl",
      "label": "dragen-variant-calling-stage v(4.4.6)",
      "doc": "Documentation for dragen-variant-calling-stage v4.4.6\n",
      "requirements": [
        {
          "expressionLib": [
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Globals */\n/*\nList of options that are booleans but where the values are expressed as a number\n*/\nvar DragenNumericBooleanType = [\n    \"global\",\n    \"all\"\n];\nvar DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH = '/opt/instance-identity';\n/*  Functions */\nfunction get_scratch_mount() {\n    /*\n    Return the path of the scratch directory space\n    */\n    return \"/scratch/\";\n}\nfunction get_intermediate_results_dir() {\n    /*\n    Get intermediate results directory as /scratch for dragen runs\n    */\n    return get_scratch_mount() + \"intermediate-results/\";\n}\nfunction get_name_root_from_tarball(basename) {\n    var tar_ball_regex = /(\\S+)\\.tar(?:\\.gz)?/g;\n    var tar_ball_expression = tar_ball_regex.exec(basename);\n    if (tar_ball_expression === null) {\n        throw new Error(\"Could not get nameroot from \".concat(basename));\n    }\n    return tar_ball_expression[1];\n}\nfunction get_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_ref_mount() {\n    /*\n    Get the reference mount point\n    */\n    return get_scratch_mount() + \"ref/\";\n}\nfunction get_ora_ref_mount() {\n    /*\n    Get the ORA reference mount point\n    */\n    return get_scratch_mount() + \"ora-reference/\";\n}\nfunction get_ora_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ora_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_nirvana_ref_mount() {\n    /*\n    Get the Nirvana reference mount point\n    */\n    return get_scratch_mount() + \"nirvana-reference/\";\n}\nfunction get_nirvana_ref_path(reference_input_obj) {\n    return get_nirvana_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename);\n}\nfunction get_variant_annotation_data_mount(nirvana_annotation_options) {\n    if (!nirvana_annotation_options) {\n        return null;\n    }\n    if (!nirvana_annotation_options.variant_annotation_data) {\n        return null;\n    }\n    return get_attribute_from_optional_input(nirvana_annotation_options.variant_annotation_data, \"path\");\n}\nfunction get_dragen_bin_path() {\n    /*\n    Get dragen bin path\n    */\n    return \"/opt/edico/bin/dragen\";\n}\nfunction get_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"fastq_list.csv\";\n}\nfunction get_tumor_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"tumor_fastq_list.csv\";\n}\nfunction capitalizeFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction json_to_toml(json_data) {\n    /*  Convert JSON to TOML format */\n    /*  Much easier than the other way around */\n    /*  Initialize an empty string to store the TOML data */\n    var toml_data = '';\n    var global_keys_list = [];\n    /*  Iterate through each key in the JSON object to first find the 'global' keys */\n    for (var key in json_data) {\n        var value = json_data[key];\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            continue;\n        }\n        global_keys_list.push(key);\n    }\n    var _loop_1 = function (key) {\n        var value = json_data[key];\n        if (value === null) {\n            return \"continue\";\n        }\n        /*  If the value is an array, we need to make an entry for each item in the array */\n        else if (Array.isArray(value)) {\n            value.forEach(function (item) {\n                toml_data += \"\".concat(key, \" = \").concat(item, \"\\n\");\n            });\n        }\n        else {\n            /*  Regular append */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    };\n    /*  Add global keys to the TOML data first */\n    for (var _i = 0, global_keys_list_1 = global_keys_list; _i < global_keys_list_1.length; _i++) {\n        var key = global_keys_list_1[_i];\n        _loop_1(key);\n    }\n    /*  Iterate through each key in the JSON object */\n    for (var key in json_data) {\n        var value = json_data[key];\n        /*  Skip global keys */\n        if (global_keys_list.indexOf(key) !== -1) {\n            continue;\n        }\n        if (value === null) {\n            continue;\n        }\n        /*  If the value is a file, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"File\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is a directory, return the path */\n        if (typeof value === 'object' && value.hasOwnProperty(\"class\") && value[\"class\"] === \"Directory\") {\n            toml_data += \"\".concat(key, \" = \").concat(value.path, \"\\n\");\n            continue;\n        }\n        /*  If the value is an object, treat it as a section */\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            /*  Section header should have a capitalized first letter */\n            toml_data += \"[\".concat(capitalizeFirstLetter(key), \"]\\n\");\n            for (var sub_key in value) {\n                toml_data += \"\".concat(sub_key, \" = \").concat(value[sub_key], \"\\n\");\n            }\n        }\n        /*  If the value is a string, treat it as a key-value pair */\n        else {\n            /*  Otherwise, treat it as a key-value pair */\n            toml_data += \"\".concat(key, \" = \").concat(value, \"\\n\");\n        }\n    }\n    /*  Return the TOML data */\n    return toml_data;\n}\n/* Convert TOML to JSON format */\nfunction toml_to_json(toml_str) {\n    /*\n    Convert TOML to JSON format.\n    This implementation uses a simple TOML parser for basic key-value pairs and sections.\n    For production use, consider using a library like `@iarna/toml` or `toml`.\n    */\n    var result = {};\n    var currentSection = null;\n    var lines = toml_str.split(/\\r?\\n/);\n    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n        var line = lines_1[_i];\n        line = line.trim();\n        if (!line || line.startsWith(\"#\"))\n            continue;\n        /*  Section header */\n        var sectionMatch = line.match(/^\\[(.+)\\]$/);\n        if (sectionMatch) {\n            /*  Make section lowercase */\n            currentSection = sectionMatch[1].toLowerCase().trim();\n            if (!result[currentSection]) {\n                result[currentSection] = {};\n            }\n            continue;\n        }\n        /*  Key-value pair */\n        var kvMatch = line.match(/^([^=]+)=(.*)$/);\n        if (kvMatch) {\n            var key = kvMatch[1].trim();\n            var value = kvMatch[2].trim();\n            /*  Check if value is empty */\n            if ((value === \"\")) {\n                value = null;\n            }\n            /*  Remove quotes if present */\n            else if ((value.startsWith('\"') && value.endsWith('\"')) ||\n                (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n                value = value.slice(1, -1);\n            }\n            else if (value === \"true\" || value === \"false\") {\n                value = value === \"true\";\n            }\n            else if (!isNaN(Number(value))) {\n                value = Number(value);\n            }\n            /* Set the key name by replacing hyphens with underscores */\n            key = key.replace(/-/g, '_');\n            /* Replace hyphens with underscores in the key */\n            if (currentSection) {\n                /* Check if the key exists in the current section */\n                if (result[currentSection].hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[currentSection][key])) {\n                        /* Push the entry */\n                        result[currentSection][key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[currentSection][key] !== undefined) {\n                            result[currentSection][key] = [result[currentSection][key], value];\n                        }\n                        else {\n                            result[currentSection][key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[currentSection][key] = value;\n                }\n            }\n            else {\n                /* Check if the key exists */\n                if (result.hasOwnProperty(key)) {\n                    /* Check if the existing value is an array */\n                    if (Array.isArray(result[key])) {\n                        /* Push the entry */\n                        result[key].push(value);\n                    }\n                    else {\n                        /* If the key exists but is not an array, convert it to an array */\n                        if (result[key] !== undefined) {\n                            result[key] = [result[key], value];\n                        }\n                        else {\n                            result[key] = value;\n                        }\n                    }\n                }\n                else {\n                    result[key] = value;\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction build_fastq_list_csv_header(header_names) {\n    /*\n    Convert lowercase labels to uppercase values\n    i.e\n    [ \"rgid\", \"rglb\", \"rgsm\", \"lane\", \"read_1\", \"read_2\" ]\n    to\n    \"RGID,RGLB,RGSM,Lane,Read1File,Read2File\"\n    */\n    var modified_header_names = [];\n    for (var _i = 0, header_names_1 = header_names; _i < header_names_1.length; _i++) {\n        var header_name = header_names_1[_i];\n        if (header_name.indexOf(\"rg\") === 0) {\n            /*\n            rgid -> RGID\n            */\n            modified_header_names.push(header_name.toUpperCase());\n        }\n        else if (header_name.indexOf(\"read\") === 0) {\n            /*\n            read_1 -> Read1File\n            */\n            modified_header_names.push(\"Read\" + header_name.charAt(header_name.length - 1) + \"File\");\n        }\n        else {\n            /*\n            lane to Lane\n            */\n            modified_header_names.push(header_name[0].toUpperCase() + header_name.substr(1));\n        }\n    }\n    /*\n    Convert array to comma separated strings\n    */\n    return modified_header_names.join(\",\") + \"\\n\";\n}\nfunction get_fastq_list_row_as_csv_row(fastq_list_row, row_order) {\n    var fastq_list_row_values_array = [];\n    /*  This for loop is here to ensure were assigning values in the same order as the header */\n    for (var _i = 0, row_order_1 = row_order; _i < row_order_1.length; _i++) {\n        var item_index = row_order_1[_i];\n        var found_item = false;\n        /*  Find matching attribute in this row */\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            var fastq_list_row_field_value = fastq_list_row[fastq_list_row_field_name];\n            if (fastq_list_row_field_value === null) {\n                /*\n                Item not found, add an empty attribute for this cell in the csv\n                */\n                continue;\n            }\n            /*  The header value matches the name in the item */\n            if (fastq_list_row_field_name === item_index) {\n                /*\n                If the field value has a class attribute then it's either read_1 or read_2\n                */\n                if (fastq_list_row_field_value.hasOwnProperty(\"class\")) {\n                    var fastq_list_row_field_value_file = fastq_list_row_field_value;\n                    /*\n                    Assert that this is actually of class file\n                    */\n                    if (fastq_list_row_field_value_file.class !== \"File\") {\n                        continue;\n                    }\n                    /*  Read 1 and 2 files are mounted as rgid/filename */\n                    fastq_list_row_values_array.push(fastq_list_row.rgid + '/' + fastq_list_row_field_value_file.basename);\n                }\n                else {\n                    /*\n                    Push the string attribute to the fastq list csv row\n                    Replace any commas in the string with ' -'\n                    */\n                    fastq_list_row_values_array.push(fastq_list_row_field_value.toString().replace(/,/g, \" -\"));\n                }\n                found_item = true;\n                break;\n            }\n        }\n        if (!found_item) {\n            /*\n            Push blank cell if no item found\n            */\n            fastq_list_row_values_array.push(\"\");\n        }\n    }\n    /*\n    Convert to string and return as string\n    */\n    return fastq_list_row_values_array.join(\",\") + \"\\n\";\n}\nfunction generate_fastq_list_csv(fastq_list_rows) {\n    /*\n    Fastq list rows generation\n    */\n    var fastq_csv_file = {\n        class:\"File\",\n        basename:get_fastq_list_csv_path()\n    };\n    /*\n    Set the row order\n    */\n    var row_order = [];\n    /*\n    Set the array order\n    Make sure we iterate through all rows of the array\n    */\n    for (var _i = 0, fastq_list_rows_1 = fastq_list_rows; _i < fastq_list_rows_1.length; _i++) {\n        var fastq_list_row = fastq_list_rows_1[_i];\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            if (row_order.indexOf(fastq_list_row_field_name) === -1) {\n                row_order.push(fastq_list_row_field_name);\n            }\n        }\n    }\n    /*\n    Make header\n    */\n    fastq_csv_file.contents = build_fastq_list_csv_header(row_order);\n    /*\n    For each fastq list row,\n    collect the values of each attribute but in the order of the header\n    */\n    for (var _c = 0, fastq_list_rows_2 = fastq_list_rows; _c < fastq_list_rows_2.length; _c++) {\n        var fastq_list_row = fastq_list_rows_2[_c];\n        /*  Add csv row to file contents */\n        fastq_csv_file.contents += get_fastq_list_row_as_csv_row(fastq_list_row, row_order);\n    }\n    return fastq_csv_file;\n}\nfunction get_value_for_config(valueObj) {\n    /* If valueObj is an IFile, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"File\") {\n        return valueObj.path;\n    }\n    /* If valueObj is an IDirectory, return its path */\n    if (valueObj.hasOwnProperty(\"class\") && valueObj[\"class\"] === \"Directory\") {\n        return valueObj.path;\n    }\n    /* Recursively call this function for nested objects */\n    if (typeof valueObj === 'object' && !Array.isArray(valueObj)) {\n        var newValueObj = {};\n        for (var key in valueObj) {\n            if (valueObj[key] === null || valueObj[key] === undefined) {\n                continue;\n            }\n            /* Special case - boolean to numeric */\n            if (key in DragenNumericBooleanType) {\n                newValueObj[key.replace(/_/g, \"-\")] = valueObj[key] ? 1 :0;\n                continue;\n            }\n            newValueObj[key.replace(/_/g, \"-\")] = get_value_for_config(valueObj[key]);\n        }\n        return newValueObj;\n    }\n    /* Consider arrays */\n    if (Array.isArray(valueObj)) {\n        return valueObj.map(function (item) { return get_value_for_config(item); });\n    }\n    /* Otherwise return the value as is */\n    return valueObj;\n}\nfunction get_dragen_config_path() {\n    return \"dragen_config.toml\";\n}\nfunction dragen_to_config_toml(props) {\n    /* Part 1 - Generate the json blob */\n    var json_blob = {};\n    for (var key in props) {\n        /* Get props key value */\n        var value = props[key];\n        /* Skip null props */\n        if (value === null || value === undefined) {\n            continue;\n        }\n        /*  FIXME denovo to DeNovo */\n        /* Special cases */\n        /* 1. Fastq list rows we rename to 'fastq-list',\n            alignment data mounted at the base of the working directory\n        */\n        /* Sequence data */\n        if (key === \"fastq_list_rows\") {\n            json_blob[\"fastq-list\"] = get_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"bam_input\") {\n            json_blob[\"bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_input\") {\n            json_blob[\"cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"cram_reference\") {\n            json_blob[\"cram-reference\"] = value.basename;\n            continue;\n        }\n        /* Tumor sequence data */\n        if (key === \"tumor_fastq_list_rows\") {\n            json_blob['tumor-fastq-list'] = get_tumor_fastq_list_csv_path();\n            continue;\n        }\n        if (key === \"tumor_bam_input\") {\n            json_blob[\"tumor-bam-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_input\") {\n            json_blob[\"tumor-cram-input\"] = value.basename;\n            continue;\n        }\n        if (key === \"tumor_cram_reference\") {\n            json_blob[\"tumor-cram-reference\"] = value.basename;\n            continue;\n        }\n        /* 2. If ref-tar is parsed through, we use ref-dir instead */\n        if (key === \"ref_tar\") {\n            json_blob['ref-dir'] = get_ref_mount() + value.basename.replace(/\\.tar\\.gz$/, \"\");\n            /*\n                If the ref_tar does not contain 'graph',\n                then we also need to add the parameter,\n                --validate-pangenome-reference=false,\n                this was in place when we wanted to align genome to linear somatic reference\n                however, we are no longer doing that so this parameter is not needed\n            */\n            if (!value.basename.includes(\"graph\")) {\n                json_blob['validate-pangenome-reference'] = false;\n            }\n            continue;\n        }\n        /* If the ora reference is parsed through, we also place the ora reference into the scratch space */\n        if (key === \"ora_reference\") {\n            /* Mounted at scratch mount, strip the .tar.gz from the basename */\n            json_blob['ora-reference'] = get_ora_ref_path(value);\n            continue;\n        }\n        /* If the nirvana reference is parsed through, we also place the nirvana reference into the scratch space */\n        if (key === \"variant_annotation_data\") {\n            /* Mounted at the scratch mount, strip the .tar.gz from the basename */\n            json_blob['variant-annotation-data'] = get_nirvana_ref_path(value);\n            continue;\n        }\n        /* 3. Check if key is in the boolean to numeric list */\n        if (key in DragenNumericBooleanType) {\n            json_blob[key.replace(/_/g, \"-\")] = value ? 1 :0;\n            continue;\n        }\n        /* 4. Check if key is a qc coverage object */\n        if (key === \"qc_coverage\") {\n            /*\n            We need to iterate through the qc coverage objects\n            and add them to the json blob\n            */\n            value.forEach(function (qcObject, index) {\n                json_blob[\"qc-coverage-region-\".concat(index + 1)] = qcObject.region.path;\n                json_blob[\"qc-coverage-reports-\".concat(index + 1)] = qcObject.report_type;\n                if (qcObject.thresholds !== null && qcObject.thresholds !== undefined) {\n                    json_blob[\"qc-coverage-region-\".concat(index + 1, \"-thresholds\")] = qcObject.thresholds.map(function (threshold) { return threshold.toString(); }).join(\",\");\n                }\n            });\n            continue;\n        }\n        /* 5. Get value for standard options */\n        if (props.hasOwnProperty(key)) {\n            /*  We replace snake case with hyphen */\n            json_blob[key.replace(/_/g, \"-\")] = get_value_for_config(value);\n        }\n    }\n    /* Part 2 - Convert the json blob to toml */\n    return json_to_toml(json_blob);\n}\nfunction generate_sequence_data_mount_points(sequence_data, tumor_sequence_data) {\n    /*\n    Create and add in the fastq list csv for the input fastqs\n    If the input is bam or cram, we also mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the sequence data */\n    if (\"fastq_list_rows\" in sequence_data && sequence_data.fastq_list_rows !== undefined) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _i = 0, _a = sequence_data.fastq_list_rows; _i < _a.length; _i++) {\n            var fastq_list_row = _a[_i];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in sequence_data && sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.bam_input.secondaryFiles) {\n            sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in sequence_data && sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (sequence_data.cram_input.secondaryFiles) {\n            sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (sequence_data.cram_reference.secondaryFiles) {\n                sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Can exist here if germline-only */\n    if (!tumor_sequence_data) {\n        /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n        return e;\n    }\n    /*  Add the tumor sequence data */\n    if (\"fastq_list_rows\" in tumor_sequence_data && tumor_sequence_data.fastq_list_rows !== undefined) {\n        /* Upload the csv */\n        e.push({\n            \"entryname\":get_tumor_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(tumor_sequence_data.fastq_list_rows)\n        });\n        /*  Optional path mappings are not added by default */\n        for (var _b = 0, _c = tumor_sequence_data.fastq_list_rows; _b < _c.length; _b++) {\n            var fastq_list_row = _c[_b];\n            if (fastq_list_row.read_1) {\n                /* Read 1 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_1 === 'object' && fastq_list_row.read_1.hasOwnProperty(\"class\") && fastq_list_row.read_1[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_1.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_1.location\n                        }\n                    });\n                }\n            }\n            if (fastq_list_row.read_2) {\n                /* Read 2 may be a string, such as a presigned url, if its a file mount it */\n                if (typeof fastq_list_row.read_2 === 'object' && fastq_list_row.read_2.hasOwnProperty(\"class\") && fastq_list_row.read_2[\"class\"] === \"File\") {\n                    e.push({\n                        \"entryname\":fastq_list_row.rgid + '/' + fastq_list_row.read_2.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":fastq_list_row.read_2.location\n                        }\n                    });\n                }\n            }\n        }\n    }\n    else if (\"bam_input\" in tumor_sequence_data && tumor_sequence_data.bam_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.bam_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.bam_input.secondaryFiles) {\n            tumor_sequence_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in tumor_sequence_data && tumor_sequence_data.cram_input !== undefined) {\n        e.push({\n            \"entryname\":tumor_sequence_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":tumor_sequence_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (tumor_sequence_data.cram_input.secondaryFiles) {\n            tumor_sequence_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (tumor_sequence_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":tumor_sequence_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_sequence_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_sequence_data.cram_reference.secondaryFiles) {\n                tumor_sequence_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_alignment_data_mount_points(alignment_data, tumor_alignment_data) {\n    /*\n    If the input is bam or cram, we mount as it 'un-cwlifies' the command line,\n    as this is often attached to the bottom of the PG line in a bam file,\n    we'd like to make that as short as possible\n    */\n    var e = [];\n    /*  Add the alignment data data */\n    if (\"bam_input\" in alignment_data && alignment_data.bam_input !== undefined) {\n        /* Add in the bam file */\n        e.push({\n            \"entryname\":alignment_data.bam_input.basename,\n            /* Due to the secondary files, we need to manually add in each file object */\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.bam_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.bam_input.secondaryFiles) {\n            alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n    }\n    else if (\"cram_input\" in alignment_data && alignment_data.cram_input !== undefined) {\n        /* Add in the cram file */\n        e.push({\n            \"entryname\":alignment_data.cram_input.basename,\n            \"entry\":{\n                \"class\":\"File\",\n                \"location\":alignment_data.cram_input.location\n            }\n        });\n        /* Then add in each secondary file object */\n        if (alignment_data.cram_input.secondaryFiles) {\n            alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                e.push({\n                    \"entryname\":secondary_file_iter_.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":secondary_file_iter_.location\n                    }\n                });\n            });\n        }\n        /*  We also add in the reference file if its provided */\n        if (alignment_data.cram_reference !== undefined) {\n            e.push({\n                \"entryname\":alignment_data.cram_reference.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":alignment_data.cram_reference.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (alignment_data.cram_reference.secondaryFiles) {\n                alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n    }\n    /* Now repeat for tumor alignment data */\n    if (tumor_alignment_data) {\n        /*  Add the alignment data data */\n        if (\"bam_input\" in tumor_alignment_data && tumor_alignment_data.bam_input !== undefined) {\n            /* Add in the bam file */\n            e.push({\n                \"entryname\":tumor_alignment_data.bam_input.basename,\n                /* Due to the secondary files, we need to manually add in each file object */\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.bam_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.bam_input.secondaryFiles) {\n                tumor_alignment_data.bam_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n        }\n        else if (\"cram_input\" in tumor_alignment_data && tumor_alignment_data.cram_input !== undefined) {\n            /* Add in the cram file */\n            e.push({\n                \"entryname\":tumor_alignment_data.cram_input.basename,\n                \"entry\":{\n                    \"class\":\"File\",\n                    \"location\":tumor_alignment_data.cram_input.location\n                }\n            });\n            /* Then add in each secondary file object */\n            if (tumor_alignment_data.cram_input.secondaryFiles) {\n                tumor_alignment_data.cram_input.secondaryFiles.forEach(function (secondary_file_iter_) {\n                    e.push({\n                        \"entryname\":secondary_file_iter_.basename,\n                        \"entry\":{\n                            \"class\":\"File\",\n                            \"location\":secondary_file_iter_.location\n                        }\n                    });\n                });\n            }\n            /*  We also add in the reference file if its provided */\n            if (tumor_alignment_data.cram_reference !== undefined) {\n                e.push({\n                    \"entryname\":tumor_alignment_data.cram_reference.basename,\n                    \"entry\":{\n                        \"class\":\"File\",\n                        \"location\":tumor_alignment_data.cram_reference.location\n                    }\n                });\n                /* Then add in each secondary file object */\n                if (tumor_alignment_data.cram_reference.secondaryFiles) {\n                    tumor_alignment_data.cram_reference.secondaryFiles.forEach(function (secondary_file_iter_) {\n                        e.push({\n                            \"entryname\":secondary_file_iter_.basename,\n                            \"entry\":{\n                                \"class\":\"File\",\n                                \"location\":secondary_file_iter_.location\n                            }\n                        });\n                    });\n                }\n            }\n        }\n    }\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_mv_qc_files_script_mount_points(options_list) {\n    /*\n     If alignment_options.qc_coverage is defined, we generate a script to move the qc files to their name attribute\n    */\n    var qc_files_script = generate_mv_qc_files_script(options_list);\n    if (!qc_files_script) {\n        return [];\n    }\n    else {\n        return [\n            {\n                entryname:qc_files_script.basename,\n                /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n                entry:qc_files_script\n            }\n        ];\n    }\n}\nfunction strip_uri_from_name(name_with_uri) {\n    /*\n    Given a string as a uri, return all after the trailing hash\n     */\n    return name_with_uri.split('#').pop() || name_with_uri;\n}\nfunction generate_mv_qc_files_script(options_list) {\n    /*\n    Generate mv qc files script\n     */\n    /* Check if alignment_options.qc_coverage is defined */\n    if (!options_list.alignment_options.qc_coverage || options_list.alignment_options.qc_coverage.length === 0) {\n        return null;\n    }\n    /* Initialise vars */\n    var output_file_prefix = options_list.output_file_prefix;\n    var output_directory = options_list.output_directory;\n    /* Initialise the script */\n    var mv_qc_files_script = \"#!/usr/bin/env bash\\n\\n\";\n    mv_qc_files_script += \"# Exit on failure\\n\";\n    mv_qc_files_script += \"set -euo pipefail\\n\\n\";\n    mv_qc_files_script += \"# Log start\\n\";\n    mv_qc_files_script += \"echo \\\"Start Moving QC files\\\" 1>&2\\n\\n\";\n    /* Arrays to make */\n    var qc_files_suffixes = [\n        /* Germline */\n        \"contig_mean_cov.csv\",\n        \"cov_report.bed\",\n        \"coverage_metrics.csv\",\n        \"fine_hist.csv\",\n        \"hist.csv\",\n        \"overall_mean_cov.csv\",\n        \"read_cov_report.bed\",\n        /* Somatic */\n        \"contig_mean_cov_normal.csv\",\n        \"contig_mean_cov_tumor.csv\",\n        \"cov_report_normal.bed\",\n        \"cov_report_tumor.bed\",\n        \"coverage_metrics_normal.csv\",\n        \"coverage_metrics_tumor.csv\",\n        \"fine_hist_normal.csv\",\n        \"fine_hist_tumor.csv\",\n        \"hist_normal.csv\",\n        \"hist_tumor.csv\",\n        \"overall_mean_cov_normal.csv\",\n        \"overall_mean_cov_tumor.csv\",\n        \"read_cov_report_normal.bed\",\n        \"read_cov_report_tumor.bed\",\n        \"somatic_callable_regions.bed\",\n    ];\n    var qc_file_names = options_list.alignment_options.qc_coverage.map(function (qc_coverage) { return strip_uri_from_name(qc_coverage.name); });\n    /* Create the qc suffixes array */\n    mv_qc_files_script += \"# Initialise coverage arrays \\n\";\n    mv_qc_files_script += \"QC_SUFFIXES=( \\\\\\n\";\n    for (var _i = 0, qc_files_suffixes_1 = qc_files_suffixes; _i < qc_files_suffixes_1.length; _i++) {\n        var qc_suffix = qc_files_suffixes_1[_i];\n        mv_qc_files_script += \"  \\\"\".concat(qc_suffix, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* QC Array complete */\n    /* Create the array of qc names */\n    mv_qc_files_script += \"QC_COVERAGE_NAMES=( \\\\\\n\";\n    for (var _a = 0, qc_file_names_1 = qc_file_names; _a < qc_file_names_1.length; _a++) {\n        var qc_coverage_name = qc_file_names_1[_a];\n        mv_qc_files_script += \"  \\\"\".concat(qc_coverage_name, \"\\\" \\\\\\n\");\n    }\n    mv_qc_files_script += \")\\n\\n\";\n    /* Now iterate through each qc name and suffix to move the files */\n    mv_qc_files_script += \"# Move the QC files to the output directory\\n\";\n    mv_qc_files_script += \"for qc_name_idx in \\\"${!QC_COVERAGE_NAMES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"  qc_name=\\\"${QC_COVERAGE_NAMES[$qc_name_idx]}\\\"\\n\";\n    mv_qc_files_script += \"  for qc_suffix in \\\"${QC_SUFFIXES[@]}\\\"; do\\n\";\n    mv_qc_files_script += \"    if [[ -f \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" ]]; then\\n\");\n    mv_qc_files_script += \"      mv \\\\\\n\";\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-$((qc_name_idx+1))_${qc_suffix}\\\" \\\\\\n\");\n    mv_qc_files_script += \"        \\\"\".concat(output_directory, \"/\").concat(output_file_prefix, \".qc-coverage-region-${qc_name}_${qc_suffix}\\\"\\n\");\n    mv_qc_files_script += \"    fi\\n\";\n    mv_qc_files_script += \"  done\\n\";\n    mv_qc_files_script += \"done\\n\\n\";\n    mv_qc_files_script += \"# Log completion\\n\";\n    mv_qc_files_script += \"echo \\\"Finish Moving QC files\\\" 1>&2\\n\";\n    return {\n        class:\"File\",\n        basename:\"mv_qc_files.sh\",\n        contents:mv_qc_files_script\n    };\n}\nfunction dragen_merge_options(options_list) {\n    /*\n    Merge a list of objects, ignoring null or undefined values\n    Options are merged in the order they are provided\n    So if there are duplicate keys, the last one will be used\n    */\n    var merged_options = {};\n    for (var _i = 0, options_list_1 = options_list; _i < options_list_1.length; _i++) {\n        var options_object = options_list_1[_i];\n        if (options_object === null || options_object === undefined) {\n            continue;\n        }\n        for (var key in options_object) {\n            /*\n             Check if the key is null or undefined.\n            */\n            if (options_object[key] === undefined) {\n                continue;\n            }\n            /*\n              If the merged key does NOT exist in the merged options but the value is null we add it in\n            */\n            if ((!merged_options.hasOwnProperty(key)) && options_object[key] === null) {\n                merged_options[key] = null;\n                continue;\n            }\n            /*\n              If the merged key DOES exist in the merged options but the value is null we skip it\n            */\n            if (merged_options.hasOwnProperty(key) && options_object[key] === null) {\n                continue;\n            }\n            /*\n              If the key already exists in merged options, check if the\n              merged_options key is a dictionary, if so we need to recursively merge instead\n            */\n            if (merged_options.hasOwnProperty(key) &&\n                typeof merged_options[key] === 'object' &&\n                (merged_options[key] !== null) &&\n                !Array.isArray(merged_options[key])) {\n                /*\n                  Check the item key is also an object\n                */\n                if (typeof options_object[key] === 'object' && !Array.isArray(options_object[key])) {\n                    /*\n                      If the key is an object, we merge the two objects\n                      This is useful for options that have sub-options\n                      However we dont to override values in merged_options that are already set\n                      if the value in the options object is null,\n                      we can solve this by calling the dragen_merge_options function recursively\n                    */\n                    merged_options[key] = dragen_merge_options([\n                        merged_options[key],\n                        options_object[key]\n                    ]);\n                }\n                /*\n                  Otherwise we just override it.\n                */\n                else {\n                    merged_options[key] = options_object[key];\n                }\n                continue;\n            }\n            /*\n            Just a standard option.\n            */\n            if (options_object.hasOwnProperty(key)) {\n                merged_options[key] = options_object[key];\n            }\n        }\n    }\n    return merged_options;\n}\nfunction get_dragen_wgts_dna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name ? props.sample_name :\"\", \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction get_dragen_wgts_rna_alignment_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        output_directory:(\"\".concat(props.sample_name, \"__\") +\n            \"\".concat(strip_uri_from_name(props.reference.name), \"__\") +\n            \"\".concat(props.reference.structure, \"__dragen_rna_alignment\")),\n        output_file_prefix:props.sample_name ? props.sample_name :\"\",\n        /* License file */\n        lic_instance_id_location:(props.lic_instance_id_location ? props.lic_instance_id_location :DEFAULT_LIC_INSTANCE_ID_LOCATION_PATH),\n        /* Set enable rna to true */\n        enable_rna:true,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ])\n    };\n}\nfunction filter_object_by_keys(object1, object2) {\n    /**\n     * Return object 1 with only the keys that are in object 2\n     */\n    var filtered_object = {};\n    /* Dont need to filter if object1 is null or undefined */\n    if (object1 === null || object1 === undefined) {\n        return object2;\n    }\n    /* Iterate through object1 and check if the key is in object2 */\n    for (var key in object1) {\n        if (object2.hasOwnProperty(key)) {\n            filtered_object[key] = object1[key];\n        }\n    }\n    return filtered_object;\n}\nfunction get_dragen_wgts_dna_variant_calling_stage_options_from_pipeline(props) {\n    /*\n        ? :syntax is required\n        since we also need to consider that all inputs are\n        evaluated before 'when'\n    */\n    return {\n        /*\n        Naming things\n        */\n        sample_name:props.sample_name,\n        tumor_sample_name:props.tumor_sample_name,\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        tumor_sequence_data:props.tumor_sequence_data,\n        ref_tar:props.reference.tarball,\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:(props.tumor_sample_name ? props.tumor_sample_name :props.sample_name),\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:((props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") +\n            props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__\" +\n            \"dragen_wgts_dna_\" + (props.tumor_sample_name ? \"somatic\" :\"germline\") + \"_variant_calling\"),\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        /* SNV caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        /* CNV caller options */\n        cnv_caller_options:props.cnv_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* SV caller options */\n        sv_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.sv_caller_options),\n            props.sv_caller_options,\n        ]),\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n        /* Targeted Caller options */\n        targeted_caller_options:props.targeted_caller_options,\n        /* Mrjd Options */\n        mrjd_options:props.mrjd_options,\n        /* TMB Options */\n        tmb_options:props.tmb_options,\n        /* MSI Options */\n        msi_options:props.msi_options,\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n    };\n}\nfunction get_dragen_wgts_rna_variant_calling_stage_options_from_pipeline(props) {\n    return {\n        /* Data inputs */\n        sequence_data:props.sequence_data,\n        ref_tar:props.reference.tarball,\n        /* Ora reference */\n        ora_reference:props.ora_reference ? props.ora_reference :null,\n        /* Annotation file, used for a lot of the variant calling options */\n        annotation_file:props.annotation_file,\n        /* Stage specific options */\n        /* Use tumor_sample_name if it exists otherwise use the standard sample name */\n        output_file_prefix:props.sample_name,\n        /* <TUMOR_SAMPLE_NAME>__<NORMAL_SAMPLE_NAME>_variant_calling for somatic data */\n        /* <SAMPLE_NAME>_variant_calling for germline data */\n        output_directory:(props.sample_name + \"__\" +\n            strip_uri_from_name(props.reference.name) + \"__\" +\n            props.reference.structure + \"__dragen_wgts_rna_variant_calling\"),\n        /* Lic Instance id location */\n        lic_instance_id_location:props.lic_instance_id_location,\n        /* Alignment options */\n        alignment_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.alignment_options),\n            props.alignment_options,\n        ]),\n        /* Variant caller options */\n        snv_variant_caller_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.snv_variant_caller_options),\n            props.snv_variant_caller_options,\n        ]),\n        gene_expression_quantification_options:dragen_merge_options([\n            filter_object_by_keys(props.default_configuration_options, props.gene_expression_quantification_options),\n            props.gene_expression_quantification_options,\n        ]),\n        gene_fusion_detection_options:props.gene_fusion_detection_options,\n        splice_variant_caller_options:props.splice_variant_caller_options,\n        /* MAF Conversion Options */\n        maf_conversion_options:props.maf_conversion_options,\n        /* Nirvana options */\n        nirvana_annotation_options:props.nirvana_annotation_options,\n    };\n}\n/**\n * Multiqc functions\n *\n */\nfunction get_wgts_dna_multiqc_output_filename(props) {\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc_report.html\";\n}\nfunction get_wgts_rna_multiqc_output_filename(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc_report.html\";\n}\nfunction get_wgts_dna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (props.tumor_sample_name ? props.tumor_sample_name + \"__\" :\"\") + props.sample_name + \"__multiqc\";\n}\nfunction get_wgts_rna_multiqc_output_directory_name(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return props.sample_name + \"_multiqc\";\n}\nfunction get_wgts_dna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS DNA Pipeline ( \" +\n        (props.tumor_sample_name ? props.tumor_sample_name + \"/\" :\"\") +\n        props.sample_name + \" )\");\n}\nfunction get_wgts_rna_multiqc_title(props) {\n    /* Given a sample name, and potentially a tumor sample name, return the multiqc output directory name */\n    return (\"Dragen 4.4.4 WGTS RNA Pipeline ( \" +\n        props.sample_name +\n        \" )\");\n}\nfunction pick_first_non_null(object_list) {\n    for (var _i = 0, object_list_1 = object_list; _i < object_list_1.length; _i++) {\n        var object = object_list_1[_i];\n        if (object) {\n            return object;\n        }\n    }\n}\nfunction pick_all_non_null(object_list) {\n    var non_null_objects = [];\n    for (var _i = 0, object_list_2 = object_list; _i < object_list_2.length; _i++) {\n        var object = object_list_2[_i];\n        if (object) {\n            non_null_objects.push(object);\n        }\n    }\n    return non_null_objects;\n}\nfunction dragen_references_match(reference_list) {\n    /*\n    Determine if the two references match,\n    If one the references is null or undefined then still return true\n    Since we really just want to know if we have two different references\n    */\n    if (reference_list.length !== 2) {\n        throw new Error(\"dragen_references_match:reference_list must be of length 2\");\n    }\n    /* Check if either of the references are null or undefined */\n    if (!reference_list[0] || !reference_list[1]) {\n        return true;\n    }\n    return reference_list[0].tarball.location == reference_list[1].tarball.location;\n}\n/* Utility functions */\nfunction get_optional_attribute_from_object(input_object, attribute) {\n    /*\n    Get attribute from object, if attribute is not defined return null\n    Assume the input object is an object of key value pairs where we know the key is of type string\n    stackoverflow.com/questions/56833469/typescript-error-ts7053-element-implicitly-has-an-any-type\n    */\n    if (input_object.hasOwnProperty(attribute)) {\n        return input_object[attribute];\n    }\n    else {\n        return null;\n    }\n}\nfunction get_attribute_from_optional_input(input_object, attribute) {\n    /*\n    Get attribute from optional input -\n    If input is not defined, then return null\n    */\n    if (input_object === null || input_object === undefined) {\n        return null;\n    }\n    else {\n        return get_optional_attribute_from_object(input_object, attribute);\n    }\n}\nfunction is_not_null(input_obj) {\n    /*\n    Determine if input object is defined and is not null\n    */\n    return !(input_obj === null || input_obj === undefined);\n}\n"
          ],
          "class": "InlineJavascriptRequirement"
        },
        {
          "class": "MultipleInputFeatureRequirement"
        },
        {
          "class": "ScatterFeatureRequirement"
        },
        {
          "types": [
            {
              "$import": "#fastq-list-row__2.0.0.yaml/fastq-list-row"
            },
            {
              "$import": "#fastq-list-rows-input__2.0.0.yaml/fastq-list-rows-input"
            },
            {
              "$import": "#bam-input__1.0.0.yaml/bam-input"
            },
            {
              "$import": "#cram-input__1.0.0.yaml/cram-input"
            },
            {
              "$import": "#dragen-reference__1.0.0.yaml/dragen-reference"
            },
            {
              "$import": "#dragen-aligner-options__4.4.0.yaml/dragen-aligner-options"
            },
            {
              "$import": "#dragen-mapper-options__4.4.0.yaml/dragen-mapper-options"
            },
            {
              "$import": "#dragen-qc-coverage__1.0.0.yaml/dragen-qc-coverage"
            },
            {
              "$import": "#dragen-wgts-alignment-options__4.4.0.yaml/dragen-wgts-alignment-options"
            },
            {
              "$import": "#dragen-snv-variant-caller-options__4.4.0.yaml/dragen-snv-variant-caller-options"
            },
            {
              "$import": "#dragen-cnv-caller-options__4.4.0.yaml/dragen-cnv-caller-options"
            },
            {
              "$import": "#dragen-maf-conversion-options__4.4.0.yaml/dragen-maf-conversion-options"
            },
            {
              "$import": "#dragen-sv-caller-options__4.4.0.yaml/dragen-sv-caller-options"
            },
            {
              "$import": "#dragen-nirvana-annotation-options__4.4.0.yaml/dragen-nirvana-annotation-options"
            },
            {
              "$import": "#dragen-targeted-caller-options__4.4.0.yaml/dragen-targeted-caller-options"
            },
            {
              "$import": "#dragen-mrjd-options__4.4.0.yaml/dragen-mrjd-options"
            },
            {
              "$import": "#dragen-msi-options__4.4.0.yaml/dragen-msi-options"
            },
            {
              "$import": "#dragen-tmb-options__4.4.0.yaml/dragen-tmb-options"
            },
            {
              "$import": "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage"
            }
          ],
          "class": "SchemaDefRequirement"
        },
        {
          "class": "StepInputExpressionRequirement"
        },
        {
          "class": "SubworkflowFeatureRequirement"
        }
      ],
      "inputs": [
        {
          "type": [
            "#dragen-wgts-dna-options-variant-calling-stage__4.4.0.yaml/dragen-wgts-dna-options-variant-calling-stage"
          ],
          "id": "#dragen-wgts-dna-variant-calling-stage__4.4.6.cwl/dragen-variant-calling-stage--4.4.6/dragen_options"
        }
      ],
      "steps": [
        {
          "in": [
            {
              "source": "#dragen-wgts-dna-variant-calling-stage__4.4.6.cwl/dragen-variant-calling-stage--4.4.6/dragen_options",
              "id": "#dragen-wgts-dna-variant-calling-stage__4.4.6.cwl/dragen-variant-calling-stage--4.4.6/run_dragen_variant_calling_step/dragen_options"
            }
          ],
          "out": [
            {
              "id": "#dragen-wgts-dna-variant-calling-stage__4.4.6.cwl/dragen-variant-calling-stage--4.4.6/run_dragen_variant_calling_step/output_directory"
            }
          ],
          "run": "#dragen-wgts-dna-variant-calling-step__4.4.6.cwl",
          "id": "#dragen-wgts-dna-variant-calling-stage__4.4.6.cwl/dragen-variant-calling-stage--4.4.6/run_dragen_variant_calling_step"
        }
      ],
      "outputs": [
        {
          "type": "Directory",
          "outputSource": "#dragen-wgts-dna-variant-calling-stage__4.4.6.cwl/dragen-variant-calling-stage--4.4.6/run_dragen_variant_calling_step/output_directory",
          "doc": "The output directory of the DRAGEN variant calling pipeline.\n",
          "id": "#dragen-wgts-dna-variant-calling-stage__4.4.6.cwl/dragen-variant-calling-stage--4.4.6/output_directory"
        }
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    }
  ],
  "cwlVersion": "v1.2",
  "$schemas": [
    "https://schema.org/version/latest/schemaorg-current-http.rdf"
  ],
  "$namespaces": {
    "s": "https://schema.org/"
  }
}