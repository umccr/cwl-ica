{
  "$graph": [
    {
      "class": "ExpressionTool",
      "id": "#get-first-non-null-bam-file__1.0.0.cwl",
      "label": "get-first-non-null-bam-file v(1.0.0)",
      "doc": "Documentation for get-first-non-null-bam-file v1.0.0\n",
      "requirements": [
        {
          "expressionLib": [
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Functions */\nfunction is_not_null(input_obj) {\n    /*\n    Determine if input object is defined and is not null\n    */\n    return !(input_obj === null || input_obj === undefined);\n}\nfunction get_attribute_from_optional_input(input_object, attribute) {\n    /*\n    Get attribute from optional input -\n    If input is not defined, then return null\n    */\n    if (input_object === null || input_object === undefined) {\n        return null;\n    }\n    else {\n        return get_optional_attribute_from_object(input_object, attribute);\n    }\n}\nfunction get_optional_attribute_from_object(input_object, attribute) {\n    /*\n    Get attribute from object, if attribute is not defined return null\n    Assume the input object is an object of key value pairs where we know the key is of type string\n    stackoverflow.com/questions/56833469/typescript-error-ts7053-element-implicitly-has-an-any-type\n    */\n    if (input_object.hasOwnProperty(attribute)) {\n        return input_object[attribute];\n    }\n    else {\n        return null;\n    }\n}\nfunction get_bool_value_as_str(input_bool) {\n    if (is_not_null(input_bool) && input_bool) {\n        return \"true\";\n    }\n    else {\n        return \"false\";\n    }\n}\nfunction boolean_to_int(input_bool) {\n    if (is_not_null(input_bool) && String(input_bool).toLowerCase() === \"true\") {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nfunction get_optional_attribute_from_multi_type_input_object(object, attribute) {\n    /*\n    Get attribute from optional input\n    */\n    if (object === null || object === undefined) {\n        return null;\n    }\n    else if (typeof object === \"object\") {\n        /*  Get attribute from optional input */\n        return get_attribute_from_optional_input(object, attribute);\n    }\n    else {\n        /*  Object is likely actually a str */\n        return object;\n    }\n}\nfunction get_source_a_or_b(input_a, input_b) {\n    /*\n    Get the first input parameter if it is not null\n    Otherwise return the second parameter\n    Otherwise return null\n    */\n    if (is_not_null(input_a)) {\n        return input_a;\n    }\n    else if (is_not_null(input_b)) {\n        return input_b;\n    }\n    else {\n        return null;\n    }\n}\nfunction get_first_non_null_input(inputs) {\n    /*\n    Get first element of the array that is not null\n    */\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n        var input_element = inputs_1[_i];\n        if (is_not_null(input_element)) {\n            return input_element;\n        }\n    }\n    return null;\n}\nfunction get_attribute_list_from_object_list(obj_list, attribute) {\n    /*\n    Get attribute from list of objects\n    If an object is null, it is not included in the return list\n    */\n    return obj_list.filter(function (x) { return x !== null; }).map(function (x) { return get_optional_attribute_from_object(x, attribute); });\n}\nfunction get_str_list_as_bash_array(input_list, item_wrap) {\n    /*\n    Convert a list of strings to a bash array, if the list is not defined return null\n    */\n    if (input_list === null) {\n        return null;\n    }\n    if (item_wrap === null) {\n        return \"( \".concat(input_list.map(function (x) { return \"'\".concat(item_wrap).concat(x).concat(item_wrap, \"'\"); }).join(' '), \" )\");\n    }\n    return \"( \".concat(input_list.map(function (x) { return \"'\".concat(x, \"'\"); }).join(' '), \" )\");\n}\nfunction get_object_attribute_list_as_bash_array(obj_list, attribute) {\n    /*\n    Get attribute from list of objects and convert to a bash array\n    Do not include null values in the array\n    */\n    return get_str_list_as_bash_array(get_attribute_list_from_object_list(obj_list, attribute).filter(function (x) { return x !== null; }));\n}\n"
          ],
          "class": "InlineJavascriptRequirement"
        }
      ],
      "inputs": [
        {
          "label": "input bams",
          "doc": "Array of input bams\n",
          "type": [
            {
              "type": "array",
              "items": [
                "null",
                "File"
              ]
            }
          ],
          "id": "#get-first-non-null-bam-file__1.0.0.cwl/get-first-non-null-bam-file--1.0.0/input_bams"
        }
      ],
      "expression": "${\n  return {\"output_bam_file\": get_first_non_null_input(inputs.input_bams)};\n}\n",
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      },
      "outputs": [
        {
          "label": "output_bam_file",
          "doc": "First non null bam file in the array\n",
          "type": [
            "null",
            "File"
          ],
          "secondaryFiles": [
            {
              "pattern": ".bai",
              "required": false
            }
          ],
          "id": "#get-first-non-null-bam-file__1.0.0.cwl/get-first-non-null-bam-file--1.0.0/output_bam_file"
        }
      ]
    },
    {
      "class": "CommandLineTool",
      "id": "#dragen-germline__4.3.6.cwl",
      "label": "dragen-germline v(4.2.4)",
      "doc": "Documentation for dragen-germline v4.2.4\n",
      "hints": [
        {
          "dockerPull": "699120554104.dkr.ecr.us-east-1.amazonaws.com/public/dragen:4.3.6",
          "class": "DockerRequirement"
        },
        {
          "coresMin": 16,
          "ramMin": 240000,
          "class": "ResourceRequirement",
          "https://platform.illumina.com/rdf/ica/resources:tier": "standard",
          "https://platform.illumina.com/rdf/ica/resources:type": "fpga",
          "https://platform.illumina.com/rdf/ica/resources:size": "medium"
        }
      ],
      "requirements": [
        {
          "listing": [
            {
              "entryname": "$(get_script_path())",
              "entry": "#!/usr/bin/env bash\n\n# Fail on non-zero exit of subshell\nset -euo pipefail\n\n# Run partial reconfig\n/opt/edico/bin/dragen \\\\\n  --partial-reconfig HMM \\\\\n  --ignore-version-check true\n\n# Create directories\nmkdir --parents \\\\\n  \"$(get_ref_mount())\" \\\\\n  \"$(get_intermediate_results_dir())\" \\\\\n  \"$(inputs.output_directory)\"\n\n# untar ref data into scratch space\ntar \\\\\n  --directory \"$(get_ref_mount())\" \\\\\n  --extract \\\\\n  --file \"$(inputs.reference_tar.path)\"\n\n# Confirm either of fastq_list, fastq_list_rows, bam_input or cram_input is defined\nif [[ \"$(boolean_to_int(is_not_null(inputs.fastq_list)) + boolean_to_int(is_not_null(inputs.fastq_list_rows)) + boolean_to_int(is_not_null(inputs.bam_input)) + boolean_to_int(is_not_null(inputs.cram_input)))\" -ne \"1\" ]]; then\n  echo \"Please set one and only one of fastq_list, fastq_list_rows and bam_input for normal sample\" 1>&2\n  exit 1\nfi\n\n# Run dragen command and import options from cli\n\"$(get_dragen_bin_path())\" \"\\${@}\"\n"
            },
            "${\n  return generate_germline_mount_points(inputs);\n}\n"
          ],
          "class": "InitialWorkDirRequirement"
        },
        {
          "expressionLib": [
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Functions */\nfunction get_script_path() {\n    /*\n    Abstract script path, can then be referenced in baseCommand attribute too\n    Makes things more readable.\n    */\n    return \"run-dragen-script.sh\";\n}\nfunction get_scratch_mount() {\n    /*\n    Return the path of the scratch directory space\n    */\n    return \"/scratch/\";\n}\nfunction get_intermediate_results_dir() {\n    /*\n    Get intermediate results directory as /scratch for dragen runs\n    */\n    return get_scratch_mount() + \"intermediate-results/\";\n}\nfunction get_name_root_from_tarball(basename) {\n    var tar_ball_regex = /(\\S+)\\.tar\\.gz/g;\n    var tar_ball_expression = tar_ball_regex.exec(basename);\n    if (tar_ball_expression === null) {\n        throw new Error(\"Could not get nameroot from \".concat(basename));\n    }\n    return tar_ball_expression[1];\n}\nfunction get_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename) + \"/\";\n}\nfunction get_ref_mount() {\n    /*\n    Get the reference mount point\n    */\n    return get_scratch_mount() + \"ref/\";\n}\nfunction get_dragen_bin_path() {\n    /*\n    Get dragen bin path\n    */\n    return \"/opt/edico/bin/dragen\";\n}\nfunction get_dragen_eval_line() {\n    /*\n    Return string\n    */\n    return \"eval \\\"\" + get_dragen_bin_path() + \"\\\" '\\\"\\$@\\\"' \\n\";\n}\nfunction get_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"fastq_list.csv\";\n}\nfunction get_tumor_fastq_list_csv_path() {\n    /*\n    The tumor fastq list path must be placed in working directory\n    */\n    return \"tumor_fastq_list.csv\";\n}\nfunction get_ora_mv_files_script_path() {\n    /*\n    Get the ora mv files script path\n    */\n    return \"mv-ora-output-files.sh\";\n}\nfunction get_new_fastq_list_csv_script_path() {\n    /*\n    Get the new fastq list csv script path\n    */\n    return \"generate-new-fastq-list-csv.sh\";\n}\nfunction get_fastq_gz_md5sum_files_script_path() {\n    /*\n    Get the script path to generating the md5sum for each fastq gzip file\n    */\n    return \"generate-md5sum-for-fastq-gz-files.sh\";\n}\nfunction get_fastq_gz_file_sizes_script_path() {\n    /*\n    Get the script path to generating the filesizes for each fastq gzip file\n    */\n    return \"generate-file-sizes-for-fastq-gz-files.sh\";\n}\nfunction get_fastq_ora_md5sum_files_script_path() {\n    /*\n    Get the script path for generating the md5sum for each fastq ora file\n    */\n    return \"generate-md5sum-for-fastq-ora-files.sh\";\n}\nfunction get_fastq_ora_file_sizes_script_path() {\n    /*\n    Get the script path to generating the filesizes for each fastq gzip file\n    */\n    return \"generate-file-sizes-for-fastq-ora-files.sh\";\n}\nfunction get_normal_name_from_fastq_list_rows(fastq_list_rows) {\n    /*\n    Get the normal sample name from the fastq list rows object\n    */\n    /*\n    Check fastq list rows is defined\n    */\n    if (fastq_list_rows === undefined || fastq_list_rows === null) {\n        return null;\n    }\n    /*\n    Get RGSM value and return\n    */\n    return fastq_list_rows[0].rgsm;\n}\nfunction get_normal_name_from_fastq_list_csv(fastq_list_csv) {\n    /*\n    Get the normal name from the fastq list csv...\n    */\n    /*\n    Check file is defined\n    */\n    if (fastq_list_csv === undefined || fastq_list_csv === null) {\n        return null;\n    }\n    /*\n    Check contents are defined\n    */\n    if (fastq_list_csv.contents === null || fastq_list_csv.contents === undefined) {\n        return null;\n    }\n    /*\n    Confirm fastq list csv is of type File\n    */\n    if (fastq_list_csv.class !== \"File\") {\n        throw new Error(\"Could not confirm input fastq_list_csv is of type File\");\n    }\n    /*\n    Split contents by line\n    */\n    var contents_by_line = [];\n    fastq_list_csv.contents.split(\"\\n\").forEach(function (line_content) {\n        var stripped_line_content = line_content.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n        if (stripped_line_content !== \"\") {\n            contents_by_line.push(stripped_line_content);\n        }\n    });\n    var column_names = contents_by_line[0].split(\",\");\n    /*\n    Get RGSM index value (which column is RGSM at?)\n    */\n    var rgsm_index = column_names.indexOf(\"RGSM\");\n    /*\n    RGSM is not in index. Return null\n    */\n    if (rgsm_index === -1) {\n        return null;\n    }\n    /*\n    Get RGSM value of first row and return\n    */\n    return contents_by_line[1].split(\",\")[rgsm_index];\n}\nfunction get_normal_output_prefix(inputs) {\n    var _a, _b;\n    /*\n    Get the normal RGSM value and then add _normal to it\n    */\n    var normal_name = null;\n    var normal_re_replacement = /_normal$/;\n    /*\n    Check if bam_input is set\n    */\n    if (inputs.bam_input !== null && inputs.bam_input !== undefined) {\n        /* Remove _normal from nameroot if it already exists */\n        /* We dont want _normal_normal as a suffix */\n        return \"\".concat((_a = inputs.bam_input.nameroot) === null || _a === void 0 ? void 0 :_a.replace(normal_re_replacement, \"\"), \"_normal\");\n    }\n    /*\n    Check if cram_input is set\n    */\n    if (inputs.cram_input !== null && inputs.cram_input !== undefined) {\n        /* Remove _normal from nameroot if it already exists */\n        /* We dont want _normal_normal as a suffix */\n        return \"\".concat((_b = inputs.cram_input.nameroot) === null || _b === void 0 ? void 0 :_b.replace(normal_re_replacement, \"\"), \"_normal\");\n    }\n    /*\n    Check if fastq list file is set\n    */\n    if (inputs.fastq_list !== null && inputs.fastq_list !== undefined) {\n        normal_name = get_normal_name_from_fastq_list_csv(inputs.fastq_list);\n        if (normal_name !== null) {\n            return \"\".concat(normal_name, \"_normal\");\n        }\n    }\n    /*\n    Otherwise collect and return from schema object\n    */\n    normal_name = get_normal_name_from_fastq_list_rows(inputs.fastq_list_rows);\n    return \"\".concat(normal_name, \"_normal\");\n}\nfunction build_fastq_list_csv_header(header_names) {\n    /*\n    Convert lowercase labels to uppercase values\n    i.e\n    [ \"rgid\", \"rglb\", \"rgsm\", \"lane\", \"read_1\", \"read_2\" ]\n    to\n    \"RGID,RGLB,RGSM,Lane,Read1File,Read2File\"\n    */\n    var modified_header_names = [];\n    for (var _i = 0, header_names_1 = header_names; _i < header_names_1.length; _i++) {\n        var header_name = header_names_1[_i];\n        if (header_name.indexOf(\"rg\") === 0) {\n            /*\n            rgid -> RGID\n            */\n            modified_header_names.push(header_name.toUpperCase());\n        }\n        else if (header_name.indexOf(\"read\") === 0) {\n            /*\n            read_1 -> Read1File\n            */\n            modified_header_names.push(\"Read\" + header_name.charAt(header_name.length - 1) + \"File\");\n        }\n        else {\n            /*\n            lane to Lane\n            */\n            modified_header_names.push(header_name[0].toUpperCase() + header_name.substr(1));\n        }\n    }\n    /*\n    Convert array to comma separated strings\n    */\n    return modified_header_names.join(\",\") + \"\\n\";\n}\nfunction get_fastq_list_row_as_csv_row(fastq_list_row, row_order) {\n    var fastq_list_row_values_array = [];\n    /*  This for loop is here to ensure were assigning values in the same order as the header */\n    for (var _i = 0, row_order_1 = row_order; _i < row_order_1.length; _i++) {\n        var item_index = row_order_1[_i];\n        var found_item = false;\n        /*  Find matching attribute in this row */\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            var fastq_list_row_field_value = fastq_list_row[fastq_list_row_field_name];\n            if (fastq_list_row_field_value === null) {\n                /*\n                Item not found, add an empty attribute for this cell in the csv\n                */\n                continue;\n            }\n            /*  The header value matches the name in the item */\n            if (fastq_list_row_field_name === item_index) {\n                /*\n                If the field value has a class attribute then it's either read_1 or read_2\n                */\n                if (fastq_list_row_field_value.hasOwnProperty(\"class\")) {\n                    var fastq_list_row_field_value_file = fastq_list_row_field_value;\n                    /*\n                    Assert that this is actually of class file\n                    */\n                    if (fastq_list_row_field_value_file.class !== \"File\") {\n                        continue;\n                    }\n                    if (fastq_list_row_field_value_file.path !== null && fastq_list_row_field_value_file.path !== undefined) {\n                        /*\n                        Push the path attribute to the fastq list csv row if it is not null\n                        */\n                        fastq_list_row_values_array.push(fastq_list_row_field_value_file.path);\n                    }\n                    else {\n                        /*\n                        Otherwise push the location attribute\n                        */\n                        fastq_list_row_values_array.push(fastq_list_row_field_value_file.location);\n                    }\n                }\n                else {\n                    /*\n                    Push the string attribute to the fastq list csv row\n                    */\n                    fastq_list_row_values_array.push(fastq_list_row_field_value.toString());\n                }\n                found_item = true;\n                break;\n            }\n        }\n        if (!found_item) {\n            /*\n            Push blank cell if no item found\n            */\n            fastq_list_row_values_array.push(\"\");\n        }\n    }\n    /*\n    Convert to string and return as string\n    */\n    return fastq_list_row_values_array.join(\",\") + \"\\n\";\n}\nfunction generate_fastq_list_csv(fastq_list_rows) {\n    /*\n    Fastq list rows generation\n    */\n    var fastq_csv_file = {\n        class:\"File\",\n        basename:get_fastq_list_csv_path()\n    };\n    /*\n    Set the row order\n    */\n    var row_order = [];\n    /*\n    Set the array order\n    Make sure we iterate through all rows of the array\n    */\n    for (var _i = 0, fastq_list_rows_1 = fastq_list_rows; _i < fastq_list_rows_1.length; _i++) {\n        var fastq_list_row = fastq_list_rows_1[_i];\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            if (row_order.indexOf(fastq_list_row_field_name) === -1) {\n                row_order.push(fastq_list_row_field_name);\n            }\n        }\n    }\n    /*\n    Make header\n    */\n    fastq_csv_file.contents = build_fastq_list_csv_header(row_order);\n    /*\n    For each fastq list row,\n    collect the values of each attribute but in the order of the header\n    */\n    for (var _c = 0, fastq_list_rows_2 = fastq_list_rows; _c < fastq_list_rows_2.length; _c++) {\n        var fastq_list_row = fastq_list_rows_2[_c];\n        /*  Add csv row to file contents */\n        fastq_csv_file.contents += get_fastq_list_row_as_csv_row(fastq_list_row, row_order);\n    }\n    return fastq_csv_file;\n}\nfunction generate_germline_mount_points(inputs) {\n    /*\n    Create and add in the fastq list csv for the input fastqs\n    */\n    var e = [];\n    if (inputs.fastq_list_rows !== null) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(inputs.fastq_list_rows)\n        });\n    }\n    if (inputs.fastq_list !== null) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":inputs.fastq_list\n        });\n    }\n    /*\n    Return file paths\n    */\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_somatic_mount_points(inputs) {\n    /*\n    Create and add in the fastq list csv for the input fastqs\n    */\n    var e = [];\n    if (inputs.fastq_list_rows !== null) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(inputs.fastq_list_rows)\n        });\n    }\n    if (inputs.tumor_fastq_list_rows !== null) {\n        e.push({\n            \"entryname\":get_tumor_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(inputs.tumor_fastq_list_rows)\n        });\n    }\n    if (inputs.fastq_list !== null) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":inputs.fastq_list\n        });\n    }\n    if (inputs.tumor_fastq_list !== null) {\n        e.push({\n            \"entryname\":get_tumor_fastq_list_csv_path(),\n            \"entry\":inputs.tumor_fastq_list\n        });\n    }\n    /*\n    Return file paths\n    */\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_transcriptome_mount_points(inputs) {\n    /*\n    Calls another function that generates mount points\n    */\n    return generate_germline_mount_points(inputs);\n}\n/*  Custom functions for dragen reference tarball build */\nfunction get_liftover_dir() {\n    /*  Hardcoded liftover directory in dragen 4.2 */\n    return \"/opt/edico/liftover/\";\n}\nfunction get_mask_dir() {\n    /*  Hardcoded mask directory in dragen 4.2 */\n    return \"/opt/edico/fasta_mask/\";\n}\nfunction get_ref_scratch_dir(reference_name) {\n    /*  We get the reference scratch directory as a combination of */\n    /*  the dragen scratch mount and the reference name */\n    return get_scratch_mount() + reference_name + \"/\";\n}\nfunction get_ora_intermediate_output_dir() {\n    return get_scratch_mount() + \"ora-outputs/\";\n}\nfunction generate_ora_mv_files_script(fastq_list_rows, input_directory, output_directory) {\n    /*\n    Generate the shell script with a list of echo commands to write a new fastq list csv to stdout, however\n    the fastq list csv contains the ora files as outputs instead\n    */\n    var ora_mv_files_script = \"#!/usr/bin/env bash\\n\\n\";\n    ora_mv_files_script += \"# Exit on failure\\n\";\n    ora_mv_files_script += \"set -euo pipefail\\n\\n\";\n    ora_mv_files_script += \"# Get fastq ora paths\\n\";\n    ora_mv_files_script += \"FASTQ_ORA_OUTPUT_PATHS=(\\n\";\n    /*  Iterate over all files */\n    for (var _i = 0, fastq_list_rows_3 = fastq_list_rows; _i < fastq_list_rows_3.length; _i++) {\n        var fastq_list_row = fastq_list_rows_3[_i];\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            /*  Add relative path of read 1 */\n            ora_mv_files_script += \"  \\\"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            /*  Add relative path of read 2 */\n            ora_mv_files_script += \"  \\\"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n    }\n    /*  Complete the bash array */\n    ora_mv_files_script += \")\\n\\n\";\n    ora_mv_files_script += \"# Move all ora files to the final output directory\\n\";\n    ora_mv_files_script += \"for fastq_ora_output_path in \\\"${FASTQ_ORA_OUTPUT_PATHS[@]}\\\"; do\\n\";\n    ora_mv_files_script += \"  fastq_ora_scratch_path=\\\"\".concat(get_ora_intermediate_output_dir(), \"$(basename \\\"${fastq_ora_output_path}\\\")\\\"\\n\");\n    ora_mv_files_script += \"  mkdir -p \\\"$(dirname \\\"\".concat(output_directory, \"/${fastq_ora_output_path}\\\")\\\"\\n\");\n    ora_mv_files_script += \"  rsync --archive \\\\\\n\";\n    ora_mv_files_script += \"    --remove-source-files \\\\\\n\";\n    ora_mv_files_script += \"    --include \\\"$(basename \\\"${fastq_ora_output_path}\\\")\\\" \\\\\\n\";\n    ora_mv_files_script += \"    --exclude \\\"*\\\" \\\\\\n\";\n    ora_mv_files_script += \"    \\\"$(dirname \\\"${fastq_ora_scratch_path}\\\")/\\\" \\\\\\n\";\n    ora_mv_files_script += \"    \\\"$(dirname \\\"\".concat(output_directory, \"/${fastq_ora_output_path}\\\")/\\\"\\n\");\n    ora_mv_files_script += \"done\\n\\n\";\n    ora_mv_files_script += \"# Transfer all other files\\n\";\n    ora_mv_files_script += \"mkdir -p \\\"\".concat(output_directory, \"/ora-logs/\\\"\\n\");\n    ora_mv_files_script += \"mv \\\"\".concat(get_ora_intermediate_output_dir(), \"\\\" \\\"\").concat(output_directory, \"/ora-logs/compression/\\\"\\n\");\n    return {\n        class:\"File\",\n        basename:get_ora_mv_files_script_path(),\n        contents:ora_mv_files_script\n    };\n}\nfunction generate_fastq_gz_md5sum_files_script(fastq_list_rows, input_directory) {\n    /*\n    Generate the fastq gzip md5sum files script command, results are printed to stdout\n    */\n    var get_md5sum_fastq_gz_script = \"#!/usr/bin/env bash\\n\\n\";\n    get_md5sum_fastq_gz_script += \"# Exit on failure\\n\";\n    get_md5sum_fastq_gz_script += \"set -euo pipefail\\n\\n\";\n    /*  Initialise the bash array */\n    get_md5sum_fastq_gz_script += \"# Get fastq gz paths\\n\";\n    get_md5sum_fastq_gz_script += \"FASTQ_GZ_PATHS=(\\n\";\n    /*  Iterate over all files */\n    for (var _i = 0, fastq_list_rows_4 = fastq_list_rows; _i < fastq_list_rows_4.length; _i++) {\n        var fastq_list_row = fastq_list_rows_4[_i];\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            /*  Add relative path of read 1 */\n            get_md5sum_fastq_gz_script += \"  \\\"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", ''), \"\\\" \\\\\\n\");\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            get_md5sum_fastq_gz_script += \"  \\\"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", ''), \"\\\" \\\\\\n\");\n        }\n    }\n    /*  Complete the bash array */\n    get_md5sum_fastq_gz_script += \")\\n\\n\";\n    /*  Build the for loop */\n    get_md5sum_fastq_gz_script += \"# Generate md5sums for the input fastq gz files\\n\";\n    get_md5sum_fastq_gz_script += \"for fastq_gz_path in \\\"${FASTQ_GZ_PATHS[@]}\\\"; do\\n\";\n    get_md5sum_fastq_gz_script += \"  full_input_path=\\\"\".concat(input_directory.path, \"/${fastq_gz_path}\\\"\\n\");\n    get_md5sum_fastq_gz_script += \"  md5sum \\\"${full_input_path}\\\" | sed \\\"s%${full_input_path}%${fastq_gz_path}%\\\"\\n\";\n    get_md5sum_fastq_gz_script += \"done\\n\\n\";\n    get_md5sum_fastq_gz_script += \"# Md5sum script complete\\n\";\n    return {\n        class:\"File\",\n        basename:get_fastq_gz_md5sum_files_script_path(),\n        contents:get_md5sum_fastq_gz_script\n    };\n}\nfunction generate_fastq_gz_file_sizes_script(fastq_list_rows, input_directory) {\n    /*\n    Generate the fastq gzip get files sizes, results are printed to stdout\n    */\n    var get_filesizes_fastq_gz_script = \"#!/usr/bin/env bash\\n\\n\";\n    get_filesizes_fastq_gz_script += \"# Exit on failure\\n\";\n    get_filesizes_fastq_gz_script += \"set -euo pipefail\\n\\n\";\n    /*  Initialise the bash array */\n    get_filesizes_fastq_gz_script += \"# Get fastq gz paths\\n\";\n    get_filesizes_fastq_gz_script += \"FASTQ_GZ_PATHS=(\\n\";\n    /*  Iterate over all files */\n    for (var _i = 0, fastq_list_rows_5 = fastq_list_rows; _i < fastq_list_rows_5.length; _i++) {\n        var fastq_list_row = fastq_list_rows_5[_i];\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            /*  Add relative path of read 1 */\n            get_filesizes_fastq_gz_script += \"  \\\"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", ''), \"\\\" \\\\\\n\");\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            get_filesizes_fastq_gz_script += \"  \\\"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", ''), \"\\\" \\\\\\n\");\n        }\n    }\n    /*  Complete the bash array */\n    get_filesizes_fastq_gz_script += \")\\n\\n\";\n    /*  Build the for loop */\n    /*  Initialise the tsv */\n    get_filesizes_fastq_gz_script += \"# Initialise the tsv header\\n\";\n    get_filesizes_fastq_gz_script += \"echo \\\"fastqPath\\tfileSizeInBytes\\\"\\n\\n\";\n    get_filesizes_fastq_gz_script += \"# Generate file sizes for the input fastq gz files\\n\";\n    get_filesizes_fastq_gz_script += \"for fastq_gz_path in \\\"${FASTQ_GZ_PATHS[@]}\\\"; do\\n\";\n    get_filesizes_fastq_gz_script += \"  file_size=\\\"$(wc -c < \\\"\".concat(input_directory.path, \"/${fastq_gz_path}\\\")\\\"\\n\");\n    get_filesizes_fastq_gz_script += \"  echo \\\"${fastq_gz_path}\\t${file_size}\\\"\\n\";\n    get_filesizes_fastq_gz_script += \"done\\n\\n\";\n    get_filesizes_fastq_gz_script += \"# file size script complete\\n\";\n    return {\n        class:\"File\",\n        basename:get_fastq_gz_file_sizes_script_path(),\n        contents:get_filesizes_fastq_gz_script\n    };\n}\nfunction generate_fastq_ora_md5sum_files_script(fastq_list_rows, input_directory, output_directory) {\n    /*\n    Generate the fastq ora md5sum files script command, results are printed to stdout\n    */\n    var get_md5sum_fastq_ora_script = \"#!/usr/bin/env bash\\n\\n\";\n    get_md5sum_fastq_ora_script += \"# Exit on failure\\n\";\n    get_md5sum_fastq_ora_script += \"set -euo pipefail\\n\\n\";\n    /*  Initialise the bash array */\n    get_md5sum_fastq_ora_script += \"# Get fastq ora paths\\n\";\n    get_md5sum_fastq_ora_script += \"FASTQ_ORA_OUTPUT_PATHS=(\\n\";\n    /*  Iterate over all files */\n    for (var _i = 0, fastq_list_rows_6 = fastq_list_rows; _i < fastq_list_rows_6.length; _i++) {\n        var fastq_list_row = fastq_list_rows_6[_i];\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            /*  Add relative path of read 1 */\n            get_md5sum_fastq_ora_script += \"  \\\"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            get_md5sum_fastq_ora_script += \"  \\\"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n    }\n    /*  Complete the bash array */\n    get_md5sum_fastq_ora_script += \")\\n\\n\";\n    get_md5sum_fastq_ora_script += \"# Generate md5sums for the input fastq ora files\\n\";\n    get_md5sum_fastq_ora_script += \"for fastq_ora_output_path in \\\"${FASTQ_ORA_OUTPUT_PATHS[@]}\\\"; do\\n\";\n    get_md5sum_fastq_ora_script += \"  fastq_ora_scratch_path=\\\"\".concat(output_directory, \"$(basename \\\"${fastq_ora_output_path}\\\")\\\"\\n\");\n    get_md5sum_fastq_ora_script += \"  md5sum \\\"${fastq_ora_scratch_path}\\\" | sed \\\"s%${fastq_ora_scratch_path}%${fastq_ora_output_path}%\\\"\\n\";\n    get_md5sum_fastq_ora_script += \"done\\n\\n\";\n    get_md5sum_fastq_ora_script += \"# Md5sum script complete\\n\";\n    return {\n        class:\"File\",\n        basename:get_fastq_ora_md5sum_files_script_path(),\n        contents:get_md5sum_fastq_ora_script\n    };\n}\nfunction generate_fastq_ora_file_sizes_script(fastq_list_rows, input_directory, output_directory) {\n    /*\n    Generate the fastq ora file size files script command, results are printed to stdout\n    */\n    var get_filesizes_fastq_ora_script = \"#!/usr/bin/env bash\\n\\n\";\n    get_filesizes_fastq_ora_script += \"# Exit on failure\\n\";\n    get_filesizes_fastq_ora_script += \"set -euo pipefail\\n\\n\";\n    /*  Initialise the bash array */\n    get_filesizes_fastq_ora_script += \"# Get fastq ora paths\\n\";\n    get_filesizes_fastq_ora_script += \"FASTQ_ORA_OUTPUT_PATHS=(\\n\";\n    /*  Iterate over all files */\n    for (var _i = 0, fastq_list_rows_7 = fastq_list_rows; _i < fastq_list_rows_7.length; _i++) {\n        var fastq_list_row = fastq_list_rows_7[_i];\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            /*  Add relative path of read 1 */\n            get_filesizes_fastq_ora_script += \"  \\\"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            get_filesizes_fastq_ora_script += \"  \\\"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n    }\n    /*  Complete the bash array */\n    get_filesizes_fastq_ora_script += \")\\n\\n\";\n    get_filesizes_fastq_ora_script += \"# Initialise the tsv header\\n\";\n    get_filesizes_fastq_ora_script += \"echo \\\"fastqPath\\tfileSizeInBytes\\\"\\n\\n\";\n    get_filesizes_fastq_ora_script += \"# Generate file sizes for the output fastq ora files\\n\";\n    get_filesizes_fastq_ora_script += \"for fastq_ora_output_path in \\\"${FASTQ_ORA_OUTPUT_PATHS[@]}\\\"; do\\n\";\n    get_filesizes_fastq_ora_script += \"  fastq_ora_scratch_path=\\\"\".concat(output_directory, \"$(basename \\\"${fastq_ora_output_path}\\\")\\\"\\n\");\n    get_filesizes_fastq_ora_script += \"  file_size=\\\"$(wc -c < \\\"${fastq_ora_scratch_path}\\\")\\\"\\n\";\n    get_filesizes_fastq_ora_script += \"  echo \\\"${fastq_ora_output_path}\\t${file_size}\\\"\\n\";\n    get_filesizes_fastq_ora_script += \"done\\n\\n\";\n    get_filesizes_fastq_ora_script += \"# ORA script complete\\n\";\n    return {\n        class:\"File\",\n        basename:get_fastq_ora_file_sizes_script_path(),\n        contents:get_filesizes_fastq_ora_script\n    };\n}\nfunction generate_new_fastq_list_csv_script(fastq_list_rows, input_directory) {\n    /*\n    Generate the shell script with a list of mv commands to move the output files from the scratch space to their\n    original location in the working directory\n    */\n    var new_fastq_list_csv_script = \"#!/usr/bin/env bash\\n\\n\";\n    new_fastq_list_csv_script += \"set -euo pipefail\\n\\n\";\n    new_fastq_list_csv_script += \"# Generate a new fastq list csv script\\n\";\n    new_fastq_list_csv_script += \"# Initialise header\\n\";\n    new_fastq_list_csv_script += \"echo \\\"RGID,RGLB,RGSM,Lane,Read1File,Read2File\\\"\\n\";\n    for (var _i = 0, fastq_list_rows_8 = fastq_list_rows; _i < fastq_list_rows_8.length; _i++) {\n        var fastq_list_row = fastq_list_rows_8[_i];\n        /*  Initialise echo line */\n        var echo_line = \"echo \\\"\".concat(fastq_list_row.rgid, \",\").concat(fastq_list_row.rglb, \",\").concat(fastq_list_row.rgsm, \",\").concat(fastq_list_row.lane, \",\");\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            echo_line += \"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \",\");\n        }\n        else {\n            echo_line += ',';\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            echo_line += \"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"));\n        }\n        /*  Finish off echo line */\n        echo_line += \"\\\"\\n\";\n        new_fastq_list_csv_script += echo_line;\n    }\n    return {\n        class:\"File\",\n        basename:get_new_fastq_list_csv_script_path(),\n        contents:new_fastq_list_csv_script\n    };\n}\nfunction find_fastq_files_in_directory_recursively_with_regex(input_dir) {\n    var _a;\n    /*\n    Initialise the output file object\n    */\n    var read_1_file_list = [];\n    var read_2_file_list = [];\n    var output_file_objs = [];\n    var fastq_file_regex = /\\.fastq\\.gz$/;\n    var r1_fastq_file_regex = /_R1_001\\.fastq\\.gz$/;\n    var r2_fastq_file_regex = /_R2_001\\.fastq\\.gz$/;\n    /*\n    Check input_dir is a directory and has a listing\n    */\n    if (input_dir.class === undefined || input_dir.class !== \"Directory\") {\n        throw new Error(\"Could not confirm that the first argument was a directory\");\n    }\n    if (input_dir.listing === undefined || input_dir.listing === null) {\n        throw new Error(\"Could not collect listing from directory \\\"\".concat(input_dir.basename, \"\\\"\"));\n    }\n    /*\n    Collect listing as a variable\n    */\n    var input_listing = input_dir.listing;\n    /*\n    Iterate through the file listing\n    */\n    for (var _i = 0, input_listing_1 = input_listing; _i < input_listing_1.length; _i++) {\n        var listing_item = input_listing_1[_i];\n        if (listing_item.class === \"File\" && fastq_file_regex.test(listing_item.basename)) {\n            /*\n            Got the file of interest and the file basename matches the file regex\n            */\n            /*\n            Check if the file is read 1 or read 2\n            */\n            if (r1_fastq_file_regex.test(listing_item.basename)) {\n                read_1_file_list.push(listing_item);\n            }\n            if (r2_fastq_file_regex.test(listing_item.basename)) {\n                read_2_file_list.push(listing_item);\n            }\n        }\n        if (listing_item.class === \"Directory\") {\n            var subdirectory_list = listing_item;\n            try {\n                /*  Consider that the file might not be in this subdirectory and that is okay */\n                output_file_objs.push.apply(output_file_objs, find_fastq_files_in_directory_recursively_with_regex(subdirectory_list));\n            }\n            catch (error) {\n                /*  Dont need to report an error though, just continue */\n            }\n        }\n    }\n    /*  Iterate over all the read 1 files and try to find a matching read 2 file */\n    for (var _b = 0, read_1_file_list_1 = read_1_file_list; _b < read_1_file_list_1.length; _b++) {\n        var read_1_file = read_1_file_list_1[_b];\n        var read_2_file = undefined;\n        for (var _c = 0, read_2_file_list_1 = read_2_file_list; _c < read_2_file_list_1.length; _c++) {\n            var read_2_file_candidate = read_2_file_list_1[_c];\n            if (((_a = read_1_file.basename) === null || _a === void 0 ? void 0 :_a.replace(\"R1_001.fastq.gz\", \"R2_001.fastq.gz\")) === read_2_file_candidate.basename) {\n                read_2_file = read_2_file_candidate;\n                break;\n            }\n        }\n        output_file_objs.push({ read1obj:read_1_file, read2obj:read_2_file });\n    }\n    /*  Return the output file object */\n    return output_file_objs;\n}\nfunction get_rgsm_value_from_fastq_file_name(fastq_file_name) {\n    /*  Get the RGID value from the fastq file name */\n    var rgid_regex = /(.+?)(?:_S\\d+)?(?:_L00\\d)?_R[12]_001\\.fastq\\.gz$/;\n    var rgid_expression = rgid_regex.exec(fastq_file_name);\n    if (rgid_expression === null) {\n        throw new Error(\"Could not get rgid from \".concat(fastq_file_name));\n    }\n    return rgid_expression[1];\n}\nfunction get_lane_value_from_fastq_file_name(fastq_file_name) {\n    /*  Get the lane value from the fastq file name */\n    var lane_regex = /(?:.+?)(?:_S\\d+)?_L00(\\d)_R[12]_001\\.fastq\\.gz$/;\n    var lane_expression = lane_regex.exec(fastq_file_name);\n    if (lane_expression === null) {\n        return 1;\n    }\n    else {\n        console.log(lane_expression);\n        return parseInt(lane_expression[1]);\n    }\n}\nfunction generate_ora_mount_points(input_run, output_directory_path, sample_id_list) {\n    /*\n    Three main parts\n\n    1. Collect the fastq files\n    2. For each fastq file pair, generate the rgid, rgsm, rglb and lane attributes as necessary to make a fastq list row\n    3. Generate the fastq list csv file\n    */\n    /*  Collect the fastq files */\n    var fastq_files_pairs = find_fastq_files_in_directory_recursively_with_regex(input_run);\n    /*  For each fastq file pair, generate the rgid, rgsm, rglb and lane attributes as necessary */\n    var fastq_list_rows = [];\n    for (var _i = 0, fastq_files_pairs_1 = fastq_files_pairs; _i < fastq_files_pairs_1.length; _i++) {\n        var fastq_files_pair = fastq_files_pairs_1[_i];\n        var rgsm_value = get_rgsm_value_from_fastq_file_name(fastq_files_pair.read1obj.basename);\n        /*  Skip fastq list pair if sample_id_list is defined and the rgsm_value is not in the list */\n        if (sample_id_list !== undefined && sample_id_list !== null && sample_id_list !== \"\" && sample_id_list.indexOf(rgsm_value) === -1) {\n            continue;\n        }\n        /*  Remove undetermined files from the list of fastqs to process (they are often empty) */\n        if (rgsm_value === \"Undetermined\") {\n            continue;\n        }\n        /*  Check if we have the size attribute and if so check if it is greater than 0 */\n        if (fastq_files_pair.read1obj.size !== null && fastq_files_pair.read1obj.size !== undefined && fastq_files_pair.read1obj.size == 0) {\n            continue;\n        }\n        /*  Repeat the condition for read 2 although also ensure that read 2 is also actually defined */\n        if (fastq_files_pair.read2obj !== undefined && fastq_files_pair.read2obj !== null) {\n            if (fastq_files_pair.read2obj.size !== null && fastq_files_pair.read2obj.size !== undefined && fastq_files_pair.read2obj.size == 0) {\n                continue;\n            }\n        }\n        var lane_value = get_lane_value_from_fastq_file_name(fastq_files_pair.read1obj.basename);\n        var fastq_list_row = {\n            rgid:lane_value.toString() + '.' + rgsm_value,\n            rgsm:rgsm_value,\n            rglb:\"UnknownLibrary\",\n            lane:lane_value,\n            read_1:fastq_files_pair.read1obj,\n            read_2:fastq_files_pair.read2obj\n        };\n        fastq_list_rows.push(fastq_list_row);\n    }\n    /*  Initialise dirent */\n    var e = [];\n    /*  Generate the fastq list csv file */\n    e.push({\n        \"entryname\":get_fastq_list_csv_path(),\n        \"entry\":generate_fastq_list_csv(fastq_list_rows)\n    });\n    /*  Generate the script to then move the files from the scratch space to the working directory */\n    e.push({\n        \"entryname\":get_ora_mv_files_script_path(),\n        \"entry\":generate_ora_mv_files_script(fastq_list_rows, input_run, output_directory_path)\n    });\n    /*  Generate the script to generate the new output fastq list csv */\n    e.push({\n        \"entryname\":get_new_fastq_list_csv_script_path(),\n        \"entry\":generate_new_fastq_list_csv_script(fastq_list_rows, input_run)\n    });\n    /*  Generate the script to generate the md5sums of the input gzipped fastq files */\n    e.push({\n        \"entryname\":get_fastq_gz_md5sum_files_script_path(),\n        \"entry\":generate_fastq_gz_md5sum_files_script(fastq_list_rows, input_run)\n    });\n    /*  Generate the script to generate the filesizes of the input gzipped fastq files */\n    e.push({\n        \"entryname\":get_fastq_gz_file_sizes_script_path(),\n        \"entry\":generate_fastq_gz_file_sizes_script(fastq_list_rows, input_run)\n    });\n    /*  Generate the script to generate the md5sums of the output ora fastq files */\n    e.push({\n        \"entryname\":get_fastq_ora_md5sum_files_script_path(),\n        \"entry\":generate_fastq_ora_md5sum_files_script(fastq_list_rows, input_run, get_ora_intermediate_output_dir())\n    });\n    /*  Generate the script to generate the filesizes of the output ora fastq files */\n    e.push({\n        \"entryname\":get_fastq_ora_file_sizes_script_path(),\n        \"entry\":generate_fastq_ora_file_sizes_script(fastq_list_rows, input_run, get_ora_intermediate_output_dir())\n    });\n    /*  Return the dirent */\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\n",
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Functions */\nfunction is_not_null(input_obj) {\n    /*\n    Determine if input object is defined and is not null\n    */\n    return !(input_obj === null || input_obj === undefined);\n}\nfunction get_attribute_from_optional_input(input_object, attribute) {\n    /*\n    Get attribute from optional input -\n    If input is not defined, then return null\n    */\n    if (input_object === null || input_object === undefined) {\n        return null;\n    }\n    else {\n        return get_optional_attribute_from_object(input_object, attribute);\n    }\n}\nfunction get_optional_attribute_from_object(input_object, attribute) {\n    /*\n    Get attribute from object, if attribute is not defined return null\n    Assume the input object is an object of key value pairs where we know the key is of type string\n    stackoverflow.com/questions/56833469/typescript-error-ts7053-element-implicitly-has-an-any-type\n    */\n    if (input_object.hasOwnProperty(attribute)) {\n        return input_object[attribute];\n    }\n    else {\n        return null;\n    }\n}\nfunction get_bool_value_as_str(input_bool) {\n    if (is_not_null(input_bool) && input_bool) {\n        return \"true\";\n    }\n    else {\n        return \"false\";\n    }\n}\nfunction boolean_to_int(input_bool) {\n    if (is_not_null(input_bool) && String(input_bool).toLowerCase() === \"true\") {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nfunction get_optional_attribute_from_multi_type_input_object(object, attribute) {\n    /*\n    Get attribute from optional input\n    */\n    if (object === null || object === undefined) {\n        return null;\n    }\n    else if (typeof object === \"object\") {\n        /*  Get attribute from optional input */\n        return get_attribute_from_optional_input(object, attribute);\n    }\n    else {\n        /*  Object is likely actually a str */\n        return object;\n    }\n}\nfunction get_source_a_or_b(input_a, input_b) {\n    /*\n    Get the first input parameter if it is not null\n    Otherwise return the second parameter\n    Otherwise return null\n    */\n    if (is_not_null(input_a)) {\n        return input_a;\n    }\n    else if (is_not_null(input_b)) {\n        return input_b;\n    }\n    else {\n        return null;\n    }\n}\nfunction get_first_non_null_input(inputs) {\n    /*\n    Get first element of the array that is not null\n    */\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n        var input_element = inputs_1[_i];\n        if (is_not_null(input_element)) {\n            return input_element;\n        }\n    }\n    return null;\n}\nfunction get_attribute_list_from_object_list(obj_list, attribute) {\n    /*\n    Get attribute from list of objects\n    If an object is null, it is not included in the return list\n    */\n    return obj_list.filter(function (x) { return x !== null; }).map(function (x) { return get_optional_attribute_from_object(x, attribute); });\n}\nfunction get_str_list_as_bash_array(input_list, item_wrap) {\n    /*\n    Convert a list of strings to a bash array, if the list is not defined return null\n    */\n    if (input_list === null) {\n        return null;\n    }\n    if (item_wrap === null) {\n        return \"( \".concat(input_list.map(function (x) { return \"'\".concat(item_wrap).concat(x).concat(item_wrap, \"'\"); }).join(' '), \" )\");\n    }\n    return \"( \".concat(input_list.map(function (x) { return \"'\".concat(x, \"'\"); }).join(' '), \" )\");\n}\nfunction get_object_attribute_list_as_bash_array(obj_list, attribute) {\n    /*\n    Get attribute from list of objects and convert to a bash array\n    Do not include null values in the array\n    */\n    return get_str_list_as_bash_array(get_attribute_list_from_object_list(obj_list, attribute).filter(function (x) { return x !== null; }));\n}\n"
          ],
          "class": "InlineJavascriptRequirement"
        },
        {
          "tmpdirMin": "${\n  /* 1 Tb */\n  return Math.pow(2, 20);\n}\n",
          "class": "ResourceRequirement"
        },
        {
          "types": [
            {
              "type": "record",
              "name": "#fastq-list-row__1.0.0.yaml/fastq-list-row",
              "fields": [
                {
                  "label": "lane",
                  "doc": "The lane that the sample was run on\n",
                  "type": "int",
                  "name": "#fastq-list-row__1.0.0.yaml/fastq-list-row/lane"
                },
                {
                  "label": "read 1",
                  "doc": "The path to R1 of a sample\n",
                  "type": [
                    "File",
                    "string"
                  ],
                  "streamable": true,
                  "name": "#fastq-list-row__1.0.0.yaml/fastq-list-row/read_1"
                },
                {
                  "label": "read 2",
                  "doc": "The path to R2 of a sample\n",
                  "type": [
                    "null",
                    "File",
                    "string"
                  ],
                  "streamable": true,
                  "name": "#fastq-list-row__1.0.0.yaml/fastq-list-row/read_2"
                },
                {
                  "label": "rgid",
                  "doc": "The read-group id of the sample.\nOften an index\n",
                  "type": "string",
                  "name": "#fastq-list-row__1.0.0.yaml/fastq-list-row/rgid"
                },
                {
                  "label": "rglb",
                  "doc": "The read-group library of the sample.\n",
                  "type": "string",
                  "name": "#fastq-list-row__1.0.0.yaml/fastq-list-row/rglb"
                },
                {
                  "label": "rgsm",
                  "doc": "The read-group sample name\n",
                  "type": "string",
                  "name": "#fastq-list-row__1.0.0.yaml/fastq-list-row/rgsm"
                }
              ]
            }
          ],
          "class": "SchemaDefRequirement"
        }
      ],
      "baseCommand": [
        "bash"
      ],
      "arguments": [
        {
          "valueFrom": "$(get_script_path())",
          "position": -1
        },
        {
          "prefix": "--enable-variant-caller=",
          "separate": false,
          "valueFrom": "true"
        },
        {
          "prefix": "--intermediate-results-dir=",
          "separate": false,
          "valueFrom": "$(get_intermediate_results_dir())"
        }
      ],
      "inputs": [
        {
          "label": "bam input",
          "doc": "Input a normal BAM file for the variant calling stage\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--bam-input=",
            "separate": false
          },
          "secondaryFiles": [
            {
              "pattern": ".bai",
              "required": true
            }
          ],
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/bam_input"
        },
        {
          "label": "cnv enable self normalization",
          "doc": "Enable CNV self normalization.\nSelf Normalization requires that the DRAGEN hash table be generated with the enable-cnv=true option.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--cnv-enable-self-normalization=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/cnv_enable_self_normalization"
        },
        {
          "label": "cram input",
          "doc": "Input a normal CRAM file for the variant calling stage\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--cram-input=",
            "separate": false
          },
          "secondaryFiles": [
            {
              "pattern": ".crai",
              "required": true
            }
          ],
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/cram_input"
        },
        {
          "label": "cram reference",
          "doc": "Path to the reference fasta file for the CRAM input.\nRequired only if the input is a cram file AND not the reference in the tarball\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--cram-reference=",
            "separate": false
          },
          "secondaryFiles": [
            {
              "pattern": ".fai",
              "required": true
            }
          ],
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/cram_reference"
        },
        {
          "label": "dbsnp annotation",
          "doc": "In Germline, Tumor-Normal somatic, or Tumor-Only somatic modes,\nDRAGEN can look up variant calls in a dbSNP database and add annotations for any matches that it finds there.\nTo enable the dbSNP database search, set the --dbsnp option to the full path to the dbSNP database\nVCF or .vcf.gz file, which must be sorted in reference order.\n",
          "type": [
            "null",
            "File"
          ],
          "secondaryFiles": [
            {
              "pattern": ".tbi",
              "required": true
            }
          ],
          "inputBinding": {
            "prefix": "--dbsnp=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/dbsnp_annotation"
        },
        {
          "label": "deduplicate minimum quality",
          "doc": "Specifies the Phred quality score below which a base should be excluded from the quality score\ncalculation used for choosing among duplicate reads.\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--dedup-min-qual=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/dedup_min_qual"
        },
        {
          "label": "enable cnv calling",
          "doc": "Enable CNV processing in the DRAGEN Host Software.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-cnv=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/enable_cnv"
        },
        {
          "label": "enable duplicate marking",
          "doc": "Mark identical alignments as duplicates\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-duplicate-marking=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/enable_duplicate_marking"
        },
        {
          "label": "enable hla",
          "doc": "Enable HLA typing by setting --enable-hla flag to true\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-hla=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/enable_hla"
        },
        {
          "label": "enable map align",
          "doc": "Enabled by default since --enable-variant-caller option is set to true.\nSet this value to false if using bam_input\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-map-align=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/enable_map_align"
        },
        {
          "label": "enable map align output",
          "doc": "Do you wish to have the output bam files present\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-map-align-output=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/enable_map_align_output"
        },
        {
          "label": "enable pgx",
          "doc": "Enable star allele caller. This also turns on other PGx callers such as CYP2D6, CYP2B6\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-pgx=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/enable_pgx"
        },
        {
          "label": "enable sort",
          "doc": "True by default, only set this to false if using --bam-input parameter\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-sort=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/enable_sort"
        },
        {
          "label": "enable sv",
          "doc": "Enable/disable structural variant\ncaller. Default is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-sv=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/enable_sv"
        },
        {
          "label": "enable targeted",
          "doc": "Enable targeted variant calling for repetitive regions\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-targeted=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/enable_targeted"
        },
        {
          "label": "fastq list",
          "doc": "CSV file that contains a list of FASTQ files\nto process.\nRead1File and Read2File may be presigned urls or use this in conjunction with\nthe fastq_list_mount_paths inputs.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "loadContents": true,
            "prefix": "--fastq-list=",
            "separate": false,
            "valueFrom": "$(get_fastq_list_csv_path())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/fastq_list"
        },
        {
          "label": "fastq list rows",
          "doc": "Alternative to providing a file, one can instead provide a list of 'fastq-list-row' objects\n",
          "type": [
            "null",
            {
              "type": "array",
              "items": "#fastq-list-row__1.0.0.yaml/fastq-list-row"
            }
          ],
          "inputBinding": {
            "prefix": "--fastq-list=",
            "separate": false,
            "valueFrom": "$(get_fastq_list_csv_path())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/fastq_list_rows"
        },
        {
          "label": "hla allele frequency file",
          "doc": "Use the population-level HLA allele frequency file to break ties if one or more HLA allele produces the same or similar results.\nThe input HLA allele frequency file must be in CSV format and contain the HLA alleles and the occurrence frequency in population.\nIf --hla-allele-frequency-file is not specified, DRAGEN automatically uses hla_classI_allele_frequency.csv from /opt/edico/config/.\nPopulation-level allele frequencies can be obtained from the Allele Frequency Net database.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--hla-allele-frequency-file=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/hla_allele_frequency_file"
        },
        {
          "label": "hla bed file",
          "doc": "Use the HLA region BED input file to specify the region to extract HLA reads from.\nDRAGEN HLA Caller parses the input file for regions within the BED file, and then\nextracts reads accordingly to align with the HLA allele reference.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--hla-bed-file=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/hla_bed_file"
        },
        {
          "label": "hla enable class 2",
          "doc": "Enable class II HLA typing by setting --hla-enable-class-2 flag to true\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--hla-enable-class-2=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/hla_enable_class_2"
        },
        {
          "label": "hla min reads",
          "doc": "Set the minimum number of reads to align to HLA alleles to ensure sufficient coverage and perform HLA typing.\nThe default value is 1000 and suggested for WES samples. If using samples with less coverage, you can use a\nlower threshold value.\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--hla-min-reads=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/hla_min_reads"
        },
        {
          "label": "hla reference file",
          "doc": "Use the HLA allele reference file to specify the reference alleles to align against.\nThe input HLA reference file must be in FASTA format and contain the protein sequence separated into exons.\nIf --hla-reference-file is not specified, DRAGEN uses hla_classI_ref_freq.fasta from /opt/edico/config/.\nThe reference HLA sequences are obtained from the IMGT/HLA database.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--hla-reference-file=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/hla_reference_file"
        },
        {
          "label": "hla tiebreaker threshold",
          "doc": "If more than one allele has a similar number of reads aligned and there is not a clear indicator for the best allele,\nthe alleles are considered as ties. The HLA Caller places the tied alleles into a candidate set for tie breaking based\non the population allele frequency. If an allele has more than the specified fraction of reads aligned (normalized to\nthe top hit), then the allele is included into the candidate set for tie breaking. The default value is 0.97.\n",
          "type": [
            "null",
            "float"
          ],
          "inputBinding": {
            "prefix": "--hla-tiebreaker-threshold=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/hla_tiebreaker_threshold"
        },
        {
          "label": "hla zygosity threshold",
          "doc": "If the minor allele at a given locus has fewer reads mapped than a fraction of the read count of the major allele,\nthen the HLA Caller infers homozygosity for the given HLA-I gene. You can use this option to specify the fraction value.\nThe default value is 0.15.\n",
          "type": [
            "null",
            "float"
          ],
          "inputBinding": {
            "prefix": "--hla zygosity threshold=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/hla_zygosity_threshold"
        },
        {
          "label": "license instance id location",
          "doc": "You may wish to place your own in.\nOptional value, default set to /opt/instance-identity\nwhich is a path inside the dragen container\n",
          "type": [
            "null",
            "File",
            "string"
          ],
          "default": "/opt/instance-identity",
          "inputBinding": {
            "prefix": "--lic-instance-id-location=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/lic_instance_id_location"
        },
        {
          "label": "output directory",
          "doc": "The directory where all output files are placed\n",
          "type": "string",
          "inputBinding": {
            "prefix": "--output-directory=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/output_directory"
        },
        {
          "label": "output file prefix",
          "doc": "The prefix given to all output files\n",
          "type": "string",
          "inputBinding": {
            "prefix": "--output-file-prefix=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/output_file_prefix"
        },
        {
          "label": "output format",
          "doc": "For mapping and aligning, the output is sorted and compressed into BAM format by default before saving to disk.\nYou can control the output format from the map/align stage with the --output-format <SAM|BAM|CRAM> option.\n",
          "type": [
            "null",
            {
              "type": "enum",
              "symbols": [
                "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/output_format/SAM",
                "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/output_format/BAM",
                "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/output_format/CRAM"
              ]
            }
          ],
          "inputBinding": {
            "prefix": "--output-format=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/output_format"
        },
        {
          "label": "qc coverage ignore overlaps",
          "doc": "Set to true to resolve all of the alignments for each fragment and avoid double-counting any\noverlapping bases. This might result in marginally longer run times.\nThis option also requires setting --enable-map-align=true.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--qc-coverage-ignore-overlaps=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/qc_coverage_ignore_overlaps"
        },
        {
          "label": "qc coverage region 1",
          "doc": "Generates coverage region report using bed file 1.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--qc-coverage-region-1=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/qc_coverage_region_1"
        },
        {
          "label": "qc coverage region 2",
          "doc": "Generates coverage region report using bed file 2.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--qc-coverage-region-2=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/qc_coverage_region_2"
        },
        {
          "label": "qc coverage region 3",
          "doc": "Generates coverage region report using bed file 3.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--qc-coverage-region-3=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/qc_coverage_region_3"
        },
        {
          "label": "reference tar",
          "doc": "Path to ref data tarball\n",
          "type": "File",
          "inputBinding": {
            "prefix": "--ref-dir=",
            "separate": false,
            "valueFrom": "$(get_ref_path(self))"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/reference_tar"
        },
        {
          "label": "repeat genotype enable",
          "doc": "Enable DRAGEN repeat expansion detection\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--repeat-genotype-enable=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/repeat_genotype_enable"
        },
        {
          "label": "repeat genotype specs",
          "doc": "Specifies the full path to the JSON file that contains the repeat variant catalog (specification) describing the loci to call.\n--repeat-genotype-specs is required for ExpansionHunter.\nIf the option is not provided,\nDRAGEN attempts to autodetect the applicable catalog file from /opt/edico/repeat-specs/ based on the reference provided.\n",
          "type": [
            "null",
            "File",
            "string"
          ],
          "inputBinding": {
            "prefix": "--repeat-genotype-specs=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/repeat_genotype_specs"
        },
        {
          "label": "repeat genotype use catalog",
          "doc": "The repeat-specification (also called variant catalog) JSON file defines the repeat regions for ExpansionHunter to analyze.\nDefault repeat-specification for some pathogenic and polymorphic repeats are in the /opt/edico/repeat-specs/ directory,\nbased on the reference genome used with DRAGEN. Users can choose between any of the three default repeat-specification files\npackaged with DRAGEN using <default|default_plus_smn|expanded>\n",
          "type": [
            "null",
            {
              "type": "enum",
              "symbols": [
                "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/repeat_genotype_use_catalog/default",
                "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/repeat_genotype_use_catalog/default_plus_smn",
                "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/repeat_genotype_use_catalog/expanded"
              ]
            }
          ],
          "inputBinding": {
            "prefix": "--repeat-genotype-use-catalog=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/repeat_genotype_use_catalog"
        },
        {
          "label": "sample sex",
          "doc": "Specifies the sex of a sample\n",
          "type": [
            "null",
            {
              "type": "enum",
              "symbols": [
                "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sample_sex/none",
                "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sample_sex/auto",
                "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sample_sex/male",
                "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sample_sex/female"
              ]
            }
          ],
          "inputBinding": {
            "prefix": "--sample-sex=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sample_sex"
        },
        {
          "label": "sv call regions bed",
          "doc": "Specifies a BED file containing the set of regions to call.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--sv-call-regions-bed=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sv_call_regions_bed"
        },
        {
          "label": "sv discovery",
          "doc": "Enable SV discovery. This flag can be set to false only when --sv-forcegt-vcf is used.\nWhen set to false, SV discovery is disabled and only the forced genotyping input variants\nare processed. The default is true.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--sv-discovery=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sv_discovery"
        },
        {
          "label": "sv enable liquid tumor mode",
          "doc": "Enable liquid tumor mode.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--sv-enable-liquid-tumor-mode=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sv_enable_liquid_tumor_mode"
        },
        {
          "label": "sv exome",
          "doc": "Set to true to configure the variant caller for targeted sequencing inputs,\nwhich includes disabling high depth filters.\nIn integrated mode, the default is to autodetect targeted sequencing input,\nand in standalone mode the default is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--sv-exome=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sv_exome"
        },
        {
          "label": "sv forcegt vcf",
          "doc": "Specify a VCF of structural variants for forced genotyping. The variants are scored and emitted\nin the output VCF even if not found in the sample data.\nThe variants are merged with any additional variants discovered directly from the sample data.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--sv-forcegt-vcf=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sv_forcegt_vcf"
        },
        {
          "label": "sv output contigs",
          "doc": "Set to true to have assembled contig sequences output in a VCF file. The default is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--sv-output-contigs=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sv_output_contigs"
        },
        {
          "label": "sv region",
          "doc": "Limit the analysis to a specified region of the genome for debugging purposes.\nThis option can be specified multiple times to build a list of regions.\nThe value must be in the format \"chr:startPos-endPos\"..\n",
          "type": [
            "null",
            "string"
          ],
          "inputBinding": {
            "prefix": "--sv-region=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sv_region"
        },
        {
          "label": "sv use overlap pair evidence",
          "doc": "Allow overlapping read pairs to be considered as evidence.\nBy default, DRAGEN uses autodetect on the fraction of overlapping read pairs if <20%.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--sv-use-overlap-pair-evidence=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sv_se_overlap_pair_evidence"
        },
        {
          "label": "sv tin contam tolerance",
          "doc": "Set the Tumor-in-Normal (TiN) contamination tolerance level.\nYou can enter any value between 0-1. The default maximum TiN contamination tolerance is 0.15.\n",
          "type": [
            "null",
            "float"
          ],
          "inputBinding": {
            "prefix": "--sv-tin-contam-tolerance=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/sv_tin_contam_tolerance"
        },
        {
          "label": "vc decoy contigs",
          "doc": "The --vc-decoy-contigs option specifies a comma-separated list of contigs to skip during variant calling.\nThis option can be set in the configuration file.\n",
          "type": [
            "null",
            "string"
          ],
          "inputBinding": {
            "prefix": "--vc-decoy-contigs=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_decoy_contigs"
        },
        {
          "label": "vc emit ref confidence",
          "doc": "A genomic VCF (gVCF) file contains information on variants and positions determined to be homozygous to the reference genome.\nFor homozygous regions, the gVCF file includes statistics that indicate how well reads support the absence of variants or\nalternative alleles. To enable gVCF output, set to GVCF. By default, contiguous runs of homozygous reference calls with similar\nscores are collapsed into blocks (hom-ref blocks). Hom-ref blocks save disk space and processing time of downstream analysis tools.\nDRAGEN recommends using the default mode. To produce unbanded output, set --vc-emit-ref-confidence to BP_RESOLUTION.\n",
          "type": [
            "null",
            "string"
          ],
          "inputBinding": {
            "prefix": "--vc-emit-ref-confidence=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_emit_ref_confidence"
        },
        {
          "label": "vc enable baf",
          "doc": "Enable or disable B-allele frequency output. Enabled by default.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-baf=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_enable_baf"
        },
        {
          "label": "vc enable decoy contigs",
          "doc": "If --vc-enable-decoy-contigs is set to true, variant calls on the decoy contigs are enabled.\nThe default value is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-decoy-contigs=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_enable_decoy_contigs"
        },
        {
          "label": "vc enable gatk acceleration",
          "doc": "If is set to true, the variant caller runs in GATK mode\n(concordant with GATK 3.7 in germline mode and GATK 4.0 in somatic mode).\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-gatk-acceleration=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_enable_gatk_acceleration"
        },
        {
          "label": "vc enable phasing",
          "doc": "The -vc-enable-phasing option enables variants to be phased when possible. The default value is true.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-phasing=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_enable_phasing"
        },
        {
          "label": "vc enable roh",
          "doc": "Enable or disable the ROH caller by setting this option to true or false. Enabled by default for human autosomes only.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-roh=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_enable_roh"
        },
        {
          "label": "vc enable sex chr diploid",
          "doc": "For male samples in germline calling mode, DRAGEN calls potential mosaic variants in non-PAR regions of sex chromosomes.\nA variant is called as mosaic when the allele frequency (FORMAT/AF) is below 85% or if multiple alt alleles are called,\nsuggesting incompatibility with the haploid assumption. The GT field for bi-allelic mosaic variants is \"0/1\",\ndenoting a mixture of reference and alt alleles, as opposed to the regular GT of \"1\" for haploid variants.\nThe GT field for multi-allelic mosaic variants is \"1/2\" in VCF.\nYou can disable the calling of mosaic variants by setting --vc-enable-sex-chr-diploid to false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-sex-chr-diploid=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_enable_sex_chr_diploid"
        },
        {
          "label": "vc enable vcf output",
          "doc": "The -vc-enable-vcf-output option enables VCF file output during a gVCF run. The default value is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-vcf-output=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_enable_vcf_output"
        },
        {
          "label": "vc forcegt vcf",
          "doc": "AGENsupports force genotyping (ForceGT) for Germline SNV variant calling.\nTo use ForceGT, use the --vc-forcegt-vcf option with a list of small variants to force genotype.\nThe input list of small variants can be a .vcf or .vcf.gz file.\n\nThe current limitations of ForceGT are as follows:\n*\tForceGT is supported for Germline SNV variant calling in the V3 mode.\nThe V1, V2, and V2+ modes are not supported.\n*\tForceGT is not supported for Somatic SNV variant calling.\n*\tForceGT variants do not propagate through Joint Genotyping.\n",
          "type": [
            "null",
            "File"
          ],
          "secondaryFiles": [
            {
              "pattern": ".tbi",
              "required": true
            }
          ],
          "inputBinding": {
            "prefix": "--vc-forcegt-vcf=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_forcegt_vcf"
        },
        {
          "label": "vc haploid call af threshold",
          "doc": "Option --vc-haploid-call-af-threshold=<af_threshold> to control threshold.\n* Diploid model is applied to haploid (chrX/Y, non-PAR) regions in male samples.\n* Variants with only one alt allele and with AF>=85% are rewritten to haploid calls.\n* The potential mosaic calls with AF<85% will have GT of \"0/1\" and an INFO tag of\n  \"MOSAIC\" will be added.\n",
          "type": [
            "null",
            "float"
          ],
          "inputBinding": {
            "prefix": "--vc-haploid-call-af-threshold=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_haploid_call_af_threshold"
        },
        {
          "label": "vc hard filter",
          "doc": "DRAGEN provides post-VCF variant filtering based on annotations present in the VCF records.\nHowever, due to the nature of DRAGEN's algorithms, which incorporate the hypothesis of correlated errors\nfrom within the core of variant caller, the pipeline has improved capabilities in distinguishing\nthe true variants from noise, and therefore the dependency on post-VCF filtering is substantially reduced.\nFor this reason, the default post-VCF filtering in DRAGEN is very simple\n",
          "type": [
            "null",
            "string"
          ],
          "inputBinding": {
            "prefix": "--vc-hard-filter=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_hard_filter"
        },
        {
          "label": "vc max reads per active region",
          "doc": "specifies the maximum number of reads covering a given active region.\nDefault is 10000 for the germline workflow\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--vc-max-reads-per-active-region=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_max_reads_per_active_region"
        },
        {
          "label": "vc max reads per raw region",
          "doc": "specifies the maximum number of reads covering a given raw region.\nDefault is 30000 for the germline workflow\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--vc-max-read-per-raw-region=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_max_reads_per_raw_region"
        },
        {
          "label": "vc ml enable recalibration",
          "doc": "DRAGEN employs machine learning-based variant recalibration (DRAGEN-ML) for germline SNV VC.\nVariant calling accuracy is improved using powerful and efficient machine learning techniques that augment the variant caller,\nby exploiting more of the available read and context information that does not easily integrate into the Bayesian processing\nused by the haplotype variant caller.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-ml-enable-recalibration=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_ml_enable_recalibration"
        },
        {
          "label": "vc remove all soft clips",
          "doc": "If is set to true, the variant caller does not use soft clips of reads to determine variants.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-remove-all-soft-clips=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_remove_all_soft_clips"
        },
        {
          "label": "vc roh blacklist bed",
          "doc": "If provided, the ROH caller ignores variants that are contained in any region in the blacklist BED file.\nDRAGEN distributes blacklist files for all popular human genomes and automatically selects a blacklist to\nmatch the genome in use, unless this option is used explicitly select a file.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--vc-roh-blacklist-bed=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_roh_blacklist_bed"
        },
        {
          "label": "vc target bed",
          "doc": "This is an optional command line input that restricts processing of the small variant caller,\ntarget bed related coverage, and callability metrics to regions specified in a BED file.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--vc-target-bed=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_target_bed"
        },
        {
          "label": "vc target bed padding",
          "doc": "This is an optional command line input that can be used to pad all of the target\nBED regions with the specified value.\nFor example, if a BED region is 1:1000-2000 and a padding value of 100 is used,\nit is equivalent to using a BED region of 1:900-2100 and a padding value of 0.\n\nAny padding added to --vc-target-bed-padding is used by the small variant caller\nand by the target bed coverage/callability reports. The default padding is 0.\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--vc-target-bed-padding=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_target_bed_padding"
        },
        {
          "label": "vc target coverage",
          "doc": "The --vc-target-coverage option specifies the target coverage for down-sampling.\nThe default value is 500 for germline mode and 50 for somatic mode.\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--vc-target-coverage=",
            "separate": false
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/vc_target_coverage"
        }
      ],
      "outputs": [
        {
          "label": "dragen bam out",
          "doc": "The output bam file, exists only if --enable-map-align-output is set to true\n",
          "type": [
            "null",
            "File"
          ],
          "outputBinding": {
            "glob": "$(inputs.output_directory)/$(inputs.output_file_prefix).bam"
          },
          "secondaryFiles": [
            {
              "pattern": ".bai",
              "required": null
            }
          ],
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/dragen_bam_out"
        },
        {
          "label": "dragen germline output directory",
          "doc": "The output directory containing all germline output files\n",
          "type": "Directory",
          "outputBinding": {
            "glob": "$(inputs.output_directory)"
          },
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/dragen_germline_output_directory"
        },
        {
          "label": "dragen vcf out",
          "doc": "The output germline vcf file\n",
          "type": [
            "null",
            "File"
          ],
          "outputBinding": {
            "glob": "$(inputs.output_directory)/$(inputs.output_file_prefix).vcf.gz"
          },
          "secondaryFiles": [
            {
              "pattern": ".tbi",
              "required": null
            }
          ],
          "id": "#dragen-germline__4.3.6.cwl/dragen-germline--4.2.4/dragen_vcf_out"
        }
      ],
      "successCodes": [
        0
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "CommandLineTool",
      "id": "#dragen-somatic__4.3.6.cwl",
      "label": "dragen-somatic v(4.3.6)",
      "doc": "Run tumor-normal dragen somatic pipeline v 4.3.6.\nWorkflow takes in two separate lists of object stor version of the fastq_list.csv equivalent\nSee the fastq_list_row schema definitions for more information.\nMore information on the documentation can be found [here](https://support-docs.illumina.com/SW/DRAGEN_v40/Content/SW/DRAGEN/SomaticMode.htm).\n",
      "hints": [
        {
          "dockerPull": "079623148045.dkr.ecr.ap-southeast-2.amazonaws.com/cp-prod/c3add40b-1be2-431d-a322-29529f7d2866:latest",
          "class": "DockerRequirement"
        },
        {
          "coresMin": 16,
          "ramMin": 240000,
          "class": "ResourceRequirement",
          "https://platform.illumina.com/rdf/ica/resources:tier": "standard",
          "https://platform.illumina.com/rdf/ica/resources:type": "fpga",
          "https://platform.illumina.com/rdf/ica/resources:size": "medium"
        }
      ],
      "requirements": [
        {
          "listing": [
            {
              "entryname": "$(get_script_path())",
              "entry": "#!/usr/bin/env bash\n\n# Fail on non-zero exit of subshell\nset -euo pipefail\n\n# Confirm not more than one of fastq_list, fastq_list_rows, bam_input and cram_input are defined\nif [[ \"$(boolean_to_int(is_not_null(inputs.fastq_list)) + boolean_to_int(is_not_null(inputs.fastq_list_rows)) + boolean_to_int(is_not_null(inputs.bam_input)) + boolean_to_int(is_not_null(inputs.cram_input)))\" -gt \"1\" ]]; then\n  echo \"Please set no more than one of fastq_list, fastq_list_rows, bam_input or cram_input for normal sample\" 1>&2\n  exit 1\nfi\n\n# Ensure that at least one (and only one) of tumor_fastq_list, tumor_fastq_list_rows, tumor_bam_input and tumor_cram_input are defined but not both defined (XOR)\nif [[ \"$(boolean_to_int(is_not_null(inputs.tumor_fastq_list)) + boolean_to_int(is_not_null(inputs.tumor_fastq_list_rows)) + boolean_to_int(is_not_null(inputs.tumor_bam_input)) + boolean_to_int(is_not_null(inputs.tumor_cram_input)))\" -ne \"1\" ]]; then\n    echo \"One and only one of inputs tumor_fastq_list, tumor_fastq_list_rows, tumor_bam_input, tumor_cram_input must be defined\" 1>&2\n    exit 1\nfi\n\n# Reset dragen\n/opt/edico/bin/dragen \\\\\n  --partial-reconfig HMM \\\\\n  --ignore-version-check true\n\n# Create directories\nmkdir --parents \\\\\n  \"$(get_ref_mount())\" \\\\\n  \"$(get_intermediate_results_dir())\" \\\\\n  \"$(inputs.output_directory)\"\n\n# untar ref data into scratch space\ntar \\\\\n  --directory \"$(get_ref_mount())\" \\\\\n  --extract \\\\\n  --file \"$(inputs.reference_tar.path)\"\n\n# Check if both bam inputs are set\nif [[ \"$(is_not_null(inputs.bam_input))\" == \"true\" && \"$(is_not_null(inputs.tumor_bam_input))\" == \"true\" && ( \"$(get_bool_value_as_str(inputs.enable_map_align))\" == \"true\" || \"$(get_bool_value_as_str(inputs.enable_map_align_output))\" == \"true\" ) ]]; then\n  echo \"More than one bam input is set, need to run enable map align first beforehand then run variant calling in a separate step\" 1>&2\n\n  # Collect options relating to map alignment (these options will be popped from the args list and not used in the variant calling step)\n  enable_sort_parameter=\"\"\n  enable_duplicate_marking_parameter=\"\"\n  dedup_min_qual_parameter=\"\"\n\n  # Pop arguments\n  # Get args from command line\n  # But capture them again since we need them when we actually run dragen\n  existing_args_array=()\n  while [ $# -gt 0 ]; do\n    case \"$1\" in\n      --enable-sort=*)\n        enable_sort_parameter=\"$1\"\n        ;;\n      --enable-duplicate-marking=*)\n        enable_duplicate_marking_parameter=\"\\${1}\"\n        ;;\n      --enable-map-align=*)\n        :  # Just popping from array, we set this by default in these steps but dont want it in final dragen call\n        ;;\n      --enable-map-align-output=*)\n        :  # Just popping from array, we set this by default in these steps but dont want it in final dragen call\n        ;;\n      --dedup-min-qual=*)\n        dedup_min_qual_parameter=\"\\${1}\"\n        ;;\n      --bam-input=*)\n        :  # Just popping from array as we set the new location elsewhere\n        ;;\n      --tumor-bam-input=*)\n        :  # Just popping from array as we set the new location elsewhere\n        ;;\n      *)\n        existing_args_array+=(\"\\${1}\")\n    esac\n    shift 1\n  done\n\n  # Then run dragen map-align and place the files in the output directories\n  # Tumor Then Normal\n  echo \"Aligning tumor\" 1>&2\n  # Eval prefix required here as some parameters are empty\n  eval /opt/edico/bin/dragen \\\\\n    --enable-map-align=true \\\\\n    --enable-map-align-output=true \\\\\n    \"\\${enable_sort_parameter}\" \\\\\n    \"\\${enable_duplicate_marking_parameter}\" \\\\\n    \"\\${dedup_min_qual_parameter}\" \\\\\n    \"--ref-dir=$(get_ref_path(inputs.reference_tar))\" \\\\\n    \"--output-directory=$(inputs.output_directory)\" \\\\\n    \"--output-file-prefix=$(inputs.output_file_prefix)\" \\\\\n    \"--intermediate-results-dir=$(get_intermediate_results_dir())\" \\\\\n    \"--lic-instance-id-location=$(get_optional_attribute_from_multi_type_input_object(inputs.lic_instance_id_location, \"path\"))\" \\\\\n    \"--tumor-bam-input=$(get_attribute_from_optional_input(inputs.tumor_bam_input, \"path\"))\"\n\n  echo \"Aligning normal\" 1>&2\n  # Eval prefix required here as some parameters are empty\n  eval /opt/edico/bin/dragen \\\\\n    --enable-map-align=true \\\\\n    --enable-map-align-output=true \\\\\n    \"\\${enable_sort_parameter}\" \\\\\n    \"\\${enable_duplicate_marking_parameter}\" \\\\\n    \"\\${dedup_min_qual_parameter}\" \\\\\n    \"--ref-dir=$(get_ref_path(inputs.reference_tar))\" \\\\\n    \"--output-directory=$(inputs.output_directory)\" \\\\\n    \"--output-file-prefix=$(inputs.output_file_prefix)\" \\\\\n    \"--intermediate-results-dir=$(get_intermediate_results_dir())\" \\\\\n    \"--lic-instance-id-location=$(get_optional_attribute_from_multi_type_input_object(inputs.lic_instance_id_location, \"path\"))\" \\\\\n    \"--bam-input=$(get_attribute_from_optional_input(inputs.bam_input, \"path\"))\"\n\n  # Pop back in existing arguments into \\${@}\n  for existing_arg in \"\\${existing_args_array[@]}\"; do\n     set -- \"\\${@}\" \"\\${existing_arg}\"\n  done\n\n  # Update bam input and tumor bam input parameters\n  set -- \"\\${@}\" \"--bam-input=$(inputs.output_directory)/$(inputs.output_file_prefix).bam\"\n  set -- \"\\${@}\" \"--tumor-bam-input=$(inputs.output_directory)/$(inputs.output_file_prefix)_tumor.bam\"\n\n  # Explicity set enable map align to false\n  # Setting --enable-map-align to false, sets --enable-map-align-output to false as well\n  set -- \"\\${@}\" \"--enable-map-align=false\"\nfi\n\n# Check if cram inputs are set and enable map align output is set\n# Like bam inputs, we need to run map align first before running variant calling\nif [[ \"$(is_not_null(inputs.cram_input))\" == \"true\" && \"$(is_not_null(inputs.tumor_cram_input))\" == \"true\" && ( \"$(get_bool_value_as_str(inputs.enable_map_align))\" == \"true\" || \"$(get_bool_value_as_str(inputs.enable_map_align_output))\" == \"true\" ) ]]; then\n  echo \"More than one cram input is set, need to run enable map align first beforehand then run variant calling in a separate step\" 1>&2\n\n  # Collect options relating to map alignment (these options will be popped from the args list and not used in the variant calling step)\n  enable_sort_parameter=\"\"\n  enable_duplicate_marking_parameter=\"\"\n  dedup_min_qual_parameter=\"\"\n  cram_reference_parameter=\"\"\n\n  # Pop arguments\n  # Get args from command line\n  # But capture them again since we need them when we actually run dragen\n  existing_args_array=()\n  while [ $# -gt 0 ]; do\n    case \"$1\" in\n      --enable-sort=*)\n        enable_sort_parameter=\"$1\"\n        ;;\n      --enable-duplicate-marking=*)\n        enable_duplicate_marking_parameter=\"\\${1}\"\n        ;;\n      --enable-map-align=*)\n        :  # Just popping from array, we set this by default in these steps but dont want it in final dragen call\n        ;;\n      --enable-map-align-output=*)\n        :  # Just popping from array, we set this by default in these steps but dont want it in final dragen call\n        ;;\n      --dedup-min-qual=*)\n        dedup_min_qual_parameter=\"\\${1}\"\n        ;;\n      --cram-input=*)\n        :  # Just popping from array as we set the new location elsewhere\n        ;;\n      --tumor-cram-input=*)\n        :  # Just popping from array as we set the new location elsewhere\n        ;;\n      --cram-reference=*)\n        cram_reference_parameter=\"\\${1}\"\n        ;;\n      *)\n        existing_args_array+=(\"\\${1}\")\n    esac\n    shift 1\n  done\n\n  # Then run dragen map-align and place the files in the output directories\n  # Tumor Then Normal\n  echo \"Aligning tumor\" 1>&2\n  # Eval prefix required here as some parameters are empty\n  eval /opt/edico/bin/dragen \\\\\n    --enable-map-align=true \\\\\n    --enable-map-align-output=true \\\\\n    \"\\${enable_sort_parameter}\" \\\\\n    \"\\${enable_duplicate_marking_parameter}\" \\\\\n    \"\\${dedup_min_qual_parameter}\" \\\\\n    \"\\${cram_reference_parameter}\" \\\\\n    \"--ref-dir=$(get_ref_path(inputs.reference_tar))\" \\\\\n    \"--output-directory=$(inputs.output_directory)\" \\\\\n    \"--output-file-prefix=$(inputs.output_file_prefix)\" \\\\\n    \"--intermediate-results-dir=$(get_intermediate_results_dir())\" \\\\\n    \"--lic-instance-id-location=$(get_optional_attribute_from_multi_type_input_object(inputs.lic_instance_id_location, \"path\"))\" \\\\\n    \"--tumor-cram-input=$(get_attribute_from_optional_input(inputs.tumor_cram_input, \"path\"))\"\n\n  echo \"Aligning normal\" 1>&2\n  # Eval prefix required here as some parameters are empty\n  eval /opt/edico/bin/dragen \\\\\n    --enable-map-align=true \\\\\n    --enable-map-align-output=true \\\\\n    \"\\${enable_sort_parameter}\" \\\\\n    \"\\${enable_duplicate_marking_parameter}\" \\\\\n    \"\\${dedup_min_qual_parameter}\" \\\\\n    \"\\${cram_reference_parameter}\" \\\\\n    \"--ref-dir=$(get_ref_path(inputs.reference_tar))\" \\\\\n    \"--output-directory=$(inputs.output_directory)\" \\\\\n    \"--output-file-prefix=$(inputs.output_file_prefix)\" \\\\\n    \"--intermediate-results-dir=$(get_intermediate_results_dir())\" \\\\\n    \"--lic-instance-id-location=$(get_optional_attribute_from_multi_type_input_object(inputs.lic_instance_id_location, \"path\"))\" \\\\\n    \"--cram-input=$(get_attribute_from_optional_input(inputs.cram_input, \"path\"))\"\n\n  # Pop back in existing arguments into \\${@}\n  for existing_arg in \"\\${existing_args_array[@]}\"; do\n     set -- \"\\${@}\" \"\\${existing_arg}\"\n  done\n\n  # Update bam input and tumor bam input parameters\n  # Note that we output bams by default\n  set -- \"\\${@}\" \"--bam-input=$(inputs.output_directory)/$(inputs.output_file_prefix).bam\"\n  set -- \"\\${@}\" \"--tumor-bam-input=$(inputs.output_directory)/$(inputs.output_file_prefix)_tumor.bam\"\n\n  # Explicity set enable map align to false since we have already done the alignment\n  # Setting --enable-map-align to false, sets --enable-map-align-output to false as well\n  set -- \"\\${@}\" \"--enable-map-align=false\"\nfi\n\n# Run dragen command and import options from cli\necho \"Running dragen variant calling\" 1>&2\n\"$(get_dragen_bin_path())\" \"\\${@}\"\n\n# Check if a normal input is set\nif [[ \"$(is_not_null(inputs.fastq_list))\" == \"true\" || \"$(is_not_null(inputs.fastq_list_rows))\" == \"true\" || \"$(is_not_null(inputs.bam_input))\" == \"true\" || \"$(is_not_null(inputs.cram_input))\" == \"true\" ]]; then\n  # --enable-map-align-output is set to false\n  if [[ \"$(get_bool_value_as_str(inputs.enable_map_align_output))\" == \"false\" ]]; then\n    # No bams output if -enable-map-align-output is false and --enable-map-align is also false\n    # if --enable-map-align-output is false and --enable-map-align is false, no bam output\n    if [[ \"$(get_bool_value_as_str(inputs.enable_map_align))\" == \"false\" ]]; then\n      echo \"--enable-map-align-output and --enable-map-align set to false, no bam output\" 1>&2\n\n    # Bams output if --enable-map-align-output is false but --enable-map-align is true\n    # And one of tumor_bam_input or tumor_cram_input is set\n    # And one of bam_input or cram_input is set\n    # Then bam is generated even when --enable-map-align-output is explicitly set to false\n    # Since we needed to align the tumor and normal prior to running the variant calling step\n    # So when --enable-map-align-output is false under these conditions, we should delete the normal bam file rather than move it\n    elif [[ \"$(get_bool_value_as_str(inputs.enable_map_align))\" == \"true\" && ( \"$(is_not_null(inputs.tumor_bam_input))\" == \"true\" || \"$(is_not_null(inputs.tumor_cram_input))\" == \"true\" ) && ( \"$(is_not_null(inputs.bam_input))\" == \"true\" || \"$(is_not_null(inputs.cram_input))\" == \"true\" ) ]]; then\n      echo \"--enable-map-align is set to true but --enable-map-align-output is set to false, but we ignored --enable-map-align-output=false because one both tumor and normal inputs were set to true and thus needed to be aligned separately, deleting tumor and normal bam files\" 1>&2\n      rm -f \"$(inputs.output_directory)/$(inputs.output_file_prefix).bam\" \"$(inputs.output_directory)/$(inputs.output_file_prefix).bam.bai\" \"$(inputs.output_directory)/$(inputs.output_file_prefix).bam.md5sum\"\n      rm -f \"$(inputs.output_directory)/$(inputs.output_file_prefix)_tumor.bam\" \"$(inputs.output_directory)/$(inputs.output_file_prefix)_tumor.bam.bai\" \"$(inputs.output_directory)/$(inputs.output_file_prefix)_tumor.bam.md5sum\"\n    fi\n\n    # No action required otherwise --enable-map-align-output is false\n\n  # --enable-map-align-output is true\n  # Move normal bam file to new normal bam file name prefix\n  else\n    # Ensure that we have a normal RGSM value, otherwise exit.\n    if [[ \"$(is_not_null(get_normal_output_prefix(inputs)))\" == \"false\" ]]; then\n      echo \"Could not get the normal bam file prefix\" 1>&2\n      echo \"Exiting\" 1>&2\n      exit\n    fi\n\n    # Get new normal file name prefix from the fastq_list.csv\n    new_normal_file_name_prefix=\"$(get_normal_output_prefix(inputs))\"\n\n    # Ensure output normal bam file exists and the destination normal bam file also does not exist yet\n    if [[ -f \"$(inputs.output_directory)/$(inputs.output_file_prefix).bam\" && ! -f \"$(inputs.output_directory)/\\${new_normal_file_name_prefix}.bam\" ]]; then\n      # Move normal bam, normal bam index and normal bam md5sum\n      (\n        cd \"$(inputs.output_directory)\"\n        mv \"$(inputs.output_file_prefix).bam\" \"\\${new_normal_file_name_prefix}.bam\"\n        mv \"$(inputs.output_file_prefix).bam.bai\" \"\\${new_normal_file_name_prefix}.bam.bai\"\n        mv \"$(inputs.output_file_prefix).bam.md5sum\" \"\\${new_normal_file_name_prefix}.bam.md5sum\"\n      )\n    else\n      echo \"Error! Expected to move file from $(inputs.output_file_prefix).bam to \\${new_normal_file_name_prefix}.bam but either $(inputs.output_file_prefix).bam does not exist or \\${new_normal_file_name_prefix}.bam already exists\" 1>&2\n    fi\n  fi\nfi\n\n# If --enable-sv has been selected, we need to remove the empty genomeDepth directory\n# https://github.com/umccr-illumina/ica_v2/issues/131\nif [[ \"$(is_not_null(inputs.enable_sv))\" == \"true\" && \"$(get_bool_value_as_str(inputs.enable_sv))\" == \"true\" && -d \"$(inputs.output_directory)/sv/\" ]]; then\n  find \"$(inputs.output_directory)/sv/\" -type d -empty -delete\nfi\n"
            },
            "${\n  return generate_somatic_mount_points(inputs);\n}\n"
          ],
          "class": "InitialWorkDirRequirement"
        },
        {
          "expressionLib": [
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Functions */\nfunction get_script_path() {\n    /*\n    Abstract script path, can then be referenced in baseCommand attribute too\n    Makes things more readable.\n    */\n    return \"run-dragen-script.sh\";\n}\nfunction get_scratch_mount() {\n    /*\n    Return the path of the scratch directory space\n    */\n    return \"/scratch/\";\n}\nfunction get_intermediate_results_dir() {\n    /*\n    Get intermediate results directory as /scratch for dragen runs\n    */\n    return get_scratch_mount() + \"intermediate-results/\";\n}\nfunction get_name_root_from_tarball(basename) {\n    var tar_ball_regex = /(\\S+)\\.tar\\.gz/g;\n    var tar_ball_expression = tar_ball_regex.exec(basename);\n    if (tar_ball_expression === null) {\n        throw new Error(\"Could not get nameroot from \".concat(basename));\n    }\n    return tar_ball_expression[1];\n}\nfunction get_ref_path(reference_input_obj) {\n    /*\n    Get the reference path\n    */\n    return get_ref_mount() + get_name_root_from_tarball(reference_input_obj.basename) + \"/\";\n}\nfunction get_ref_mount() {\n    /*\n    Get the reference mount point\n    */\n    return get_scratch_mount() + \"ref/\";\n}\nfunction get_dragen_bin_path() {\n    /*\n    Get dragen bin path\n    */\n    return \"/opt/edico/bin/dragen\";\n}\nfunction get_dragen_eval_line() {\n    /*\n    Return string\n    */\n    return \"eval \\\"\" + get_dragen_bin_path() + \"\\\" '\\\"\\$@\\\"' \\n\";\n}\nfunction get_fastq_list_csv_path() {\n    /*\n    The fastq list path must be placed in working directory\n    */\n    return \"fastq_list.csv\";\n}\nfunction get_tumor_fastq_list_csv_path() {\n    /*\n    The tumor fastq list path must be placed in working directory\n    */\n    return \"tumor_fastq_list.csv\";\n}\nfunction get_ora_mv_files_script_path() {\n    /*\n    Get the ora mv files script path\n    */\n    return \"mv-ora-output-files.sh\";\n}\nfunction get_new_fastq_list_csv_script_path() {\n    /*\n    Get the new fastq list csv script path\n    */\n    return \"generate-new-fastq-list-csv.sh\";\n}\nfunction get_fastq_gz_md5sum_files_script_path() {\n    /*\n    Get the script path to generating the md5sum for each fastq gzip file\n    */\n    return \"generate-md5sum-for-fastq-gz-files.sh\";\n}\nfunction get_fastq_gz_file_sizes_script_path() {\n    /*\n    Get the script path to generating the filesizes for each fastq gzip file\n    */\n    return \"generate-file-sizes-for-fastq-gz-files.sh\";\n}\nfunction get_fastq_ora_md5sum_files_script_path() {\n    /*\n    Get the script path for generating the md5sum for each fastq ora file\n    */\n    return \"generate-md5sum-for-fastq-ora-files.sh\";\n}\nfunction get_fastq_ora_file_sizes_script_path() {\n    /*\n    Get the script path to generating the filesizes for each fastq gzip file\n    */\n    return \"generate-file-sizes-for-fastq-ora-files.sh\";\n}\nfunction get_normal_name_from_fastq_list_rows(fastq_list_rows) {\n    /*\n    Get the normal sample name from the fastq list rows object\n    */\n    /*\n    Check fastq list rows is defined\n    */\n    if (fastq_list_rows === undefined || fastq_list_rows === null) {\n        return null;\n    }\n    /*\n    Get RGSM value and return\n    */\n    return fastq_list_rows[0].rgsm;\n}\nfunction get_normal_name_from_fastq_list_csv(fastq_list_csv) {\n    /*\n    Get the normal name from the fastq list csv...\n    */\n    /*\n    Check file is defined\n    */\n    if (fastq_list_csv === undefined || fastq_list_csv === null) {\n        return null;\n    }\n    /*\n    Check contents are defined\n    */\n    if (fastq_list_csv.contents === null || fastq_list_csv.contents === undefined) {\n        return null;\n    }\n    /*\n    Confirm fastq list csv is of type File\n    */\n    if (fastq_list_csv.class !== \"File\") {\n        throw new Error(\"Could not confirm input fastq_list_csv is of type File\");\n    }\n    /*\n    Split contents by line\n    */\n    var contents_by_line = [];\n    fastq_list_csv.contents.split(\"\\n\").forEach(function (line_content) {\n        var stripped_line_content = line_content.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n        if (stripped_line_content !== \"\") {\n            contents_by_line.push(stripped_line_content);\n        }\n    });\n    var column_names = contents_by_line[0].split(\",\");\n    /*\n    Get RGSM index value (which column is RGSM at?)\n    */\n    var rgsm_index = column_names.indexOf(\"RGSM\");\n    /*\n    RGSM is not in index. Return null\n    */\n    if (rgsm_index === -1) {\n        return null;\n    }\n    /*\n    Get RGSM value of first row and return\n    */\n    return contents_by_line[1].split(\",\")[rgsm_index];\n}\nfunction get_normal_output_prefix(inputs) {\n    var _a, _b;\n    /*\n    Get the normal RGSM value and then add _normal to it\n    */\n    var normal_name = null;\n    var normal_re_replacement = /_normal$/;\n    /*\n    Check if bam_input is set\n    */\n    if (inputs.bam_input !== null && inputs.bam_input !== undefined) {\n        /* Remove _normal from nameroot if it already exists */\n        /* We dont want _normal_normal as a suffix */\n        return \"\".concat((_a = inputs.bam_input.nameroot) === null || _a === void 0 ? void 0 :_a.replace(normal_re_replacement, \"\"), \"_normal\");\n    }\n    /*\n    Check if cram_input is set\n    */\n    if (inputs.cram_input !== null && inputs.cram_input !== undefined) {\n        /* Remove _normal from nameroot if it already exists */\n        /* We dont want _normal_normal as a suffix */\n        return \"\".concat((_b = inputs.cram_input.nameroot) === null || _b === void 0 ? void 0 :_b.replace(normal_re_replacement, \"\"), \"_normal\");\n    }\n    /*\n    Check if fastq list file is set\n    */\n    if (inputs.fastq_list !== null && inputs.fastq_list !== undefined) {\n        normal_name = get_normal_name_from_fastq_list_csv(inputs.fastq_list);\n        if (normal_name !== null) {\n            return \"\".concat(normal_name, \"_normal\");\n        }\n    }\n    /*\n    Otherwise collect and return from schema object\n    */\n    normal_name = get_normal_name_from_fastq_list_rows(inputs.fastq_list_rows);\n    return \"\".concat(normal_name, \"_normal\");\n}\nfunction build_fastq_list_csv_header(header_names) {\n    /*\n    Convert lowercase labels to uppercase values\n    i.e\n    [ \"rgid\", \"rglb\", \"rgsm\", \"lane\", \"read_1\", \"read_2\" ]\n    to\n    \"RGID,RGLB,RGSM,Lane,Read1File,Read2File\"\n    */\n    var modified_header_names = [];\n    for (var _i = 0, header_names_1 = header_names; _i < header_names_1.length; _i++) {\n        var header_name = header_names_1[_i];\n        if (header_name.indexOf(\"rg\") === 0) {\n            /*\n            rgid -> RGID\n            */\n            modified_header_names.push(header_name.toUpperCase());\n        }\n        else if (header_name.indexOf(\"read\") === 0) {\n            /*\n            read_1 -> Read1File\n            */\n            modified_header_names.push(\"Read\" + header_name.charAt(header_name.length - 1) + \"File\");\n        }\n        else {\n            /*\n            lane to Lane\n            */\n            modified_header_names.push(header_name[0].toUpperCase() + header_name.substr(1));\n        }\n    }\n    /*\n    Convert array to comma separated strings\n    */\n    return modified_header_names.join(\",\") + \"\\n\";\n}\nfunction get_fastq_list_row_as_csv_row(fastq_list_row, row_order) {\n    var fastq_list_row_values_array = [];\n    /*  This for loop is here to ensure were assigning values in the same order as the header */\n    for (var _i = 0, row_order_1 = row_order; _i < row_order_1.length; _i++) {\n        var item_index = row_order_1[_i];\n        var found_item = false;\n        /*  Find matching attribute in this row */\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            var fastq_list_row_field_value = fastq_list_row[fastq_list_row_field_name];\n            if (fastq_list_row_field_value === null) {\n                /*\n                Item not found, add an empty attribute for this cell in the csv\n                */\n                continue;\n            }\n            /*  The header value matches the name in the item */\n            if (fastq_list_row_field_name === item_index) {\n                /*\n                If the field value has a class attribute then it's either read_1 or read_2\n                */\n                if (fastq_list_row_field_value.hasOwnProperty(\"class\")) {\n                    var fastq_list_row_field_value_file = fastq_list_row_field_value;\n                    /*\n                    Assert that this is actually of class file\n                    */\n                    if (fastq_list_row_field_value_file.class !== \"File\") {\n                        continue;\n                    }\n                    if (fastq_list_row_field_value_file.path !== null && fastq_list_row_field_value_file.path !== undefined) {\n                        /*\n                        Push the path attribute to the fastq list csv row if it is not null\n                        */\n                        fastq_list_row_values_array.push(fastq_list_row_field_value_file.path);\n                    }\n                    else {\n                        /*\n                        Otherwise push the location attribute\n                        */\n                        fastq_list_row_values_array.push(fastq_list_row_field_value_file.location);\n                    }\n                }\n                else {\n                    /*\n                    Push the string attribute to the fastq list csv row\n                    */\n                    fastq_list_row_values_array.push(fastq_list_row_field_value.toString());\n                }\n                found_item = true;\n                break;\n            }\n        }\n        if (!found_item) {\n            /*\n            Push blank cell if no item found\n            */\n            fastq_list_row_values_array.push(\"\");\n        }\n    }\n    /*\n    Convert to string and return as string\n    */\n    return fastq_list_row_values_array.join(\",\") + \"\\n\";\n}\nfunction generate_fastq_list_csv(fastq_list_rows) {\n    /*\n    Fastq list rows generation\n    */\n    var fastq_csv_file = {\n        class:\"File\",\n        basename:get_fastq_list_csv_path()\n    };\n    /*\n    Set the row order\n    */\n    var row_order = [];\n    /*\n    Set the array order\n    Make sure we iterate through all rows of the array\n    */\n    for (var _i = 0, fastq_list_rows_1 = fastq_list_rows; _i < fastq_list_rows_1.length; _i++) {\n        var fastq_list_row = fastq_list_rows_1[_i];\n        for (var _a = 0, _b = Object.getOwnPropertyNames(fastq_list_row); _a < _b.length; _a++) {\n            var fastq_list_row_field_name = _b[_a];\n            if (row_order.indexOf(fastq_list_row_field_name) === -1) {\n                row_order.push(fastq_list_row_field_name);\n            }\n        }\n    }\n    /*\n    Make header\n    */\n    fastq_csv_file.contents = build_fastq_list_csv_header(row_order);\n    /*\n    For each fastq list row,\n    collect the values of each attribute but in the order of the header\n    */\n    for (var _c = 0, fastq_list_rows_2 = fastq_list_rows; _c < fastq_list_rows_2.length; _c++) {\n        var fastq_list_row = fastq_list_rows_2[_c];\n        /*  Add csv row to file contents */\n        fastq_csv_file.contents += get_fastq_list_row_as_csv_row(fastq_list_row, row_order);\n    }\n    return fastq_csv_file;\n}\nfunction generate_germline_mount_points(inputs) {\n    /*\n    Create and add in the fastq list csv for the input fastqs\n    */\n    var e = [];\n    if (inputs.fastq_list_rows !== null) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(inputs.fastq_list_rows)\n        });\n    }\n    if (inputs.fastq_list !== null) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":inputs.fastq_list\n        });\n    }\n    /*\n    Return file paths\n    */\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_somatic_mount_points(inputs) {\n    /*\n    Create and add in the fastq list csv for the input fastqs\n    */\n    var e = [];\n    if (inputs.fastq_list_rows !== null) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(inputs.fastq_list_rows)\n        });\n    }\n    if (inputs.tumor_fastq_list_rows !== null) {\n        e.push({\n            \"entryname\":get_tumor_fastq_list_csv_path(),\n            \"entry\":generate_fastq_list_csv(inputs.tumor_fastq_list_rows)\n        });\n    }\n    if (inputs.fastq_list !== null) {\n        e.push({\n            \"entryname\":get_fastq_list_csv_path(),\n            \"entry\":inputs.fastq_list\n        });\n    }\n    if (inputs.tumor_fastq_list !== null) {\n        e.push({\n            \"entryname\":get_tumor_fastq_list_csv_path(),\n            \"entry\":inputs.tumor_fastq_list\n        });\n    }\n    /*\n    Return file paths\n    */\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\nfunction generate_transcriptome_mount_points(inputs) {\n    /*\n    Calls another function that generates mount points\n    */\n    return generate_germline_mount_points(inputs);\n}\n/*  Custom functions for dragen reference tarball build */\nfunction get_liftover_dir() {\n    /*  Hardcoded liftover directory in dragen 4.2 */\n    return \"/opt/edico/liftover/\";\n}\nfunction get_mask_dir() {\n    /*  Hardcoded mask directory in dragen 4.2 */\n    return \"/opt/edico/fasta_mask/\";\n}\nfunction get_ref_scratch_dir(reference_name) {\n    /*  We get the reference scratch directory as a combination of */\n    /*  the dragen scratch mount and the reference name */\n    return get_scratch_mount() + reference_name + \"/\";\n}\nfunction get_ora_intermediate_output_dir() {\n    return get_scratch_mount() + \"ora-outputs/\";\n}\nfunction generate_ora_mv_files_script(fastq_list_rows, input_directory, output_directory) {\n    /*\n    Generate the shell script with a list of echo commands to write a new fastq list csv to stdout, however\n    the fastq list csv contains the ora files as outputs instead\n    */\n    var ora_mv_files_script = \"#!/usr/bin/env bash\\n\\n\";\n    ora_mv_files_script += \"# Exit on failure\\n\";\n    ora_mv_files_script += \"set -euo pipefail\\n\\n\";\n    ora_mv_files_script += \"# Get fastq ora paths\\n\";\n    ora_mv_files_script += \"FASTQ_ORA_OUTPUT_PATHS=(\\n\";\n    /*  Iterate over all files */\n    for (var _i = 0, fastq_list_rows_3 = fastq_list_rows; _i < fastq_list_rows_3.length; _i++) {\n        var fastq_list_row = fastq_list_rows_3[_i];\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            /*  Add relative path of read 1 */\n            ora_mv_files_script += \"  \\\"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            /*  Add relative path of read 2 */\n            ora_mv_files_script += \"  \\\"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n    }\n    /*  Complete the bash array */\n    ora_mv_files_script += \")\\n\\n\";\n    ora_mv_files_script += \"# Move all ora files to the final output directory\\n\";\n    ora_mv_files_script += \"for fastq_ora_output_path in \\\"${FASTQ_ORA_OUTPUT_PATHS[@]}\\\"; do\\n\";\n    ora_mv_files_script += \"  fastq_ora_scratch_path=\\\"\".concat(get_ora_intermediate_output_dir(), \"$(basename \\\"${fastq_ora_output_path}\\\")\\\"\\n\");\n    ora_mv_files_script += \"  mkdir -p \\\"$(dirname \\\"\".concat(output_directory, \"/${fastq_ora_output_path}\\\")\\\"\\n\");\n    ora_mv_files_script += \"  rsync --archive \\\\\\n\";\n    ora_mv_files_script += \"    --remove-source-files \\\\\\n\";\n    ora_mv_files_script += \"    --include \\\"$(basename \\\"${fastq_ora_output_path}\\\")\\\" \\\\\\n\";\n    ora_mv_files_script += \"    --exclude \\\"*\\\" \\\\\\n\";\n    ora_mv_files_script += \"    \\\"$(dirname \\\"${fastq_ora_scratch_path}\\\")/\\\" \\\\\\n\";\n    ora_mv_files_script += \"    \\\"$(dirname \\\"\".concat(output_directory, \"/${fastq_ora_output_path}\\\")/\\\"\\n\");\n    ora_mv_files_script += \"done\\n\\n\";\n    ora_mv_files_script += \"# Transfer all other files\\n\";\n    ora_mv_files_script += \"mkdir -p \\\"\".concat(output_directory, \"/ora-logs/\\\"\\n\");\n    ora_mv_files_script += \"mv \\\"\".concat(get_ora_intermediate_output_dir(), \"\\\" \\\"\").concat(output_directory, \"/ora-logs/compression/\\\"\\n\");\n    return {\n        class:\"File\",\n        basename:get_ora_mv_files_script_path(),\n        contents:ora_mv_files_script\n    };\n}\nfunction generate_fastq_gz_md5sum_files_script(fastq_list_rows, input_directory) {\n    /*\n    Generate the fastq gzip md5sum files script command, results are printed to stdout\n    */\n    var get_md5sum_fastq_gz_script = \"#!/usr/bin/env bash\\n\\n\";\n    get_md5sum_fastq_gz_script += \"# Exit on failure\\n\";\n    get_md5sum_fastq_gz_script += \"set -euo pipefail\\n\\n\";\n    /*  Initialise the bash array */\n    get_md5sum_fastq_gz_script += \"# Get fastq gz paths\\n\";\n    get_md5sum_fastq_gz_script += \"FASTQ_GZ_PATHS=(\\n\";\n    /*  Iterate over all files */\n    for (var _i = 0, fastq_list_rows_4 = fastq_list_rows; _i < fastq_list_rows_4.length; _i++) {\n        var fastq_list_row = fastq_list_rows_4[_i];\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            /*  Add relative path of read 1 */\n            get_md5sum_fastq_gz_script += \"  \\\"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", ''), \"\\\" \\\\\\n\");\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            get_md5sum_fastq_gz_script += \"  \\\"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", ''), \"\\\" \\\\\\n\");\n        }\n    }\n    /*  Complete the bash array */\n    get_md5sum_fastq_gz_script += \")\\n\\n\";\n    /*  Build the for loop */\n    get_md5sum_fastq_gz_script += \"# Generate md5sums for the input fastq gz files\\n\";\n    get_md5sum_fastq_gz_script += \"for fastq_gz_path in \\\"${FASTQ_GZ_PATHS[@]}\\\"; do\\n\";\n    get_md5sum_fastq_gz_script += \"  full_input_path=\\\"\".concat(input_directory.path, \"/${fastq_gz_path}\\\"\\n\");\n    get_md5sum_fastq_gz_script += \"  md5sum \\\"${full_input_path}\\\" | sed \\\"s%${full_input_path}%${fastq_gz_path}%\\\"\\n\";\n    get_md5sum_fastq_gz_script += \"done\\n\\n\";\n    get_md5sum_fastq_gz_script += \"# Md5sum script complete\\n\";\n    return {\n        class:\"File\",\n        basename:get_fastq_gz_md5sum_files_script_path(),\n        contents:get_md5sum_fastq_gz_script\n    };\n}\nfunction generate_fastq_gz_file_sizes_script(fastq_list_rows, input_directory) {\n    /*\n    Generate the fastq gzip get files sizes, results are printed to stdout\n    */\n    var get_filesizes_fastq_gz_script = \"#!/usr/bin/env bash\\n\\n\";\n    get_filesizes_fastq_gz_script += \"# Exit on failure\\n\";\n    get_filesizes_fastq_gz_script += \"set -euo pipefail\\n\\n\";\n    /*  Initialise the bash array */\n    get_filesizes_fastq_gz_script += \"# Get fastq gz paths\\n\";\n    get_filesizes_fastq_gz_script += \"FASTQ_GZ_PATHS=(\\n\";\n    /*  Iterate over all files */\n    for (var _i = 0, fastq_list_rows_5 = fastq_list_rows; _i < fastq_list_rows_5.length; _i++) {\n        var fastq_list_row = fastq_list_rows_5[_i];\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            /*  Add relative path of read 1 */\n            get_filesizes_fastq_gz_script += \"  \\\"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", ''), \"\\\" \\\\\\n\");\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            get_filesizes_fastq_gz_script += \"  \\\"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", ''), \"\\\" \\\\\\n\");\n        }\n    }\n    /*  Complete the bash array */\n    get_filesizes_fastq_gz_script += \")\\n\\n\";\n    /*  Build the for loop */\n    /*  Initialise the tsv */\n    get_filesizes_fastq_gz_script += \"# Initialise the tsv header\\n\";\n    get_filesizes_fastq_gz_script += \"echo \\\"fastqPath\\tfileSizeInBytes\\\"\\n\\n\";\n    get_filesizes_fastq_gz_script += \"# Generate file sizes for the input fastq gz files\\n\";\n    get_filesizes_fastq_gz_script += \"for fastq_gz_path in \\\"${FASTQ_GZ_PATHS[@]}\\\"; do\\n\";\n    get_filesizes_fastq_gz_script += \"  file_size=\\\"$(wc -c < \\\"\".concat(input_directory.path, \"/${fastq_gz_path}\\\")\\\"\\n\");\n    get_filesizes_fastq_gz_script += \"  echo \\\"${fastq_gz_path}\\t${file_size}\\\"\\n\";\n    get_filesizes_fastq_gz_script += \"done\\n\\n\";\n    get_filesizes_fastq_gz_script += \"# file size script complete\\n\";\n    return {\n        class:\"File\",\n        basename:get_fastq_gz_file_sizes_script_path(),\n        contents:get_filesizes_fastq_gz_script\n    };\n}\nfunction generate_fastq_ora_md5sum_files_script(fastq_list_rows, input_directory, output_directory) {\n    /*\n    Generate the fastq ora md5sum files script command, results are printed to stdout\n    */\n    var get_md5sum_fastq_ora_script = \"#!/usr/bin/env bash\\n\\n\";\n    get_md5sum_fastq_ora_script += \"# Exit on failure\\n\";\n    get_md5sum_fastq_ora_script += \"set -euo pipefail\\n\\n\";\n    /*  Initialise the bash array */\n    get_md5sum_fastq_ora_script += \"# Get fastq ora paths\\n\";\n    get_md5sum_fastq_ora_script += \"FASTQ_ORA_OUTPUT_PATHS=(\\n\";\n    /*  Iterate over all files */\n    for (var _i = 0, fastq_list_rows_6 = fastq_list_rows; _i < fastq_list_rows_6.length; _i++) {\n        var fastq_list_row = fastq_list_rows_6[_i];\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            /*  Add relative path of read 1 */\n            get_md5sum_fastq_ora_script += \"  \\\"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            get_md5sum_fastq_ora_script += \"  \\\"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n    }\n    /*  Complete the bash array */\n    get_md5sum_fastq_ora_script += \")\\n\\n\";\n    get_md5sum_fastq_ora_script += \"# Generate md5sums for the input fastq ora files\\n\";\n    get_md5sum_fastq_ora_script += \"for fastq_ora_output_path in \\\"${FASTQ_ORA_OUTPUT_PATHS[@]}\\\"; do\\n\";\n    get_md5sum_fastq_ora_script += \"  fastq_ora_scratch_path=\\\"\".concat(output_directory, \"$(basename \\\"${fastq_ora_output_path}\\\")\\\"\\n\");\n    get_md5sum_fastq_ora_script += \"  md5sum \\\"${fastq_ora_scratch_path}\\\" | sed \\\"s%${fastq_ora_scratch_path}%${fastq_ora_output_path}%\\\"\\n\";\n    get_md5sum_fastq_ora_script += \"done\\n\\n\";\n    get_md5sum_fastq_ora_script += \"# Md5sum script complete\\n\";\n    return {\n        class:\"File\",\n        basename:get_fastq_ora_md5sum_files_script_path(),\n        contents:get_md5sum_fastq_ora_script\n    };\n}\nfunction generate_fastq_ora_file_sizes_script(fastq_list_rows, input_directory, output_directory) {\n    /*\n    Generate the fastq ora file size files script command, results are printed to stdout\n    */\n    var get_filesizes_fastq_ora_script = \"#!/usr/bin/env bash\\n\\n\";\n    get_filesizes_fastq_ora_script += \"# Exit on failure\\n\";\n    get_filesizes_fastq_ora_script += \"set -euo pipefail\\n\\n\";\n    /*  Initialise the bash array */\n    get_filesizes_fastq_ora_script += \"# Get fastq ora paths\\n\";\n    get_filesizes_fastq_ora_script += \"FASTQ_ORA_OUTPUT_PATHS=(\\n\";\n    /*  Iterate over all files */\n    for (var _i = 0, fastq_list_rows_7 = fastq_list_rows; _i < fastq_list_rows_7.length; _i++) {\n        var fastq_list_row = fastq_list_rows_7[_i];\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            /*  Add relative path of read 1 */\n            get_filesizes_fastq_ora_script += \"  \\\"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            get_filesizes_fastq_ora_script += \"  \\\"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \"\\\" \\\\\\n\");\n        }\n    }\n    /*  Complete the bash array */\n    get_filesizes_fastq_ora_script += \")\\n\\n\";\n    get_filesizes_fastq_ora_script += \"# Initialise the tsv header\\n\";\n    get_filesizes_fastq_ora_script += \"echo \\\"fastqPath\\tfileSizeInBytes\\\"\\n\\n\";\n    get_filesizes_fastq_ora_script += \"# Generate file sizes for the output fastq ora files\\n\";\n    get_filesizes_fastq_ora_script += \"for fastq_ora_output_path in \\\"${FASTQ_ORA_OUTPUT_PATHS[@]}\\\"; do\\n\";\n    get_filesizes_fastq_ora_script += \"  fastq_ora_scratch_path=\\\"\".concat(output_directory, \"$(basename \\\"${fastq_ora_output_path}\\\")\\\"\\n\");\n    get_filesizes_fastq_ora_script += \"  file_size=\\\"$(wc -c < \\\"${fastq_ora_scratch_path}\\\")\\\"\\n\";\n    get_filesizes_fastq_ora_script += \"  echo \\\"${fastq_ora_output_path}\\t${file_size}\\\"\\n\";\n    get_filesizes_fastq_ora_script += \"done\\n\\n\";\n    get_filesizes_fastq_ora_script += \"# ORA script complete\\n\";\n    return {\n        class:\"File\",\n        basename:get_fastq_ora_file_sizes_script_path(),\n        contents:get_filesizes_fastq_ora_script\n    };\n}\nfunction generate_new_fastq_list_csv_script(fastq_list_rows, input_directory) {\n    /*\n    Generate the shell script with a list of mv commands to move the output files from the scratch space to their\n    original location in the working directory\n    */\n    var new_fastq_list_csv_script = \"#!/usr/bin/env bash\\n\\n\";\n    new_fastq_list_csv_script += \"set -euo pipefail\\n\\n\";\n    new_fastq_list_csv_script += \"# Generate a new fastq list csv script\\n\";\n    new_fastq_list_csv_script += \"# Initialise header\\n\";\n    new_fastq_list_csv_script += \"echo \\\"RGID,RGLB,RGSM,Lane,Read1File,Read2File\\\"\\n\";\n    for (var _i = 0, fastq_list_rows_8 = fastq_list_rows; _i < fastq_list_rows_8.length; _i++) {\n        var fastq_list_row = fastq_list_rows_8[_i];\n        /*  Initialise echo line */\n        var echo_line = \"echo \\\"\".concat(fastq_list_row.rgid, \",\").concat(fastq_list_row.rglb, \",\").concat(fastq_list_row.rgsm, \",\").concat(fastq_list_row.lane, \",\");\n        /*  Confirm read 1 is a file type */\n        if (\"class\" in fastq_list_row.read_1 && fastq_list_row.read_1.class === \"File\") {\n            echo_line += \"\".concat(fastq_list_row.read_1.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"), \",\");\n        }\n        else {\n            echo_line += ',';\n        }\n        /*  Confirm read 2 is a file type */\n        if (fastq_list_row.read_2 !== null && \"class\" in fastq_list_row.read_2 && fastq_list_row.read_2.class === \"File\") {\n            echo_line += \"\".concat(fastq_list_row.read_2.path.replace(input_directory.path + \"/\", '').replace(\".gz\", \".ora\"));\n        }\n        /*  Finish off echo line */\n        echo_line += \"\\\"\\n\";\n        new_fastq_list_csv_script += echo_line;\n    }\n    return {\n        class:\"File\",\n        basename:get_new_fastq_list_csv_script_path(),\n        contents:new_fastq_list_csv_script\n    };\n}\nfunction find_fastq_files_in_directory_recursively_with_regex(input_dir) {\n    var _a;\n    /*\n    Initialise the output file object\n    */\n    var read_1_file_list = [];\n    var read_2_file_list = [];\n    var output_file_objs = [];\n    var fastq_file_regex = /\\.fastq\\.gz$/;\n    var r1_fastq_file_regex = /_R1_001\\.fastq\\.gz$/;\n    var r2_fastq_file_regex = /_R2_001\\.fastq\\.gz$/;\n    /*\n    Check input_dir is a directory and has a listing\n    */\n    if (input_dir.class === undefined || input_dir.class !== \"Directory\") {\n        throw new Error(\"Could not confirm that the first argument was a directory\");\n    }\n    if (input_dir.listing === undefined || input_dir.listing === null) {\n        throw new Error(\"Could not collect listing from directory \\\"\".concat(input_dir.basename, \"\\\"\"));\n    }\n    /*\n    Collect listing as a variable\n    */\n    var input_listing = input_dir.listing;\n    /*\n    Iterate through the file listing\n    */\n    for (var _i = 0, input_listing_1 = input_listing; _i < input_listing_1.length; _i++) {\n        var listing_item = input_listing_1[_i];\n        if (listing_item.class === \"File\" && fastq_file_regex.test(listing_item.basename)) {\n            /*\n            Got the file of interest and the file basename matches the file regex\n            */\n            /*\n            Check if the file is read 1 or read 2\n            */\n            if (r1_fastq_file_regex.test(listing_item.basename)) {\n                read_1_file_list.push(listing_item);\n            }\n            if (r2_fastq_file_regex.test(listing_item.basename)) {\n                read_2_file_list.push(listing_item);\n            }\n        }\n        if (listing_item.class === \"Directory\") {\n            var subdirectory_list = listing_item;\n            try {\n                /*  Consider that the file might not be in this subdirectory and that is okay */\n                output_file_objs.push.apply(output_file_objs, find_fastq_files_in_directory_recursively_with_regex(subdirectory_list));\n            }\n            catch (error) {\n                /*  Dont need to report an error though, just continue */\n            }\n        }\n    }\n    /*  Iterate over all the read 1 files and try to find a matching read 2 file */\n    for (var _b = 0, read_1_file_list_1 = read_1_file_list; _b < read_1_file_list_1.length; _b++) {\n        var read_1_file = read_1_file_list_1[_b];\n        var read_2_file = undefined;\n        for (var _c = 0, read_2_file_list_1 = read_2_file_list; _c < read_2_file_list_1.length; _c++) {\n            var read_2_file_candidate = read_2_file_list_1[_c];\n            if (((_a = read_1_file.basename) === null || _a === void 0 ? void 0 :_a.replace(\"R1_001.fastq.gz\", \"R2_001.fastq.gz\")) === read_2_file_candidate.basename) {\n                read_2_file = read_2_file_candidate;\n                break;\n            }\n        }\n        output_file_objs.push({ read1obj:read_1_file, read2obj:read_2_file });\n    }\n    /*  Return the output file object */\n    return output_file_objs;\n}\nfunction get_rgsm_value_from_fastq_file_name(fastq_file_name) {\n    /*  Get the RGID value from the fastq file name */\n    var rgid_regex = /(.+?)(?:_S\\d+)?(?:_L00\\d)?_R[12]_001\\.fastq\\.gz$/;\n    var rgid_expression = rgid_regex.exec(fastq_file_name);\n    if (rgid_expression === null) {\n        throw new Error(\"Could not get rgid from \".concat(fastq_file_name));\n    }\n    return rgid_expression[1];\n}\nfunction get_lane_value_from_fastq_file_name(fastq_file_name) {\n    /*  Get the lane value from the fastq file name */\n    var lane_regex = /(?:.+?)(?:_S\\d+)?_L00(\\d)_R[12]_001\\.fastq\\.gz$/;\n    var lane_expression = lane_regex.exec(fastq_file_name);\n    if (lane_expression === null) {\n        return 1;\n    }\n    else {\n        console.log(lane_expression);\n        return parseInt(lane_expression[1]);\n    }\n}\nfunction generate_ora_mount_points(input_run, output_directory_path, sample_id_list) {\n    /*\n    Three main parts\n\n    1. Collect the fastq files\n    2. For each fastq file pair, generate the rgid, rgsm, rglb and lane attributes as necessary to make a fastq list row\n    3. Generate the fastq list csv file\n    */\n    /*  Collect the fastq files */\n    var fastq_files_pairs = find_fastq_files_in_directory_recursively_with_regex(input_run);\n    /*  For each fastq file pair, generate the rgid, rgsm, rglb and lane attributes as necessary */\n    var fastq_list_rows = [];\n    for (var _i = 0, fastq_files_pairs_1 = fastq_files_pairs; _i < fastq_files_pairs_1.length; _i++) {\n        var fastq_files_pair = fastq_files_pairs_1[_i];\n        var rgsm_value = get_rgsm_value_from_fastq_file_name(fastq_files_pair.read1obj.basename);\n        /*  Skip fastq list pair if sample_id_list is defined and the rgsm_value is not in the list */\n        if (sample_id_list !== undefined && sample_id_list !== null && sample_id_list !== \"\" && sample_id_list.indexOf(rgsm_value) === -1) {\n            continue;\n        }\n        /*  Remove undetermined files from the list of fastqs to process (they are often empty) */\n        if (rgsm_value === \"Undetermined\") {\n            continue;\n        }\n        /*  Check if we have the size attribute and if so check if it is greater than 0 */\n        if (fastq_files_pair.read1obj.size !== null && fastq_files_pair.read1obj.size !== undefined && fastq_files_pair.read1obj.size == 0) {\n            continue;\n        }\n        /*  Repeat the condition for read 2 although also ensure that read 2 is also actually defined */\n        if (fastq_files_pair.read2obj !== undefined && fastq_files_pair.read2obj !== null) {\n            if (fastq_files_pair.read2obj.size !== null && fastq_files_pair.read2obj.size !== undefined && fastq_files_pair.read2obj.size == 0) {\n                continue;\n            }\n        }\n        var lane_value = get_lane_value_from_fastq_file_name(fastq_files_pair.read1obj.basename);\n        var fastq_list_row = {\n            rgid:lane_value.toString() + '.' + rgsm_value,\n            rgsm:rgsm_value,\n            rglb:\"UnknownLibrary\",\n            lane:lane_value,\n            read_1:fastq_files_pair.read1obj,\n            read_2:fastq_files_pair.read2obj\n        };\n        fastq_list_rows.push(fastq_list_row);\n    }\n    /*  Initialise dirent */\n    var e = [];\n    /*  Generate the fastq list csv file */\n    e.push({\n        \"entryname\":get_fastq_list_csv_path(),\n        \"entry\":generate_fastq_list_csv(fastq_list_rows)\n    });\n    /*  Generate the script to then move the files from the scratch space to the working directory */\n    e.push({\n        \"entryname\":get_ora_mv_files_script_path(),\n        \"entry\":generate_ora_mv_files_script(fastq_list_rows, input_run, output_directory_path)\n    });\n    /*  Generate the script to generate the new output fastq list csv */\n    e.push({\n        \"entryname\":get_new_fastq_list_csv_script_path(),\n        \"entry\":generate_new_fastq_list_csv_script(fastq_list_rows, input_run)\n    });\n    /*  Generate the script to generate the md5sums of the input gzipped fastq files */\n    e.push({\n        \"entryname\":get_fastq_gz_md5sum_files_script_path(),\n        \"entry\":generate_fastq_gz_md5sum_files_script(fastq_list_rows, input_run)\n    });\n    /*  Generate the script to generate the filesizes of the input gzipped fastq files */\n    e.push({\n        \"entryname\":get_fastq_gz_file_sizes_script_path(),\n        \"entry\":generate_fastq_gz_file_sizes_script(fastq_list_rows, input_run)\n    });\n    /*  Generate the script to generate the md5sums of the output ora fastq files */\n    e.push({\n        \"entryname\":get_fastq_ora_md5sum_files_script_path(),\n        \"entry\":generate_fastq_ora_md5sum_files_script(fastq_list_rows, input_run, get_ora_intermediate_output_dir())\n    });\n    /*  Generate the script to generate the filesizes of the output ora fastq files */\n    e.push({\n        \"entryname\":get_fastq_ora_file_sizes_script_path(),\n        \"entry\":generate_fastq_ora_file_sizes_script(fastq_list_rows, input_run, get_ora_intermediate_output_dir())\n    });\n    /*  Return the dirent */\n    /*  @ts-ignore Type '{ entryname:string; entry:FileProperties; }[]' is not assignable to type 'DirentProperties[]' */\n    return e;\n}\n",
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Functions */\nfunction is_not_null(input_obj) {\n    /*\n    Determine if input object is defined and is not null\n    */\n    return !(input_obj === null || input_obj === undefined);\n}\nfunction get_attribute_from_optional_input(input_object, attribute) {\n    /*\n    Get attribute from optional input -\n    If input is not defined, then return null\n    */\n    if (input_object === null || input_object === undefined) {\n        return null;\n    }\n    else {\n        return get_optional_attribute_from_object(input_object, attribute);\n    }\n}\nfunction get_optional_attribute_from_object(input_object, attribute) {\n    /*\n    Get attribute from object, if attribute is not defined return null\n    Assume the input object is an object of key value pairs where we know the key is of type string\n    stackoverflow.com/questions/56833469/typescript-error-ts7053-element-implicitly-has-an-any-type\n    */\n    if (input_object.hasOwnProperty(attribute)) {\n        return input_object[attribute];\n    }\n    else {\n        return null;\n    }\n}\nfunction get_bool_value_as_str(input_bool) {\n    if (is_not_null(input_bool) && input_bool) {\n        return \"true\";\n    }\n    else {\n        return \"false\";\n    }\n}\nfunction boolean_to_int(input_bool) {\n    if (is_not_null(input_bool) && String(input_bool).toLowerCase() === \"true\") {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nfunction get_optional_attribute_from_multi_type_input_object(object, attribute) {\n    /*\n    Get attribute from optional input\n    */\n    if (object === null || object === undefined) {\n        return null;\n    }\n    else if (typeof object === \"object\") {\n        /*  Get attribute from optional input */\n        return get_attribute_from_optional_input(object, attribute);\n    }\n    else {\n        /*  Object is likely actually a str */\n        return object;\n    }\n}\nfunction get_source_a_or_b(input_a, input_b) {\n    /*\n    Get the first input parameter if it is not null\n    Otherwise return the second parameter\n    Otherwise return null\n    */\n    if (is_not_null(input_a)) {\n        return input_a;\n    }\n    else if (is_not_null(input_b)) {\n        return input_b;\n    }\n    else {\n        return null;\n    }\n}\nfunction get_first_non_null_input(inputs) {\n    /*\n    Get first element of the array that is not null\n    */\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n        var input_element = inputs_1[_i];\n        if (is_not_null(input_element)) {\n            return input_element;\n        }\n    }\n    return null;\n}\nfunction get_attribute_list_from_object_list(obj_list, attribute) {\n    /*\n    Get attribute from list of objects\n    If an object is null, it is not included in the return list\n    */\n    return obj_list.filter(function (x) { return x !== null; }).map(function (x) { return get_optional_attribute_from_object(x, attribute); });\n}\nfunction get_str_list_as_bash_array(input_list, item_wrap) {\n    /*\n    Convert a list of strings to a bash array, if the list is not defined return null\n    */\n    if (input_list === null) {\n        return null;\n    }\n    if (item_wrap === null) {\n        return \"( \".concat(input_list.map(function (x) { return \"'\".concat(item_wrap).concat(x).concat(item_wrap, \"'\"); }).join(' '), \" )\");\n    }\n    return \"( \".concat(input_list.map(function (x) { return \"'\".concat(x, \"'\"); }).join(' '), \" )\");\n}\nfunction get_object_attribute_list_as_bash_array(obj_list, attribute) {\n    /*\n    Get attribute from list of objects and convert to a bash array\n    Do not include null values in the array\n    */\n    return get_str_list_as_bash_array(get_attribute_list_from_object_list(obj_list, attribute).filter(function (x) { return x !== null; }));\n}\n"
          ],
          "class": "InlineJavascriptRequirement"
        },
        {
          "tmpdirMin": "${\n  /* 2 Tb */\n  return Math.pow(2, 21);\n}\n",
          "class": "ResourceRequirement"
        },
        {
          "types": [
            {
              "$import": "#fastq-list-row__1.0.0.yaml/fastq-list-row"
            }
          ],
          "class": "SchemaDefRequirement"
        }
      ],
      "baseCommand": [
        "bash"
      ],
      "arguments": [
        {
          "position": -1,
          "valueFrom": "$(get_script_path())"
        },
        {
          "position": 1,
          "prefix": "--enable-variant-caller=",
          "separate": false,
          "valueFrom": "true"
        },
        {
          "prefix": "--intermediate-results-dir=",
          "separate": false,
          "valueFrom": "$(get_intermediate_results_dir())"
        }
      ],
      "inputs": [
        {
          "label": "bam input",
          "doc": "Input a normal BAM file for the variant calling stage\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--bam-input=",
            "separate": false
          },
          "secondaryFiles": [
            {
              "pattern": ".bai",
              "required": true
            }
          ],
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/bam_input"
        },
        {
          "label": "cnv enable self normalization",
          "doc": "Enable CNV self normalization.\nSelf Normalization requires that the DRAGEN hash table be generated with the enable-cnv=true option.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--cnv-enable-self-normalization=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/cnv_enable_self_normalization"
        },
        {
          "label": "cnv normal b allele vcf",
          "doc": "Specify a matched normal SNV VCF.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--cnv-normal-b-allele-vcf=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/cnv_normal_b_allele_vcf"
        },
        {
          "label": "cnv normal cnv vcf",
          "doc": "Specify germline CNVs from the matched normal sample.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--cnv-normal-cnv-vcf=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/cnv_normal_cnv_vcf"
        },
        {
          "label": "cnv population b allele vcf",
          "doc": "Specify a population SNP catalog.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--cnv-population-b-allele-vcf=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/cnv_population_b_allele_vcf"
        },
        {
          "label": "cnv somatic enable het calling",
          "doc": "Enable HET-calling mode for heterogeneous segments.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--cnv-somatic-enable-het-calling=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/cnv_somatic_enable_het_calling"
        },
        {
          "label": "cnv somatic enable lower ploidy limit",
          "doc": "To improve accuracy on the tumor ploidy model estimation, the somatic WGS CNV caller estimates whether the chosen model calls\nhomozygous deletions on regions that are likely to reduce the overall fitness of cells,\nwhich are therefore deemed to be \"essential\" and under negative selection.\nIn the current literature, recent efforts tried to map such cell-essential genes (eg, in 2015 - https://www.science.org/doi/10.1126/science.aac7041).\nThe check on essential regions is controlled with --cnv-somatic-enable-lower-ploidy-limit (default true).\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--cnv-somatic-enable-lower-ploidy-limit=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/cnv_somatic_enable_lower_ploidy_limit"
        },
        {
          "label": "cnv somatic essential genes bed",
          "doc": "Default bedfiles describing the essential regions are provided for hg19, GRCh37, hs37d5, GRCh38,\nbut a custom bedfile can also be provided in input through the\n--cnv-somatic-essential-genes-bed=<BEDFILE_PATH> parameter.\nIn such case, the feature is automatically enabled.\nA custom essential regions bedfile needs to have the following format: 4-column, tab-separated,\nwhere the first 3 columns identify the coordinates of the essential region (chromosome, 0-based start, excluded end).\nThe fourth column is the region id (string type). For the purpose of the algorithm, currently only the first 3 columns are used.\nHowever, the fourth might be helpful to investigate manually which regions drove the decisions on model plausibility made by the caller.\n",
          "type": [
            "null",
            "string",
            "File"
          ],
          "inputBinding": {
            "prefix": "--cnv-somatic-essential-genes-bed=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/cnv_somatic_essential_genes_bed"
        },
        {
          "label": "cnv use somatic vc baf",
          "doc": "If running in tumor-normal mode with the SNV caller enabled, use this option\nto specify the germline heterozygous sites.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--cnv-use-somatic-vc-baf=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/cnv_use_somatic_vc_baf"
        },
        {
          "label": "cnv use somatic vc vaf",
          "doc": "Use the variant allele frequencies (VAFs) from the somatic SNVs to help select\nthe tumor model for the sample.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--cnv-use-somatic-vc-vaf=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/cnv_use_somatic_vc_vaf"
        },
        {
          "label": "cram input",
          "doc": "Input a normal CRAM file for the variant calling stage\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--cram-input=",
            "separate": false
          },
          "secondaryFiles": [
            {
              "pattern": ".crai",
              "required": true
            }
          ],
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/cram_input"
        },
        {
          "label": "cram reference",
          "doc": "Path to the reference fasta file for the CRAM input.\nRequired only if the input is a cram file AND not the reference in the tarball\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--cram-reference=",
            "separate": false
          },
          "secondaryFiles": [
            {
              "pattern": ".fai",
              "required": true
            }
          ],
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/cram_reference"
        },
        {
          "label": "dbsnp annotation",
          "doc": "In Germline, Tumor-Normal somatic, or Tumor-Only somatic modes,\nDRAGEN can look up variant calls in a dbSNP database and add annotations for any matches that it finds there.\nTo enable the dbSNP database search, set the --dbsnp option to the full path to the dbSNP database\nVCF or .vcf.gz file, which must be sorted in reference order.\n",
          "type": [
            "null",
            "File"
          ],
          "secondaryFiles": [
            {
              "pattern": ".tbi",
              "required": true
            }
          ],
          "inputBinding": {
            "prefix": "--dbsnp=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/dbsnp_annotation"
        },
        {
          "label": "deduplicate minimum quality",
          "doc": "Specifies the Phred quality score below which a base should be excluded from the quality score\ncalculation used for choosing among duplicate reads.\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--dedup-min-qual=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/dedup_min_qual"
        },
        {
          "label": "enable cnv calling",
          "doc": "Enable CNV processing in the DRAGEN Host Software.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-cnv=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/enable_cnv"
        },
        {
          "label": "enable duplicate marking",
          "doc": "Enable the flagging of duplicate output\nalignment records.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-duplicate-marking=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/enable_duplicate_marking"
        },
        {
          "label": "enable hla",
          "doc": "Enable HLA typing by setting --enable-hla flag to true\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-hla=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/enable_hla"
        },
        {
          "label": "enable hrd",
          "doc": "Set to true to enable HRD scoring to quantify genomic instability.\nRequires somatic CNV calls.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-hrd=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/enable_hrd"
        },
        {
          "label": "enable map align",
          "doc": "Enabled by default since --enable-variant-caller option is set to true.\nSet this value to false if using bam_input AND tumor_bam_input\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-map-align=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/enable_map_align"
        },
        {
          "label": "enable map align output",
          "doc": "Enables saving the output from the\nmap/align stage. Default is true when only\nrunning map/align. Default is false if\nrunning the variant caller.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-map-align-output=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/enable_map_align_output"
        },
        {
          "label": "enable rna",
          "doc": "Set this option for running RNA samples through T/N workflow\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-rna=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/enable_rna"
        },
        {
          "label": "enable sort",
          "doc": "True by default, only set this to false if using --bam-input and --tumor-bam-input parameters\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-sort=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/enable_sort"
        },
        {
          "label": "enable sv",
          "doc": "Enable/disable structural variant\ncaller. Default is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-sv=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/enable_sv"
        },
        {
          "label": "enable tmb",
          "doc": "Enables TMB. If set, the small variant caller, Illumina Annotation Engine,\nand the related callability report are enabled.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--enable-tmb=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/enable_tmb"
        },
        {
          "label": "fastq list",
          "doc": "CSV file that contains a list of FASTQ files for normal sample\nto process. read_1 and read_2 components in the CSV file must be presigned urls.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "loadContents": true,
            "prefix": "--fastq-list=",
            "separate": false,
            "valueFrom": "$(get_fastq_list_csv_path())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/fastq_list"
        },
        {
          "label": "fastq list rows",
          "doc": "Alternative to providing a file, one can instead provide a list of 'fastq-list-row' objects for normal sample\n",
          "type": [
            "null",
            {
              "type": "array",
              "items": "#fastq-list-row__1.0.0.yaml/fastq-list-row"
            }
          ],
          "inputBinding": {
            "prefix": "--fastq-list=",
            "separate": false,
            "valueFrom": "$(get_fastq_list_csv_path())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/fastq_list_rows"
        },
        {
          "label": "hla allele frequency file",
          "doc": "Use the population-level HLA allele frequency file to break ties if one or more HLA allele produces the same or similar results.\nThe input HLA allele frequency file must be in CSV format and contain the HLA alleles and the occurrence frequency in population.\nIf --hla-allele-frequency-file is not specified, DRAGEN automatically uses hla_classI_allele_frequency.csv from /opt/edico/config/.\nPopulation-level allele frequencies can be obtained from the Allele Frequency Net database.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--hla-allele-frequency-file=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/hla_allele_frequency_file"
        },
        {
          "label": "hla bed file",
          "doc": "Use the HLA region BED input file to specify the region to extract HLA reads from.\nDRAGEN HLA Caller parses the input file for regions within the BED file, and then\nextracts reads accordingly to align with the HLA allele reference.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--hla-bed-file=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/hla_bed_file"
        },
        {
          "label": "hla min reads",
          "doc": "Set the minimum number of reads to align to HLA alleles to ensure sufficient coverage and perform HLA typing.\nThe default value is 1000 and suggested for WES samples. If using samples with less coverage, you can use a\nlower threshold value.\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--hla-min-reads=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/hla_min_reads"
        },
        {
          "label": "hla reference file",
          "doc": "Use the HLA allele reference file to specify the reference alleles to align against.\nThe input HLA reference file must be in FASTA format and contain the protein sequence separated into exons.\nIf --hla-reference-file is not specified, DRAGEN uses hla_classI_ref_freq.fasta from /opt/edico/config/.\nThe reference HLA sequences are obtained from the IMGT/HLA database.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--hla-reference-file=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/hla_reference_file"
        },
        {
          "label": "hla tiebreaker threshold",
          "doc": "If more than one allele has a similar number of reads aligned and there is not a clear indicator for the best allele,\nthe alleles are considered as ties. The HLA Caller places the tied alleles into a candidate set for tie breaking based\non the population allele frequency. If an allele has more than the specified fraction of reads aligned (normalized to\nthe top hit), then the allele is included into the candidate set for tie breaking. The default value is 0.97.\n",
          "type": [
            "null",
            "float"
          ],
          "inputBinding": {
            "prefix": "--hla-tiebreaker-threshold=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/hla_tiebreaker_threshold"
        },
        {
          "label": "hla zygosity threshold",
          "doc": "If the minor allele at a given locus has fewer reads mapped than a fraction of the read count of the major allele,\nthen the HLA Caller infers homozygosity for the given HLA-I gene. You can use this option to specify the fraction value.\nThe default value is 0.15.\n",
          "type": [
            "null",
            "float"
          ],
          "inputBinding": {
            "prefix": "--hla zygosity threshold=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/hla_zygosity_threshold"
        },
        {
          "label": "license instance id location",
          "doc": "You may wish to place your own in.\nOptional value, default set to /opt/instance-identity\nwhich is a path inside the dragen container\n",
          "type": [
            "null",
            "File",
            "string"
          ],
          "default": "/opt/instance-identity",
          "inputBinding": {
            "prefix": "--lic-instance-id-location=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/lic_instance_id_location"
        },
        {
          "label": "output directory",
          "doc": "Required - The output directory.\n",
          "type": "string",
          "inputBinding": {
            "prefix": "--output-directory=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/output_directory"
        },
        {
          "label": "output file prefix",
          "doc": "Required - the output file prefix\n",
          "type": "string",
          "inputBinding": {
            "prefix": "--output-file-prefix=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/output_file_prefix"
        },
        {
          "label": "qc coverage ignore overlaps",
          "doc": "Set to true to resolve all of the alignments for each fragment and avoid double-counting any\noverlapping bases. This might result in marginally longer run times.\nThis option also requires setting --enable-map-align=true.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--qc-coverage-ignore-overlaps=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/qc_coverage_ignore_overlaps"
        },
        {
          "label": "qc coverage region 1",
          "doc": "Generates coverage region report using bed file 1.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--qc-coverage-region-1=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/qc_coverage_region_1"
        },
        {
          "label": "qc coverage region 2",
          "doc": "Generates coverage region report using bed file 2.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--qc-coverage-region-2=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/qc_coverage_region_2"
        },
        {
          "label": "qc coverage region 3",
          "doc": "Generates coverage region report using bed file 3.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--qc-coverage-region-3=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/qc_coverage_region_3"
        },
        {
          "label": "reference tar",
          "doc": "Path to ref data tarball\n",
          "type": "File",
          "inputBinding": {
            "prefix": "--ref-dir=",
            "separate": false,
            "valueFrom": "$(get_ref_path(self))"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/reference_tar"
        },
        {
          "label": "repeat genotype enable",
          "doc": "Enables repeat expansion detection.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--repeat-genotype-enable=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/repeat_genotype_enable"
        },
        {
          "label": "repeat genotype specs",
          "doc": "Specifies the full path to the JSON file that contains the\nrepeat variant catalog (specification) describing the loci to call.\nIf the option is not provided, DRAGEN attempts to autodetect the applicable catalog file\nfrom /opt/edico/repeat-specs/ based on the reference provided.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--repeate-genotype-specs=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/repeat_genotype_specs"
        },
        {
          "label": "repeat genotype use catalog",
          "doc": "Repeat variant catalog type to use (default - ~60 repeats, default_plus_smn -\nsame as default with SMN repeat, expanded - ~50K repeats)\n",
          "type": [
            "null",
            {
              "type": "enum",
              "symbols": [
                "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/repeat_genotype_use_catalog/default",
                "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/repeat_genotype_use_catalog/default_plus_smn",
                "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/repeat_genotype_use_catalog/expanded"
              ]
            }
          ],
          "inputBinding": {
            "prefix": "--repeat-genotype-use-catalog=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/repeat_genotype_use_catalog"
        },
        {
          "label": "sample sex",
          "doc": "Specifies the sex of a sample\n",
          "type": [
            "null",
            {
              "type": "enum",
              "symbols": [
                "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sample_sex/none",
                "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sample_sex/auto",
                "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sample_sex/male",
                "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sample_sex/female"
              ]
            }
          ],
          "inputBinding": {
            "prefix": "--sample-sex=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sample_sex"
        },
        {
          "label": "sv call regions bed",
          "doc": "Specifies a BED file containing the set of regions to call.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--sv-call-regions-bed=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sv_call_regions_bed"
        },
        {
          "label": "sv discovery",
          "doc": "Enable SV discovery. This flag can be set to false only when --sv-forcegt-vcf is used.\nWhen set to false, SV discovery is disabled and only the forced genotyping input variants\nare processed. The default is true.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--sv-discovery=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sv_discovery"
        },
        {
          "label": "sv enable liquid tumor mode",
          "doc": "Enable liquid tumor mode.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--sv-enable-liquid-tumor-mode=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sv_enable_liquid_tumor_mode"
        },
        {
          "label": "sv enable somatic ins tandup hotspot regions",
          "doc": "Enable or disable the ITD hotspot region input. The default is true in somatic variant analysis.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--sv-enable-somatic-ins-tandup-hotspot-regions=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sv_enable_somatic_ins_tandup_hotspot_regions"
        },
        {
          "label": "sv exome",
          "doc": "Set to true to configure the variant caller for targeted sequencing inputs,\nwhich includes disabling high depth filters.\nIn integrated mode, the default is to autodetect targeted sequencing input,\nand in standalone mode the default is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--sv-exome=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sv_exome"
        },
        {
          "label": "sv forcegt vcf",
          "doc": "Specify a VCF of structural variants for forced genotyping. The variants are scored and emitted\nin the output VCF even if not found in the sample data.\nThe variants are merged with any additional variants discovered directly from the sample data.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--sv-forcegt-vcf=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sv_forcegt_vcf"
        },
        {
          "label": "sv output contigs",
          "doc": "Set to true to have assembled contig sequences output in a VCF file. The default is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--sv-output-contigs=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sv_output_contigs"
        },
        {
          "label": "sv region",
          "doc": "Limit the analysis to a specified region of the genome for debugging purposes.\nThis option can be specified multiple times to build a list of regions.\nThe value must be in the format \"chr:startPos-endPos\"..\n",
          "type": [
            "null",
            "string"
          ],
          "inputBinding": {
            "prefix": "--sv-region=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sv_region"
        },
        {
          "label": "sv use overlap pair evidence",
          "doc": "Allow overlapping read pairs to be considered as evidence.\nBy default, DRAGEN uses autodetect on the fraction of overlapping read pairs if <20%.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--sv-use-overlap-pair-evidence=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sv_se_overlap_pair_evidence"
        },
        {
          "label": "sv somatic ins tandup hotspot regions bed",
          "doc": "Specify a BED of ITD hotspot regions to increase sensitivity for calling ITDs in somatic variant analysis.\nBy default, DRAGEN SV automatically selects areference-specific hotspots BED file from\n/opt/edico/config/sv_somatic_ins_tandup_hotspot_*.bed.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--sv-somatic-ins-tandup-hotspot-regions-bed=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sv_somatic_ins_tandup_hotspot_regions_bed"
        },
        {
          "label": "sv tin contam tolerance",
          "doc": "Set the Tumor-in-Normal (TiN) contamination tolerance level.\nYou can enter any value between 0-1. The default maximum TiN contamination tolerance is 0.15.\n",
          "type": [
            "null",
            "float"
          ],
          "inputBinding": {
            "prefix": "--sv-tin-contam-tolerance=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/sv_tin_contam_tolerance"
        },
        {
          "label": "tmb db threshold",
          "doc": "Specify the minimum allele count (total number of observations) for an allele in gnomAD or 1000 Genome\nto be considered a germline variant.  Variant calls that have the same positions and allele are ignored\nfrom the TMB calculation. The default value is 10.\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--tmb-db-threshold=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/tmb_db_threshold"
        },
        {
          "label": "tmb vaf threshold",
          "doc": "Specify the minimum VAF threshold for a variant. Variants that do not meet the threshold are filtered out.\nThe default value is 0.05.\n",
          "type": [
            "null",
            "float"
          ],
          "inputBinding": {
            "prefix": "--tmb-db-threshold=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/tmb_vaf_threshold"
        },
        {
          "label": "tumor bam input",
          "doc": "Input a tumor BAM file for the variant calling stage\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--tumor-bam-input=",
            "separate": false
          },
          "secondaryFiles": [
            {
              "pattern": ".bai",
              "required": true
            }
          ],
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/tumor_bam_input"
        },
        {
          "label": "tumor cram input",
          "doc": "Input a tumor CRAM file for the variant calling stage\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--tumor-cram-input=",
            "separate": false
          },
          "secondaryFiles": [
            {
              "pattern": ".crai",
              "required": true
            }
          ],
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/tumor_cram_input"
        },
        {
          "label": "tumor fastq list",
          "doc": "CSV file that contains a list of FASTQ files\nto process. read_1 and read_2 components in the CSV file must be presigned urls.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--tumor-fastq-list=",
            "separate": false,
            "valueFrom": "$(get_tumor_fastq_list_csv_path())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/tumor_fastq_list"
        },
        {
          "label": "tumor fastq list rows",
          "doc": "Alternative to providing a file, one can instead provide a list of 'fastq-list-row' objects for tumor sample\n",
          "type": [
            "null",
            {
              "type": "array",
              "items": "#fastq-list-row__1.0.0.yaml/fastq-list-row"
            }
          ],
          "inputBinding": {
            "prefix": "--tumor-fastq-list=",
            "separate": false,
            "valueFrom": "$(get_tumor_fastq_list_csv_path())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/tumor_fastq_list_rows"
        },
        {
          "label": "vc af call threshold",
          "type": [
            "null",
            "float"
          ],
          "doc": "Set the allele frequency call threshold to emit a call in the VCF if the AF filter is enabled.\nThe default is 0.01.\n",
          "inputBinding": {
            "prefix": "--vc-af-call-threshold=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_af_call_threshold"
        },
        {
          "label": "vc af call threshold mito",
          "doc": "If the AF filter is enabled using --vc-enable-af-filter-mito=true,\nthe option sets the allele frequency call threshold to emit a call in the VCF for mitochondrial variant calling.\nThe default value is 0.01.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-af-call-threshold-mito=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_af_call_threshold_mito"
        },
        {
          "label": "vc af filter threshold",
          "type": [
            "null",
            "float"
          ],
          "doc": "Set the allele frequency filter threshold to mark emitted VCF calls as filtered if the AF filter is\nenabled.\nThe default is 0.05.\n",
          "inputBinding": {
            "prefix": "--vc-af-filter-threshold=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_af_filter_threshold"
        },
        {
          "label": "vc af filter threshold mito",
          "doc": "If the AF filter is enabled using --vc-enable-af-filter-mito=true,\nthe option sets the allele frequency filter threshold to mark emitted VCF calls\nas filtered for mitochondrial variant calling. The default value is 0.02.\n",
          "type": [
            "null",
            "float"
          ],
          "inputBinding": {
            "prefix": "--vc-af-filter-threshold-mito=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_af_filter_threshold_mito"
        },
        {
          "label": "vc base qual threshold",
          "doc": "(Replaces --vc-min-base-qual)\nSpecifies the minimum base quality to be considered in the active region detection of the small variant caller.\nThe default value is 10.\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--vc-base-qual-threshold=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_base_qual_threshold"
        },
        {
          "label": "vc callability normal thresh",
          "type": [
            "null",
            "int"
          ],
          "doc": "The --vc-callability-normal-thresh option specifies the callability threshold for normal samples.\nThe somatic callable regions report includes all regions with normal coverage above the normal threshold.\n",
          "inputBinding": {
            "prefix": "--vc-callability-normal-thresh=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_callability_normal_thresh"
        },
        {
          "label": "vc callability tumor thresh",
          "type": [
            "null",
            "int"
          ],
          "doc": "The --vc-callability-tumor-thresh option specifies the callability threshold for tumor samples. The\nsomatic callable regions report includes all regions with tumor coverage above the tumor threshold.\n",
          "inputBinding": {
            "prefix": "--vc-callability-tumor-thresh=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_callability_tumor_thresh"
        },
        {
          "label": "vc combine phased variants distance",
          "doc": "When the specified value is greater than 0, combines all phased variants in the phasing set that have a distance\nless than or equal to the provided value. The max allowed phasing distance is 15.\nThe default value is 0, which disables the option.\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--vc-combine-phased-variants-distance=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_combine_phased_variants_distance"
        },
        {
          "label": "vc combine phased variants max vaf delta",
          "doc": "Component SNVs/INDELs of MNV calls are output only if the VAF of the component\ncall is greater than that of the MNV by more than 0.1. The VAF difference\nthreshold for outputting component calls along with MNV calls can be controlled by\nthe --vc-combine-phased-variants-max-vaf-delta option.\nThis option is mutually exclusive with --vc-mnv-emit-component-calls\n",
          "type": [
            "null",
            "float"
          ],
          "inputBinding": {
            "prefix": "--vc-combine-phased-variants-max-vaf-delta=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_combine_phased_variants_max_vaf_delta"
        },
        {
          "label": "vc decoy contigs",
          "doc": "The --vc-decoy-contigs option specifies a comma-separated list of contigs to skip during variant calling.\nThis option can be set in the configuration file.\n",
          "type": [
            "null",
            "string"
          ],
          "inputBinding": {
            "prefix": "--vc-decoy-contigs=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_decoy_contigs"
        },
        {
          "label": "vc enable af filter",
          "type": [
            "null",
            "boolean"
          ],
          "doc": "Enables the allele frequency filter. The default value is false. When set to true, the VCF excludes variants\nwith allele frequencies below the AF call threshold or variants with an allele frequency below the AF filter\nthreshold and tagged with low AF filter tag. The default AF call threshold is 1% and the default AF filter\nthreshold is 5%.\nTo change the threshold values, use the following command line options:\n  --vc-af-callthreshold and --vc-af-filter-threshold.\n",
          "inputBinding": {
            "prefix": "--vc-enable-af-filter=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_af_filter"
        },
        {
          "label": "vc enable baf",
          "doc": "Enable or disable B-allele frequency output. Enabled by default.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-baf=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_baf"
        },
        {
          "label": "vc enable decoy contigs",
          "doc": "If --vc-enable-decoy-contigs is set to true, variant calls on the decoy contigs are enabled.\nThe default value is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-decoy-contigs=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_decoy_contigs"
        },
        {
          "label": "vc enable gatk acceleration",
          "doc": "If is set to true, the variant caller runs in GATK mode\n(concordant with GATK 3.7 in germline mode and GATK 4.0 in somatic mode).\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-gatk-acceleration=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_gatk_acceleration"
        },
        {
          "label": "vc enable liquid tumor mode",
          "type": [
            "null",
            "boolean"
          ],
          "doc": "In a tumor-normal analysis, DRAGEN accounts for tumor-in-normal (TiN) contamination by running liquid\ntumor mode. Liquid tumor mode is disabled by default. When liquid tumor mode is enabled, DRAGEN is\nable to call variants in the presence of TiN contamination up to a specified maximum tolerance level.\nvc-enable-liquid-tumor-mode enables liquid tumor mode with a default maximum contamination\nTiN tolerance of 0.15. If using the default maximum contamination TiN tolerance, somatic variants are\nexpected to be observed in the normal sample with allele frequencies up to 15% of the corresponding\nallele in the tumor sample.\n",
          "inputBinding": {
            "prefix": "--vc-enable-liquid-tumor-mode=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_liquid_tumor_mode"
        },
        {
          "label": "vc enable non homoref normal filter",
          "doc": "Enables the non-homref normal filter. The default value is true. When set to true, the VCF filters out\nvariants if the normal sample genotype is not a homozygous reference.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-non-homref-normal-filter=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_non_homref_normal_filter"
        },
        {
          "label": "vc enable non primary allelic filter",
          "doc": "Similar to vc-enable-triallelic-filter, but less aggressive.\nKeep the allele per position with highest alt AD, and only filter the rest.\nThe default is false. Not compatible with vc-enable-triallelic-filter.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-non-primary-allelic-filter=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_non_primary_allelic_filter"
        },
        {
          "label": "vc enable orientation bias filter",
          "type": [
            "null",
            "boolean"
          ],
          "doc": "Enables the orientation bias filter. The default value is false, which means the option is disabled.\n",
          "inputBinding": {
            "prefix": "--vc-enable-orientation-bias-filter=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_orientation_bias_filter"
        },
        {
          "label": "vc enable orientation bias filter artifacts",
          "type": [
            "null",
            "string"
          ],
          "doc": "The artifact type to be filtered can be specified with the --vc-orientation-bias-filter-artifacts option.\nThe default is C/T,G/T, which correspond to OxoG and FFPE artifacts. Valid values include C/T, or G/T, or C/T,G/T,C/A.\nAn artifact (or an artifact and its reverse compliment) cannot be listed twice.\nFor example, C/T,G/A is not valid, because C->G and T->A are reverse compliments.\n",
          "inputBinding": {
            "prefix": "--vc-enable-orientation-bias-filter-artifacts=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_orientation_bias_filter_artifacts"
        },
        {
          "label": "vc enable phasing",
          "doc": "The -vc-enable-phasing option enables variants to be phased when possible. The default value is true.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-phasing=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_phasing"
        },
        {
          "label": "vc enable roh",
          "doc": "Enable or disable the ROH caller by setting this option to true or false. Enabled by default for human autosomes only.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-roh=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_roh"
        },
        {
          "label": "vc enable triallelic filter",
          "type": [
            "null",
            "boolean"
          ],
          "doc": "Enables the multiallelic filter. The default is true.\n",
          "inputBinding": {
            "prefix": "--vc-enable-triallelic-filter=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_triallelic_filter"
        },
        {
          "label": "vc enable unequal ntd",
          "doc": "Nucleotide (NTD) Error Bias Estimation is on by default and recommended as a replacement for the orientation bias filter.\nBoth methods take account of strand-specific biases (systematic differences between F1R2 and F2R1 reads).\nIn addition, NTD error estimation accounts for non-strand-specific biases such as sample-wide elevation of a certain SNV type,\neg C->T or any other transition or transversion.\nNTD error estimation can also capture the biases in a trinucleotide context.\n",
          "type": [
            "null",
            "boolean",
            {
              "type": "enum",
              "symbols": [
                "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_unequal_ntd/true",
                "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_unequal_ntd/false",
                "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_unequal_ntd/auto"
              ]
            }
          ],
          "inputBinding": {
            "prefix": "--vc-enable-unequal-ntd=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_unequal_ntd"
        },
        {
          "label": "vc enable vcf output",
          "doc": "The -vc-enable-vcf-output option enables VCF file output during a gVCF run. The default value is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-enable-vcf-output=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_enable_vcf_output"
        },
        {
          "label": "vc hard filter",
          "doc": "DRAGEN provides post-VCF variant filtering based on annotations present in the VCF records.\nHowever, due to the nature of DRAGEN's algorithms, which incorporate the hypothesis of correlated errors\nfrom within the core of variant caller, the pipeline has improved capabilities in distinguishing\nthe true variants from noise, and therefore the dependency on post-VCF filtering is substantially reduced.\nFor this reason, the default post-VCF filtering in DRAGEN is very simple\n",
          "type": [
            "null",
            "string"
          ],
          "inputBinding": {
            "prefix": "--vc-hard-filter=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_hard_filter"
        },
        {
          "label": "vc hotspot log10 prior boost",
          "type": [
            "null",
            "int"
          ],
          "doc": "The size of the hotspot adjustment can be controlled via vc-hotspotlog10-prior-boost,\nwhich has a default value of 4 (log10 scale) corresponding to an increase of 40 phred.\n",
          "inputBinding": {
            "prefix": "--vc-hotspot-log10-prior-boost=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_hotspot_log10_prior_boost"
        },
        {
          "label": "vc max reads per active region",
          "doc": "specifies the maximum number of reads covering a given active region.\nDefault is 10000 for the somatic workflow\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--vc-max-reads-per-active-region=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_max_reads_per_active_region"
        },
        {
          "label": "vc max reads per raw region",
          "doc": "specifies the maximum number of reads covering a given raw region.\nDefault is 30000 for the somatic workflow\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--vc-max-read-per-raw-region=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_max_reads_per_raw_region"
        },
        {
          "label": "vc min tumor read qual",
          "type": [
            "null",
            "int"
          ],
          "doc": "The --vc-min-tumor-read-qual option specifies the minimum read quality (MAPQ) to be considered for\nvariant calling. The default value is 3 for tumor-normal analysis or 20 for tumor-only analysis.\n",
          "inputBinding": {
            "prefix": "--vc-min-tumor-read-qual=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_min_tumor_read_qual"
        },
        {
          "label": "vc mnv emit component calls",
          "doc": "To output all component SNVs/INDELs of MNVs, regardless of VAF difference,\nwhen enabled, use the option --vc-mnv-emit-component-calls.\nThis option is mutually exclusive with --vc-combine-phased-variants-max-vaf-delta\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-mnv-emit-component-calls=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_mnv_emit_component_calls"
        },
        {
          "label": "vc remove all soft clips",
          "doc": "If is set to true, the variant caller does not use soft clips of reads to determine variants.\n",
          "type": [
            "null",
            "boolean"
          ],
          "inputBinding": {
            "prefix": "--vc-remove-all-soft-clips=",
            "separate": false,
            "valueFrom": "$(self.toString())"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_remove_all_soft_clips"
        },
        {
          "label": "vc roh blacklist bed",
          "doc": "If provided, the ROH caller ignores variants that are contained in any region in the blacklist BED file.\nDRAGEN distributes blacklist files for all popular human genomes and automatically selects a blacklist to\nmatch the genome in use, unless this option is used explicitly select a file.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--vc-roh-blacklist-bed=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_roh_blacklist_bed"
        },
        {
          "label": "vc somatic hotspots",
          "type": [
            "null",
            "File"
          ],
          "doc": "The somatic hotspots option allows an input VCF to specify the positions where the risk for somatic\nmutations are assumed to be significantly elevated. DRAGEN genotyping priors are boosted for all\npostions specified in the VCF, so it is possible to call a variant at one of these sites with fewer supporting\nreads. The cosmic database in VCF format can be used as one source of prior information to boost\nsensitivity for known somatic mutations.\n",
          "inputBinding": {
            "prefix": "--vc-somatic-hotspots=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_somatic_hotspots"
        },
        {
          "label": "vc sq call threshold",
          "type": [
            "null",
            "float"
          ],
          "doc": "Emits calls in the VCF. The default is 3.\nIf the value for vc-sq-filter-threshold is lower than vc-sq-callthreshold,\nthe filter threshold value is used instead of the call threshold value\n",
          "inputBinding": {
            "prefix": "--vc-sq-call-threshold=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_sq_call_threshold"
        },
        {
          "label": "vc sq filter threshold",
          "type": [
            "null",
            "float"
          ],
          "doc": "Marks emitted VCF calls as filtered.\nThe default is 17.5 for tumor-normal and 6.5 for tumor-only.\n",
          "inputBinding": {
            "prefix": "--vc-sq-filter-threshold=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_sq_filter_threshold"
        },
        {
          "label": "vc target bed",
          "doc": "This is an optional command line input that restricts processing of the small variant caller,\ntarget bed related coverage, and callability metrics to regions specified in a BED file.\n",
          "type": [
            "null",
            "File"
          ],
          "inputBinding": {
            "prefix": "--vc-target-bed=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_target_bed"
        },
        {
          "label": "vc target bed padding",
          "doc": "This is an optional command line input that can be used to pad all of the target\nBED regions with the specified value.\nFor example, if a BED region is 1:1000-2000 and a padding value of 100 is used,\nit is equivalent to using a BED region of 1:900-2100 and a padding value of 0.\n\nAny padding added to --vc-target-bed-padding is used by the small variant caller\nand by the target bed coverage/callability reports. The default padding is 0.\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--vc-target-bed-padding=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_target_bed_padding"
        },
        {
          "label": "vc target coverage",
          "doc": "The --vc-target-coverage option specifies the target coverage for down-sampling.\nThe default value is 500 for germline mode and 50 for somatic mode.\n",
          "type": [
            "null",
            "int"
          ],
          "inputBinding": {
            "prefix": "--vc-target-coverage=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_target_coverage"
        },
        {
          "label": "vc target vaf",
          "doc": "The vc-target-vaf is used to select the variant allele frequencies of interest.\nThe variant caller will aim to detect variants with allele frequencies larger than this setting.\nWe recommend adding a small safety factor, e.g. to ensure variants in the ballpark of 1% are detected,\nthe minimum vc-target-vaf can be specified as 0.009 (0.9%). This setting will not apply a hard threshold,\nand it is possible to detect variants with allele frequencies lower than the selected threshold.\nOn high coverage and clean datasets, a lower target-vaf may help increase sensitivity.\nOn noisy samples (like FFPE) a higher target-vaf (like 0.03) maybe help reduce false positives.\nUsing a low target-vaf may also increase runtime. Set the vc-target-vaf to 0 to disable this feature.\nWhen this feature is disabled the variant caller will require at least 2 supporting reads to discover a candidate variant.\nDefault=0.01.\n",
          "type": [
            "null",
            "float"
          ],
          "inputBinding": {
            "prefix": "--vc-target-vaf=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_target_vaf"
        },
        {
          "label": "vc tin contam tolerance",
          "type": [
            "null",
            "float"
          ],
          "doc": "vc-tin-contam-tolerance enables liquid tumor mode and allows you to\nset the maximum contamination TiN tolerance. The maximum contamination TiN tolerance must be\ngreater than zero. For example, vc-tin-contam-tolerance=-0.1.\n",
          "inputBinding": {
            "prefix": "--vc-tin-contam-tolerance=",
            "separate": false
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/vc_tin_contam_tolerance"
        }
      ],
      "outputs": [
        {
          "label": "dragen somatic output directory",
          "doc": "Output directory containing all outputs of the somatic dragen run\n",
          "type": "Directory",
          "outputBinding": {
            "glob": "$(inputs.output_directory)"
          },
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/dragen_somatic_output_directory"
        },
        {
          "label": "output normal bam",
          "doc": "Bam file of the normal sample\nExists only if --enable-map-align-output set to true\n",
          "type": [
            "null",
            "File"
          ],
          "outputBinding": {
            "glob": "$(inputs.output_directory)/$(get_normal_output_prefix(inputs)).bam"
          },
          "secondaryFiles": [
            {
              "pattern": ".bai",
              "required": null
            }
          ],
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/normal_bam_out"
        },
        {
          "label": "somatic snv vcf filetered",
          "doc": "Output of the snv vcf filtered tumor calls\n",
          "type": [
            "null",
            "File"
          ],
          "outputBinding": {
            "glob": "$(inputs.output_directory)/$(inputs.output_file_prefix).hard-filtered.vcf.gz"
          },
          "secondaryFiles": [
            {
              "pattern": ".tbi",
              "required": null
            }
          ],
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/somatic_snv_vcf_hard_filtered_out"
        },
        {
          "label": "somatic snv vcf",
          "doc": "Output of the snv vcf tumor calls\n",
          "type": [
            "null",
            "File"
          ],
          "outputBinding": {
            "glob": "$(inputs.output_directory)/$(inputs.output_file_prefix).vcf.gz"
          },
          "secondaryFiles": [
            {
              "pattern": ".tbi",
              "required": null
            }
          ],
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/somatic_snv_vcf_out"
        },
        {
          "label": "somatic sv vcf filetered",
          "doc": "Output of the sv vcf filtered tumor calls.\nExists only if --enable-sv is set to true.\n",
          "type": [
            "null",
            "File"
          ],
          "outputBinding": {
            "glob": "$(inputs.output_directory)/$(inputs.output_file_prefix).sv.vcf.gz"
          },
          "secondaryFiles": [
            {
              "pattern": ".tbi",
              "required": null
            }
          ],
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/somatic_structural_vcf_out"
        },
        {
          "label": "output tumor bam",
          "doc": "Bam file of the tumor sample.\nExists only if --enable-map-align-output set to true\n",
          "type": [
            "null",
            "File"
          ],
          "outputBinding": {
            "glob": "$(inputs.output_directory)/$(inputs.output_file_prefix)_tumor.bam"
          },
          "secondaryFiles": [
            {
              "pattern": ".bai",
              "required": null
            }
          ],
          "id": "#dragen-somatic__4.3.6.cwl/dragen-somatic--4.3.6/tumor_bam_out"
        }
      ],
      "successCodes": [
        0
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "CommandLineTool",
      "id": "#multiqc__1.25.1.cwl",
      "label": "multiqc v(1.25.0)",
      "doc": "Documentation for multiqc v1.25.0\nUse patch that includes https://github.com/ewels/MultiQC/pull/1969\n",
      "hints": [
        {
          "dockerPull": "ghcr.io/multiqc/multiqc:v1.25.1",
          "class": "DockerRequirement"
        },
        {
          "coresMin": 2,
          "ramMin": 4000,
          "class": "ResourceRequirement",
          "https://platform.illumina.com/rdf/ica/resources:tier": "standard",
          "https://platform.illumina.com/rdf/ica/resources:type": "standard",
          "https://platform.illumina.com/rdf/ica/resources:size": "small"
        }
      ],
      "requirements": [
        {
          "class": "InlineJavascriptRequirement"
        }
      ],
      "baseCommand": [
        "multiqc"
      ],
      "inputs": [
        {
          "label": "cl config",
          "doc": "Override config from the cli\n",
          "type": [
            "null",
            "string"
          ],
          "inputBinding": {
            "prefix": "--cl-config"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/cl_config"
        },
        {
          "label": "comment",
          "doc": "Custom comment, will be printed at the top of the report.\n",
          "type": [
            "null",
            "string"
          ],
          "inputBinding": {
            "prefix": "--comment"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/comment"
        },
        {
          "label": "config",
          "doc": "Configuration file for bclconvert\n",
          "type": [
            "null",
            "File"
          ],
          "streamable": true,
          "inputBinding": {
            "prefix": "--config"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/config"
        },
        {
          "label": "input directories",
          "doc": "The list of directories to place in the analysis\n",
          "type": {
            "type": "array",
            "items": "Directory"
          },
          "inputBinding": {
            "position": 100
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/input_directories"
        },
        {
          "label": "output directory",
          "doc": "The output directory\n",
          "type": "string",
          "inputBinding": {
            "prefix": "--outdir",
            "valueFrom": "$(runtime.outdir)/$(self)"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/output_directory_name"
        },
        {
          "label": "output filename",
          "doc": "Report filename in html format.\nDefaults to 'multiqc-report.html\"\n",
          "type": "string",
          "inputBinding": {
            "prefix": "--filename"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/output_filename"
        },
        {
          "label": "title",
          "doc": "Report title.\nPrinted as page header, used for filename if not otherwise specified.\n",
          "type": "string",
          "inputBinding": {
            "prefix": "--title"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/title"
        }
      ],
      "outputs": [
        {
          "label": "output directory",
          "doc": "Directory that contains all multiqc analysis data\n",
          "type": "Directory",
          "outputBinding": {
            "glob": "$(inputs.output_directory_name)"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/output_directory"
        },
        {
          "label": "output file",
          "doc": "Output html file\n",
          "type": "File",
          "outputBinding": {
            "glob": "$(inputs.output_directory_name)/$(inputs.output_filename)"
          },
          "id": "#multiqc__1.25.1.cwl/multiqc--1.25.0/output_file"
        }
      ],
      "successCodes": [
        0
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    },
    {
      "class": "Workflow",
      "id": "#main",
      "label": "dragen-somatic-with-germline-pipeline v(4.3.6)",
      "doc": "Documentation for dragen-somatic-with-germline-pipeline\nv4.3.6\n",
      "requirements": [
        {
          "expressionLib": [
            "/*  Author:Alexis Lucattini */\n/*  For assistance on generation of typescript expressions */\n/*  In CWL, please visit our wiki page at https://github.com/umccr/cwl-ica/wiki/TypeScript */\n/*  Imports */\n/*  Functions */\nfunction is_not_null(input_obj) {\n    /*\n    Determine if input object is defined and is not null\n    */\n    return !(input_obj === null || input_obj === undefined);\n}\nfunction get_attribute_from_optional_input(input_object, attribute) {\n    /*\n    Get attribute from optional input -\n    If input is not defined, then return null\n    */\n    if (input_object === null || input_object === undefined) {\n        return null;\n    }\n    else {\n        return get_optional_attribute_from_object(input_object, attribute);\n    }\n}\nfunction get_optional_attribute_from_object(input_object, attribute) {\n    /*\n    Get attribute from object, if attribute is not defined return null\n    Assume the input object is an object of key value pairs where we know the key is of type string\n    stackoverflow.com/questions/56833469/typescript-error-ts7053-element-implicitly-has-an-any-type\n    */\n    if (input_object.hasOwnProperty(attribute)) {\n        return input_object[attribute];\n    }\n    else {\n        return null;\n    }\n}\nfunction get_bool_value_as_str(input_bool) {\n    if (is_not_null(input_bool) && input_bool) {\n        return \"true\";\n    }\n    else {\n        return \"false\";\n    }\n}\nfunction boolean_to_int(input_bool) {\n    if (is_not_null(input_bool) && String(input_bool).toLowerCase() === \"true\") {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nfunction get_optional_attribute_from_multi_type_input_object(object, attribute) {\n    /*\n    Get attribute from optional input\n    */\n    if (object === null || object === undefined) {\n        return null;\n    }\n    else if (typeof object === \"object\") {\n        /*  Get attribute from optional input */\n        return get_attribute_from_optional_input(object, attribute);\n    }\n    else {\n        /*  Object is likely actually a str */\n        return object;\n    }\n}\nfunction get_source_a_or_b(input_a, input_b) {\n    /*\n    Get the first input parameter if it is not null\n    Otherwise return the second parameter\n    Otherwise return null\n    */\n    if (is_not_null(input_a)) {\n        return input_a;\n    }\n    else if (is_not_null(input_b)) {\n        return input_b;\n    }\n    else {\n        return null;\n    }\n}\nfunction get_first_non_null_input(inputs) {\n    /*\n    Get first element of the array that is not null\n    */\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n        var input_element = inputs_1[_i];\n        if (is_not_null(input_element)) {\n            return input_element;\n        }\n    }\n    return null;\n}\nfunction get_attribute_list_from_object_list(obj_list, attribute) {\n    /*\n    Get attribute from list of objects\n    If an object is null, it is not included in the return list\n    */\n    return obj_list.filter(function (x) { return x !== null; }).map(function (x) { return get_optional_attribute_from_object(x, attribute); });\n}\nfunction get_str_list_as_bash_array(input_list, item_wrap) {\n    /*\n    Convert a list of strings to a bash array, if the list is not defined return null\n    */\n    if (input_list === null) {\n        return null;\n    }\n    if (item_wrap === null) {\n        return \"( \".concat(input_list.map(function (x) { return \"'\".concat(item_wrap).concat(x).concat(item_wrap, \"'\"); }).join(' '), \" )\");\n    }\n    return \"( \".concat(input_list.map(function (x) { return \"'\".concat(x, \"'\"); }).join(' '), \" )\");\n}\nfunction get_object_attribute_list_as_bash_array(obj_list, attribute) {\n    /*\n    Get attribute from list of objects and convert to a bash array\n    Do not include null values in the array\n    */\n    return get_str_list_as_bash_array(get_attribute_list_from_object_list(obj_list, attribute).filter(function (x) { return x !== null; }));\n}\n"
          ],
          "class": "InlineJavascriptRequirement"
        },
        {
          "class": "MultipleInputFeatureRequirement"
        },
        {
          "class": "ScatterFeatureRequirement"
        },
        {
          "types": [
            {
              "$import": "#fastq-list-row__1.0.0.yaml/fastq-list-row"
            }
          ],
          "class": "SchemaDefRequirement"
        },
        {
          "class": "StepInputExpressionRequirement"
        }
      ],
      "inputs": [
        {
          "label": "bam input",
          "doc": "Input a normal BAM file for the variant calling stage\n",
          "type": [
            "null",
            "File"
          ],
          "secondaryFiles": [
            {
              "pattern": ".bai",
              "required": true
            }
          ],
          "id": "#main/bam_input"
        },
        {
          "label": "cnv enable self normalization",
          "doc": "Enable CNV self normalization.\nSelf Normalization requires that the DRAGEN hash table be generated with the enable-cnv=true option.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/cnv_enable_self_normalization"
        },
        {
          "label": "cnv normal b allele vcf",
          "doc": "Specify a matched normal SNV VCF.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/cnv_normal_b_allele_vcf"
        },
        {
          "label": "cnv normal cnv vcf",
          "doc": "Specify germline CNVs from the matched normal sample.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/cnv_normal_cnv_vcf"
        },
        {
          "label": "cnv population b allele vcf",
          "doc": "Specify a population SNP catalog.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/cnv_population_b_allele_vcf"
        },
        {
          "label": "cnv somatic enable het calling",
          "doc": "Enable HET-calling mode for heterogeneous segments.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/cnv_somatic_enable_het_calling"
        },
        {
          "label": "cnv somatic enable lower ploidy limit",
          "doc": "To improve accuracy on the tumor ploidy model estimation, the somatic WGS CNV caller estimates whether the chosen model calls\nhomozygous deletions on regions that are likely to reduce the overall fitness of cells,\nwhich are therefore deemed to be \"essential\" and under negative selection.\nIn the current literature, recent efforts tried to map such cell-essential genes (eg, in 2015 - https://www.science.org/doi/10.1126/science.aac7041).\nThe check on essential regions is controlled with --cnv-somatic-enable-lower-ploidy-limit (default true).\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/cnv_somatic_enable_lower_ploidy_limit"
        },
        {
          "label": "cnv somatic essential genes bed",
          "doc": "Default bedfiles describing the essential regions are provided for hg19, GRCh37, hs37d5, GRCh38,\nbut a custom bedfile can also be provided in input through the\n--cnv-somatic-essential-genes-bed=<BEDFILE_PATH> parameter.\nIn such case, the feature is automatically enabled.\nA custom essential regions bedfile needs to have the following format: 4-column, tab-separated,\nwhere the first 3 columns identify the coordinates of the essential region (chromosome, 0-based start, excluded end).\nThe fourth column is the region id (string type). For the purpose of the algorithm, currently only the first 3 columns are used.\nHowever, the fourth might be helpful to investigate manually which regions drove the decisions on model plausibility made by the caller.\n",
          "type": [
            "null",
            "string",
            "File"
          ],
          "id": "#main/cnv_somatic_essential_genes_bed"
        },
        {
          "label": "cnv use somatic vc baf",
          "doc": "If running in tumor-normal mode with the SNV caller enabled, use this option\nto specify the germline heterozygous sites.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/cnv_use_somatic_vc_baf"
        },
        {
          "label": "cnv use somatic vc vaf",
          "doc": "Use the variant allele frequencies (VAFs) from the somatic SNVs to help select\nthe tumor model for the sample.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/cnv_use_somatic_vc_vaf"
        },
        {
          "label": "cram input",
          "doc": "Input a normal CRAM file for the variant calling stage\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/cram_input"
        },
        {
          "label": "cram reference",
          "doc": "Path to the reference fasta file for the CRAM input.\nRequired only if the input is a cram file AND not the reference in the tarball\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/cram_reference"
        },
        {
          "label": "dbsnp annotation",
          "doc": "In Germline, Tumor-Normal somatic, or Tumor-Only somatic modes,\nDRAGEN can look up variant calls in a dbSNP database and add annotations for any matches that it finds there.\nTo enable the dbSNP database search, set the --dbsnp option to the full path to the dbSNP database\nVCF or .vcf.gz file, which must be sorted in reference order.\n",
          "type": [
            "null",
            "File"
          ],
          "secondaryFiles": [
            {
              "pattern": ".tbi",
              "required": true
            }
          ],
          "id": "#main/dbsnp_annotation"
        },
        {
          "label": "deduplicate minimum quality",
          "doc": "Specifies the Phred quality score below which a base should be excluded from the quality score\ncalculation used for choosing among duplicate reads.\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/dedup_min_qual"
        },
        {
          "label": "deduplicate minimum quality germline",
          "doc": "Specifies the Phred quality score below which a base should be excluded from the quality score\ncalculation used for choosing among duplicate reads.\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/dedup_min_qual_germline"
        },
        {
          "label": "deduplicate minimum quality somatic",
          "doc": "Specifies the Phred quality score below which a base should be excluded from the quality score\ncalculation used for choosing among duplicate reads.\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/dedup_min_qual_somatic"
        },
        {
          "label": "enable cnv calling",
          "doc": "Enable CNV processing in the DRAGEN Host Software.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_cnv"
        },
        {
          "label": "enable cnv germline",
          "doc": "Enable CNV processing in the DRAGEN Host Software (somatic only)\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_cnv_germline"
        },
        {
          "label": "enable cnv somatic",
          "doc": "Enable CNV processing in the DRAGEN Host Software (germline only)\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_cnv_somatic"
        },
        {
          "label": "enable duplicate marking",
          "doc": "Enable the flagging of duplicate output\nalignment records.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_duplicate_marking"
        },
        {
          "label": "enable duplicate marking germline",
          "doc": "Enable the flagging of duplicate output\nalignment records.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_duplicate_marking_germline"
        },
        {
          "label": "enable duplicate marking somatic",
          "doc": "Enable the flagging of duplicate output\nalignment records.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_duplicate_marking_somatic"
        },
        {
          "label": "enable hla",
          "doc": "Enable HLA typing by setting --enable-hla flag to true\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_hla"
        },
        {
          "label": "enable hrd",
          "doc": "Set to true to enable HRD scoring to quantify genomic instability.\nRequires somatic CNV calls.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_hrd"
        },
        {
          "label": "enable map align",
          "doc": "Enabled by default since --enable-variant-caller option is set to true.\nSet this value to false if using bam_input\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_map_align"
        },
        {
          "label": "enable map align germline",
          "doc": "Enabled by default since --enable-variant-caller option is set to true.\nSet this value to false if using bam_input\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_map_align_germline"
        },
        {
          "label": "enable map align output",
          "doc": "Enables saving the output from the\nmap/align stage. Default is true when only\nrunning map/align. Default is false if\nrunning the variant caller.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_map_align_output"
        },
        {
          "label": "enable map align output germline",
          "doc": "Enables saving the output from the\nmap/align stage. Default is true when only\nrunning map/align. Default is false if\nrunning the variant caller.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_map_align_output_germline"
        },
        {
          "label": "enable map align output somatic",
          "doc": "Enables saving the output from the\nmap/align stage. Default is true when only\nrunning map/align. Default is false if\nrunning the variant caller.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_map_align_output_somatic"
        },
        {
          "label": "enable map align somatic",
          "doc": "Enabled by default since --enable-variant-caller option is set to true.\nSet this value to false if using bam_input\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_map_align_somatic"
        },
        {
          "label": "enable rna",
          "doc": "Set this option for running RNA samples through T/N workflow\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_rna"
        },
        {
          "label": "enable sort",
          "doc": "True by default, only set this to false if using --bam-input parameter\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_sort"
        },
        {
          "label": "enable sort germline",
          "doc": "True by default, only set this to false if using --bam-input parameter\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_sort_germline"
        },
        {
          "label": "enable sort somatic",
          "doc": "True by default, only set this to false if using --bam-input parameter\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_sort_somatic"
        },
        {
          "label": "enable sv",
          "doc": "Enable/disable structural variant\ncaller. Default is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_sv"
        },
        {
          "label": "enable sv germline",
          "doc": "Enable/disable structural variant\ncaller. Default is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_sv_germline"
        },
        {
          "label": "enable sv somatic",
          "doc": "Enable/disable structural variant\ncaller. Default is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_sv_somatic"
        },
        {
          "label": "enable tmb",
          "doc": "Enables TMB. If set, the small variant caller, Illumina Annotation Engine,\nand the related callability report are enabled.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/enable_tmb"
        },
        {
          "label": "fastq list",
          "doc": "CSV file that contains a list of FASTQ files for normal sample\nto process.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/fastq_list"
        },
        {
          "label": "Row of fastq lists",
          "doc": "The row of fastq lists.\nEach row has the following attributes:\n  * RGID\n  * RGLB\n  * RGSM\n  * Lane\n  * Read1File\n  * Read2File (optional)\n",
          "type": [
            "null",
            {
              "type": "array",
              "items": "#fastq-list-row__1.0.0.yaml/fastq-list-row"
            }
          ],
          "id": "#main/fastq_list_rows"
        },
        {
          "label": "hla allele frequency file",
          "doc": "Use the population-level HLA allele frequency file to break ties if one or more HLA allele produces the same or similar results.\nThe input HLA allele frequency file must be in CSV format and contain the HLA alleles and the occurrence frequency in population.\nIf --hla-allele-frequency-file is not specified, DRAGEN automatically uses hla_classI_allele_frequency.csv from /opt/edico/config/.\nPopulation-level allele frequencies can be obtained from the Allele Frequency Net database.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/hla_allele_frequency_file"
        },
        {
          "label": "hla bed file",
          "doc": "Use the HLA region BED input file to specify the region to extract HLA reads from.\nDRAGEN HLA Caller parses the input file for regions within the BED file, and then\nextracts reads accordingly to align with the HLA allele reference.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/hla_bed_file"
        },
        {
          "label": "hla min reads",
          "doc": "Set the minimum number of reads to align to HLA alleles to ensure sufficient coverage and perform HLA typing.\nThe default value is 1000 and suggested for WES samples. If using samples with less coverage, you can use a\nlower threshold value.\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/hla_min_reads"
        },
        {
          "label": "hla reference file",
          "doc": "Use the HLA allele reference file to specify the reference alleles to align against.\nThe input HLA reference file must be in FASTA format and contain the protein sequence separated into exons.\nIf --hla-reference-file is not specified, DRAGEN uses hla_classI_ref_freq.fasta from /opt/edico/config/.\nThe reference HLA sequences are obtained from the IMGT/HLA database.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/hla_reference_file"
        },
        {
          "label": "hla tiebreaker threshold",
          "doc": "If more than one allele has a similar number of reads aligned and there is not a clear indicator for the best allele,\nthe alleles are considered as ties. The HLA Caller places the tied alleles into a candidate set for tie breaking based\non the population allele frequency. If an allele has more than the specified fraction of reads aligned (normalized to\nthe top hit), then the allele is included into the candidate set for tie breaking. The default value is 0.97.\n",
          "type": [
            "null",
            "float"
          ],
          "id": "#main/hla_tiebreaker_threshold"
        },
        {
          "label": "hla zygosity threshold",
          "doc": "If the minor allele at a given locus has fewer reads mapped than a fraction of the read count of the major allele,\nthen the HLA Caller infers homozygosity for the given HLA-I gene. You can use this option to specify the fraction value.\nThe default value is 0.15.\n",
          "type": [
            "null",
            "float"
          ],
          "id": "#main/hla_zygosity_threshold"
        },
        {
          "label": "license instance id location",
          "doc": "You may wish to place your own in.\nOptional value, default set to /opt/instance-identity\nwhich is a path inside the dragen container\n",
          "type": [
            "null",
            "File",
            "string"
          ],
          "default": "/opt/instance-identity",
          "id": "#main/lic_instance_id_location"
        },
        {
          "label": "output prefix germline",
          "doc": "The prefix given to all outputs for the dragen germline pipeline\n",
          "type": "string",
          "id": "#main/output_prefix_germline"
        },
        {
          "label": "output prefix somatic",
          "doc": "The prefix given to all outputs for the dragen somatic pipeline\n",
          "type": "string",
          "id": "#main/output_prefix_somatic"
        },
        {
          "label": "qc coverage ignore overlaps",
          "doc": "Set to true to resolve all of the alignments for each fragment and avoid double-counting any\noverlapping bases. This might result in marginally longer run times.\nThis option also requires setting --enable-map-align=true.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/qc_coverage_ignore_overlaps"
        },
        {
          "label": "qc coverage region 1",
          "doc": "Generates coverage region report using bed file 1.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/qc_coverage_region_1"
        },
        {
          "label": "qc coverage region 2",
          "doc": "Generates coverage region report using bed file 2.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/qc_coverage_region_2"
        },
        {
          "label": "qc coverage region 3",
          "doc": "Generates coverage region report using bed file 3.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/qc_coverage_region_3"
        },
        {
          "label": "reference tar",
          "doc": "Path to ref data tarball\n",
          "type": "File",
          "id": "#main/reference_tar"
        },
        {
          "label": "repeat genotype enable",
          "doc": "Enables repeat expansion detection.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/repeat_genotype_enable"
        },
        {
          "label": "repeat genotype specs",
          "doc": "Specifies the full path to the JSON file that contains the\nrepeat variant catalog (specification) describing the loci to call.\nIf the option is not provided, DRAGEN attempts to autodetect the applicable catalog file\nfrom /opt/edico/repeat-specs/ based on the reference provided.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/repeat_genotype_specs"
        },
        {
          "label": "repeat genotype use catalog",
          "doc": "Repeat variant catalog type to use (default - ~60 repeats, default_plus_smn -\nsame as default with SMN repeat, expanded - ~50K repeats)\n",
          "type": [
            "null",
            {
              "type": "enum",
              "symbols": [
                "#main/repeat_genotype_use_catalog/default",
                "#main/repeat_genotype_use_catalog/default_plus_smn",
                "#main/repeat_genotype_use_catalog/expanded"
              ]
            }
          ],
          "id": "#main/repeat_genotype_use_catalog"
        },
        {
          "label": "sample sex",
          "doc": "Specifies the sex of a sample\n",
          "type": [
            "null",
            {
              "type": "enum",
              "symbols": [
                "#main/sample_sex/male",
                "#main/sample_sex/female"
              ]
            }
          ],
          "id": "#main/sample_sex"
        },
        {
          "label": "sv call regions bed",
          "doc": "Specifies a BED file containing the set of regions to call.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/sv_call_regions_bed"
        },
        {
          "label": "sv discovery",
          "doc": "Enable SV discovery. This flag can be set to false only when --sv-forcegt-vcf is used.\nWhen set to false, SV discovery is disabled and only the forced genotyping input variants\nare processed. The default is true.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/sv_discovery"
        },
        {
          "label": "sv enable liquid tumor mode",
          "doc": "Enable liquid tumor mode.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/sv_enable_liquid_tumor_mode"
        },
        {
          "label": "sv enable somatic ins tandup hotspot regions",
          "doc": "Enable or disable the ITD hotspot region input. The default is true in somatic variant analysis.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/sv_enable_somatic_ins_tandup_hotspot_regions"
        },
        {
          "label": "sv exome",
          "doc": "Set to true to configure the variant caller for targeted sequencing inputs,\nwhich includes disabling high depth filters.\nIn integrated mode, the default is to autodetect targeted sequencing input,\nand in standalone mode the default is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/sv_exome"
        },
        {
          "label": "sv forcegt vcf",
          "doc": "Specify a VCF of structural variants for forced genotyping. The variants are scored and emitted\nin the output VCF even if not found in the sample data.\nThe variants are merged with any additional variants discovered directly from the sample data.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/sv_forcegt_vcf"
        },
        {
          "label": "sv output contigs",
          "doc": "Set to true to have assembled contig sequences output in a VCF file. The default is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/sv_output_contigs"
        },
        {
          "label": "sv region",
          "doc": "Limit the analysis to a specified region of the genome for debugging purposes.\nThis option can be specified multiple times to build a list of regions.\nThe value must be in the format \"chr:startPos-endPos\"..\n",
          "type": [
            "null",
            "string"
          ],
          "id": "#main/sv_region"
        },
        {
          "label": "sv use overlap pair evidence",
          "doc": "Allow overlapping read pairs to be considered as evidence.\nBy default, DRAGEN uses autodetect on the fraction of overlapping read pairs if <20%.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/sv_se_overlap_pair_evidence"
        },
        {
          "label": "sv somatic ins tandup hotspot regions bed",
          "doc": "Specify a BED of ITD hotspot regions to increase sensitivity for calling ITDs in somatic variant analysis.\nBy default, DRAGEN SV automatically selects areference-specific hotspots BED file from\n/opt/edico/config/sv_somatic_ins_tandup_hotspot_*.bed.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/sv_somatic_ins_tandup_hotspot_regions_bed"
        },
        {
          "label": "sv tin contam tolerance",
          "doc": "Set the Tumor-in-Normal (TiN) contamination tolerance level.\nYou can enter any value between 0-1. The default maximum TiN contamination tolerance is 0.15.\n",
          "type": [
            "null",
            "float"
          ],
          "id": "#main/sv_tin_contam_tolerance"
        },
        {
          "label": "tmb db threshold",
          "doc": "Specify the minimum allele count (total number of observations) for an allele in gnomAD or 1000 Genome\nto be considered a germline variant.  Variant calls that have the same positions and allele are ignored\nfrom the TMB calculation. The default value is 10.\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/tmb_db_threshold"
        },
        {
          "label": "tmb vaf threshold",
          "doc": "Specify the minimum VAF threshold for a variant. Variants that do not meet the threshold are filtered out.\nThe default value is 0.05.\n",
          "type": [
            "null",
            "float"
          ],
          "id": "#main/tmb_vaf_threshold"
        },
        {
          "label": "tumor bam input",
          "doc": "Input a tumor BAM file for the variant calling stage\n",
          "type": [
            "null",
            "File"
          ],
          "secondaryFiles": [
            {
              "pattern": ".bai",
              "required": true
            }
          ],
          "id": "#main/tumor_bam_input"
        },
        {
          "label": "tumor cram input",
          "doc": "Input a tumor CRAM file for the variant calling stage\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/tumor_cram_input"
        },
        {
          "label": "tumor fastq list",
          "doc": "CSV file that contains a list of FASTQ files\nto process.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/tumor_fastq_list"
        },
        {
          "label": "Row of fastq lists",
          "doc": "The row of fastq lists.\nEach row has the following attributes:\n  * RGID\n  * RGLB\n  * RGSM\n  * Lane\n  * Read1File\n  * Read2File (optional)\n",
          "type": [
            "null",
            {
              "type": "array",
              "items": "#fastq-list-row__1.0.0.yaml/fastq-list-row"
            }
          ],
          "id": "#main/tumor_fastq_list_rows"
        },
        {
          "label": "vc af call threshold",
          "type": [
            "null",
            "float"
          ],
          "doc": "Set the allele frequency call threshold to emit a call in the VCF if the AF filter is enabled.\nThe default is 0.01.\n",
          "id": "#main/vc_af_call_threshold"
        },
        {
          "label": "vc af call threshold mito",
          "doc": "If the AF filter is enabled using --vc-enable-af-filter-mito=true,\nthe option sets the allele frequency call threshold to emit a call in the VCF for mitochondrial variant calling.\nThe default value is 0.01.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/vc_af_call_threshold_mito"
        },
        {
          "label": "vc af filter threshold",
          "type": [
            "null",
            "float"
          ],
          "doc": "Set the allele frequency filter threshold to mark emitted VCF calls as filtered if the AF filter is\nenabled.\nThe default is 0.05.\n",
          "id": "#main/vc_af_filter_threshold"
        },
        {
          "label": "vc af filter threshold mito",
          "doc": "If the AF filter is enabled using --vc-enable-af-filter-mito=true,\nthe option sets the allele frequency filter threshold to mark emitted VCF calls\nas filtered for mitochondrial variant calling. The default value is 0.02.\n",
          "type": [
            "null",
            "float"
          ],
          "id": "#main/vc_af_filter_threshold_mito"
        },
        {
          "label": "vc base qual threshold",
          "doc": "(Replaces --vc-min-base-qual)\nSpecifies the minimum base quality to be considered in the active region detection of the small variant caller.\nThe default value is 10.\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/vc_base_qual_threshold"
        },
        {
          "label": "vc base qual threshold germline",
          "doc": "(Replaces --vc-min-base-qual)\nSpecifies the minimum base quality to be considered in the active region detection of the small variant caller.\nThe default value is 10.\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/vc_base_qual_threshold_germline"
        },
        {
          "label": "vc base qual threshold somatic",
          "doc": "(Replaces --vc-min-base-qual)\nSpecifies the minimum base quality to be considered in the active region detection of the small variant caller.\nThe default value is 10.\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/vc_base_qual_threshold_somatic"
        },
        {
          "label": "vc callability normal thresh",
          "type": [
            "null",
            "int"
          ],
          "doc": "The --vc-callability-normal-thresh option specifies the callability threshold for normal samples.\nThe somatic callable regions report includes all regions with normal coverage above the normal threshold.\n",
          "id": "#main/vc_callability_normal_thresh"
        },
        {
          "label": "vc callability tumor thresh",
          "type": [
            "null",
            "int"
          ],
          "doc": "The --vc-callability-tumor-thresh option specifies the callability threshold for tumor samples. The\nsomatic callable regions report includes all regions with tumor coverage above the tumor threshold.\n",
          "id": "#main/vc_callability_tumor_thresh"
        },
        {
          "label": "vc combine phased variants distance somatic",
          "doc": "When the specified value is greater than 0, combines all phased variants in the phasing set that have a distance\nless than or equal to the provided value. The max allowed phasing distance is 15.\nThe default value is 0, which disables the option.\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/vc_combine_phased_variants_distance_somatic"
        },
        {
          "label": "vc combine phased variants max vaf delta somatic",
          "doc": "Component SNVs/INDELs of MNV calls are output only if the VAF of the component\ncall is greater than that of the MNV by more than 0.1. The VAF difference\nthreshold for outputting component calls along with MNV calls can be controlled by\nthe --vc-combine-phased-variants-max-vaf-delta option.\nThis option is mutually exclusive with --vc-mnv-emit-component-calls\n",
          "type": [
            "null",
            "float"
          ],
          "id": "#main/vc_combine_phased_variants_max_vaf_delta_somatic"
        },
        {
          "label": "vc decoy contigs",
          "doc": "The --vc-decoy-contigs option specifies a comma-separated list of contigs to skip during variant calling.\nThis option can be set in the configuration file.\n",
          "type": [
            "null",
            "string"
          ],
          "id": "#main/vc_decoy_contigs"
        },
        {
          "label": "vc enable af filter",
          "type": [
            "null",
            "boolean"
          ],
          "doc": "Enables the allele frequency filter. The default value is false. When set to true, the VCF excludes variants\nwith allele frequencies below the AF call threshold or variants with an allele frequency below the AF filter\nthreshold and tagged with low AF filter tag. The default AF call threshold is 1% and the default AF filter\nthreshold is 5%.\nTo change the threshold values, use the following command line options:\n  --vc-af-callthreshold and --vc-af-filter-threshold.\n",
          "id": "#main/vc_enable_af_filter"
        },
        {
          "label": "vc enable baf",
          "doc": "Enable or disable B-allele frequency output. Enabled by default.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/vc_enable_baf"
        },
        {
          "label": "vc enable decoy contigs",
          "doc": "If --vc-enable-decoy-contigs is set to true, variant calls on the decoy contigs are enabled.\nThe default value is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/vc_enable_decoy_contigs"
        },
        {
          "label": "vc enable gatk acceleration",
          "doc": "If is set to true, the variant caller runs in GATK mode\n(concordant with GATK 3.7 in germline mode and GATK 4.0 in somatic mode).\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/vc_enable_gatk_acceleration"
        },
        {
          "label": "vc enable liquid tumor mode",
          "type": [
            "null",
            "boolean"
          ],
          "doc": "In a tumor-normal analysis, DRAGEN accounts for tumor-in-normal (TiN) contamination by running liquid\ntumor mode. Liquid tumor mode is disabled by default. When liquid tumor mode is enabled, DRAGEN is\nable to call variants in the presence of TiN contamination up to a specified maximum tolerance level.\nvc-enable-liquid-tumor-mode enables liquid tumor mode with a default maximum contamination\nTiN tolerance of 0.15. If using the default maximum contamination TiN tolerance, somatic variants are\nexpected to be observed in the normal sample with allele frequencies up to 15% of the corresponding\nallele in the tumor sample.\n",
          "id": "#main/vc_enable_liquid_tumor_mode"
        },
        {
          "label": "vc enable non homoref normal filter",
          "doc": "Enables the non-homref normal filter. The default value is true. When set to true, the VCF filters out\nvariants if the normal sample genotype is not a homozygous reference.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/vc_enable_non_homref_normal_filter"
        },
        {
          "label": "vc enable non primary allelic filter",
          "doc": "Similar to vc-enable-triallelic-filter, but less aggressive.\nKeep the allele per position with highest alt AD, and only filter the rest.\nThe default is false. Not compatible with vc-enable-triallelic-filter.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/vc_enable_non_primary_allelic_filter"
        },
        {
          "label": "vc enable orientation bias filter",
          "type": [
            "null",
            "boolean"
          ],
          "doc": "Enables the orientation bias filter. The default value is false, which means the option is disabled.\n",
          "id": "#main/vc_enable_orientation_bias_filter"
        },
        {
          "label": "vc enable orientation bias filter artifacts",
          "type": [
            "null",
            "string"
          ],
          "doc": "The artifact type to be filtered can be specified with the --vc-orientation-bias-filter-artifacts option.\nThe default is C/T,G/T, which correspond to OxoG and FFPE artifacts. Valid values include C/T, or G/T, or C/T,G/T,C/A.\nAn artifact (or an artifact and its reverse compliment) cannot be listed twice.\nFor example, C/T,G/A is not valid, because C->G and T->A are reverse compliments.\n",
          "id": "#main/vc_enable_orientation_bias_filter_artifacts"
        },
        {
          "label": "vc enable phasing",
          "doc": "The -vc-enable-phasing option enables variants to be phased when possible. The default value is true.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/vc_enable_phasing"
        },
        {
          "label": "vc enable roh",
          "doc": "Enable or disable the ROH caller by setting this option to true or false. Enabled by default for human autosomes only.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/vc_enable_roh"
        },
        {
          "label": "vc enable triallelic filter",
          "type": [
            "null",
            "boolean"
          ],
          "doc": "Enables the multiallelic filter. The default is true.\n",
          "id": "#main/vc_enable_triallelic_filter"
        },
        {
          "label": "vc enable unequal ntd",
          "doc": "Nucleotide (NTD) Error Bias Estimation is on by default and recommended as a replacement for the orientation bias filter.\nBoth methods take account of strand-specific biases (systematic differences between F1R2 and F2R1 reads).\nIn addition, NTD error estimation accounts for non-strand-specific biases such as sample-wide elevation of a certain SNV type,\neg C->T or any other transition or transversion.\nNTD error estimation can also capture the biases in a trinucleotide context.\n",
          "type": [
            "null",
            "boolean",
            {
              "type": "enum",
              "symbols": [
                "#main/vc_enable_unequal_ntd/true",
                "#main/vc_enable_unequal_ntd/false",
                "#main/vc_enable_unequal_ntd/auto"
              ]
            }
          ],
          "id": "#main/vc_enable_unequal_ntd"
        },
        {
          "label": "vc enable vcf output",
          "doc": "The -vc-enable-vcf-output option enables VCF file output during a gVCF run. The default value is false.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/vc_enable_vcf_output"
        },
        {
          "label": "vc forcegt vcf",
          "doc": "AGENsupports force genotyping (ForceGT) for Germline SNV variant calling.\nTo use ForceGT, use the --vc-forcegt-vcf option with a list of small variants to force genotype.\nThe input list of small variants can be a .vcf or .vcf.gz file.\n\nThe current limitations of ForceGT are as follows:\n*\tForceGT is supported for Germline SNV variant calling in the V3 mode.\nThe V1, V2, and V2+ modes are not supported.\n*\tForceGT is not supported for Somatic SNV variant calling.\n*\tForceGT variants do not propagate through Joint Genotyping.\n",
          "type": [
            "null",
            "File"
          ],
          "secondaryFiles": [
            {
              "pattern": ".tbi",
              "required": true
            }
          ],
          "id": "#main/vc_forcegt_vcf"
        },
        {
          "label": "vc hard filter",
          "doc": "DRAGEN provides post-VCF variant filtering based on annotations present in the VCF records.\nHowever, due to the nature of DRAGEN's algorithms, which incorporate the hypothesis of correlated errors\nfrom within the core of variant caller, the pipeline has improved capabilities in distinguishing\nthe true variants from noise, and therefore the dependency on post-VCF filtering is substantially reduced.\nFor this reason, the default post-VCF filtering in DRAGEN is very simple\n",
          "type": [
            "null",
            "string"
          ],
          "id": "#main/vc_hard_filter"
        },
        {
          "label": "vc hotspot log10 prior boost",
          "type": [
            "null",
            "int"
          ],
          "doc": "The size of the hotspot adjustment can be controlled via vc-hotspotlog10-prior-boost,\nwhich has a default value of 4 (log10 scale) corresponding to an increase of 40 phred.\n",
          "id": "#main/vc_hotspot_log10_prior_boost"
        },
        {
          "label": "vc max reads per active region",
          "doc": "specifies the maximum number of reads covering a given active region.\nDefault is 10000 for the somatic workflow\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/vc_max_reads_per_active_region"
        },
        {
          "label": "vc max reads per raw region",
          "doc": "specifies the maximum number of reads covering a given raw region.\nDefault is 30000 for the somatic workflow\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/vc_max_reads_per_raw_region"
        },
        {
          "label": "vc min tumor read qual",
          "type": [
            "null",
            "int"
          ],
          "doc": "The --vc-min-tumor-read-qual option specifies the minimum read quality (MAPQ) to be considered for\nvariant calling. The default value is 3 for tumor-normal analysis or 20 for tumor-only analysis.\n",
          "id": "#main/vc_min_tumor_read_qual"
        },
        {
          "label": "vc mnv emit component calls somatic",
          "doc": "To output all component SNVs/INDELs of MNVs, regardless of VAF difference,\nwhen enabled, use the option --vc-mnv-emit-component-calls.\nThis option is mutually exclusive with --vc-combine-phased-variants-max-vaf-delta\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/vc_mnv_emit_component_calls_somatic"
        },
        {
          "label": "vc remove all soft clips",
          "doc": "If is set to true, the variant caller does not use soft clips of reads to determine variants.\n",
          "type": [
            "null",
            "boolean"
          ],
          "id": "#main/vc_remove_all_soft_clips"
        },
        {
          "label": "vc roh blacklist bed",
          "doc": "If provided, the ROH caller ignores variants that are contained in any region in the blacklist BED file.\nDRAGEN distributes blacklist files for all popular human genomes and automatically selects a blacklist to\nmatch the genome in use, unless this option is used explicitly select a file.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/vc_roh_blacklist_bed"
        },
        {
          "label": "vc somatic hotspots",
          "type": [
            "null",
            "File"
          ],
          "doc": "The somatic hotspots option allows an input VCF to specify the positions where the risk for somatic\nmutations are assumed to be significantly elevated. DRAGEN genotyping priors are boosted for all\npostions specified in the VCF, so it is possible to call a variant at one of these sites with fewer supporting\nreads. The cosmic database in VCF format can be used as one source of prior information to boost\nsensitivity for known somatic mutations.\n",
          "id": "#main/vc_somatic_hotspots"
        },
        {
          "label": "vc sq call threshold",
          "type": [
            "null",
            "float"
          ],
          "doc": "Emits calls in the VCF. The default is 3.\nIf the value for vc-sq-filter-threshold is lower than vc-sq-callthreshold,\nthe filter threshold value is used instead of the call threshold value\n",
          "id": "#main/vc_sq_call_threshold"
        },
        {
          "label": "vc sq filter threshold",
          "type": [
            "null",
            "float"
          ],
          "doc": "Marks emitted VCF calls as filtered.\nThe default is 17.5 for tumor-normal and 6.5 for tumor-only.\n",
          "id": "#main/vc_sq_filter_threshold"
        },
        {
          "label": "vc target bed",
          "doc": "This is an optional command line input that restricts processing of the small variant caller,\ntarget bed related coverage, and callability metrics to regions specified in a BED file.\n",
          "type": [
            "null",
            "File"
          ],
          "id": "#main/vc_target_bed"
        },
        {
          "label": "vc target bed padding",
          "doc": "This is an optional command line input that can be used to pad all of the target\nBED regions with the specified value.\nFor example, if a BED region is 1:1000-2000 and a padding value of 100 is used,\nit is equivalent to using a BED region of 1:900-2100 and a padding value of 0.\n\nAny padding added to --vc-target-bed-padding is used by the small variant caller\nand by the target bed coverage/callability reports. The default padding is 0.\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/vc_target_bed_padding"
        },
        {
          "label": "vc target coverage",
          "doc": "The --vc-target-coverage option specifies the target coverage for down-sampling.\nThe default value is 500 for germline mode and 50 for somatic mode.\n",
          "type": [
            "null",
            "int"
          ],
          "id": "#main/vc_target_coverage"
        },
        {
          "label": "vc target vaf somatic",
          "doc": "The vc-target-vaf is used to select the variant allele frequencies of interest.\nThe variant caller will aim to detect variants with allele frequencies larger than this setting.\nWe recommend adding a small safety factor, e.g. to ensure variants in the ballpark of 1% are detected,\nthe minimum vc-target-vaf can be specified as 0.009 (0.9%). This setting will not apply a hard threshold,\nand it is possible to detect variants with allele frequencies lower than the selected threshold.\nOn high coverage and clean datasets, a lower target-vaf may help increase sensitivity.\nOn noisy samples (like FFPE) a higher target-vaf (like 0.03) maybe help reduce false positives.\nUsing a low target-vaf may also increase runtime. Set the vc-target-vaf to 0 to disable this feature.\nWhen this feature is disabled the variant caller will require at least 2 supporting reads to discover a candidate variant.\nDefault=0.01.\n",
          "type": [
            "null",
            "float"
          ],
          "id": "#main/vc_target_vaf_somatic"
        },
        {
          "label": "vc tin contam tolerance",
          "type": [
            "null",
            "float"
          ],
          "doc": "vc-tin-contam-tolerance enables liquid tumor mode and allows you to\nset the maximum contamination TiN tolerance. The maximum contamination TiN tolerance must be\ngreater than zero. For example, vc-tin-contam-tolerance=-0.1.\n",
          "id": "#main/vc_tin_contam_tolerance"
        }
      ],
      "steps": [
        {
          "label": "get normal bam out",
          "doc": "Get the normal bam value from one of the two available options\nFrom the germline step (preferred)\nFrom the somatic step (backup option)\n",
          "in": [
            {
              "source": [
                "#main/run_dragen_germline_step/dragen_bam_out",
                "#main/run_dragen_somatic_step/normal_bam_out"
              ],
              "id": "#main/get_normal_bam_out/input_bams"
            }
          ],
          "out": [
            {
              "id": "#main/get_normal_bam_out/output_bam_file"
            }
          ],
          "run": "#get-first-non-null-bam-file__1.0.0.cwl",
          "id": "#main/get_normal_bam_out"
        },
        {
          "label": "run dragen germline step",
          "doc": "Runs the dragen germline workflow on the FPGA.\nTakes in either a fastq list as a file or a fastq_list_rows schema object\n",
          "in": [
            {
              "source": "#main/bam_input",
              "id": "#main/run_dragen_germline_step/bam_input"
            },
            {
              "source": "#main/cnv_enable_self_normalization",
              "id": "#main/run_dragen_germline_step/cnv_enable_self_normalization"
            },
            {
              "source": "#main/cram_input",
              "id": "#main/run_dragen_germline_step/cram_input"
            },
            {
              "source": "#main/cram_reference",
              "id": "#main/run_dragen_germline_step/cram_reference"
            },
            {
              "source": "#main/dbsnp_annotation",
              "id": "#main/run_dragen_germline_step/dbsnp_annotation"
            },
            {
              "source": [
                "#main/dedup_min_qual_germline",
                "#main/dedup_min_qual"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_germline_step/dedup_min_qual"
            },
            {
              "source": [
                "#main/enable_cnv_germline",
                "#main/enable_cnv"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_germline_step/enable_cnv"
            },
            {
              "source": [
                "#main/enable_duplicate_marking_germline",
                "#main/enable_duplicate_marking"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_germline_step/enable_duplicate_marking"
            },
            {
              "source": "#main/enable_hla",
              "id": "#main/run_dragen_germline_step/enable_hla"
            },
            {
              "source": [
                "#main/enable_map_align_germline",
                "#main/enable_map_align"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_germline_step/enable_map_align"
            },
            {
              "source": [
                "#main/enable_map_align_output_germline",
                "#main/enable_map_align_output"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_germline_step/enable_map_align_output"
            },
            {
              "source": [
                "#main/enable_sort_germline",
                "#main/enable_sort"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_germline_step/enable_sort"
            },
            {
              "source": [
                "#main/enable_sv_germline",
                "#main/enable_sv"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_germline_step/enable_sv"
            },
            {
              "source": "#main/fastq_list",
              "id": "#main/run_dragen_germline_step/fastq_list"
            },
            {
              "source": "#main/fastq_list_rows",
              "id": "#main/run_dragen_germline_step/fastq_list_rows"
            },
            {
              "source": "#main/hla_allele_frequency_file",
              "id": "#main/run_dragen_germline_step/hla_allele_frequency_file"
            },
            {
              "source": "#main/hla_bed_file",
              "id": "#main/run_dragen_germline_step/hla_bed_file"
            },
            {
              "source": "#main/hla_min_reads",
              "id": "#main/run_dragen_germline_step/hla_min_reads"
            },
            {
              "source": "#main/hla_reference_file",
              "id": "#main/run_dragen_germline_step/hla_reference_file"
            },
            {
              "source": "#main/hla_tiebreaker_threshold",
              "id": "#main/run_dragen_germline_step/hla_tiebreaker_threshold"
            },
            {
              "source": "#main/hla_zygosity_threshold",
              "id": "#main/run_dragen_germline_step/hla_zygosity_threshold"
            },
            {
              "source": "#main/lic_instance_id_location",
              "id": "#main/run_dragen_germline_step/lic_instance_id_location"
            },
            {
              "source": "#main/output_prefix_germline",
              "valueFrom": "$(self)_dragen_germline",
              "id": "#main/run_dragen_germline_step/output_directory"
            },
            {
              "source": "#main/output_prefix_germline",
              "id": "#main/run_dragen_germline_step/output_file_prefix"
            },
            {
              "source": "#main/qc_coverage_ignore_overlaps",
              "id": "#main/run_dragen_germline_step/qc_coverage_ignore_overlaps"
            },
            {
              "source": "#main/qc_coverage_region_1",
              "id": "#main/run_dragen_germline_step/qc_coverage_region_1"
            },
            {
              "source": "#main/qc_coverage_region_2",
              "id": "#main/run_dragen_germline_step/qc_coverage_region_2"
            },
            {
              "source": "#main/qc_coverage_region_3",
              "id": "#main/run_dragen_germline_step/qc_coverage_region_3"
            },
            {
              "source": "#main/reference_tar",
              "id": "#main/run_dragen_germline_step/reference_tar"
            },
            {
              "source": "#main/sample_sex",
              "id": "#main/run_dragen_germline_step/sample_sex"
            },
            {
              "source": "#main/sv_call_regions_bed",
              "id": "#main/run_dragen_germline_step/sv_call_regions_bed"
            },
            {
              "source": "#main/sv_discovery",
              "id": "#main/run_dragen_germline_step/sv_discovery"
            },
            {
              "source": "#main/sv_enable_liquid_tumor_mode",
              "id": "#main/run_dragen_germline_step/sv_enable_liquid_tumor_mode"
            },
            {
              "source": "#main/sv_exome",
              "id": "#main/run_dragen_germline_step/sv_exome"
            },
            {
              "source": "#main/sv_forcegt_vcf",
              "id": "#main/run_dragen_germline_step/sv_forcegt_vcf"
            },
            {
              "source": "#main/sv_output_contigs",
              "id": "#main/run_dragen_germline_step/sv_output_contigs"
            },
            {
              "source": "#main/sv_region",
              "id": "#main/run_dragen_germline_step/sv_region"
            },
            {
              "source": "#main/sv_se_overlap_pair_evidence",
              "id": "#main/run_dragen_germline_step/sv_se_overlap_pair_evidence"
            },
            {
              "source": "#main/sv_tin_contam_tolerance",
              "id": "#main/run_dragen_germline_step/sv_tin_contam_tolerance"
            },
            {
              "source": [
                "#main/vc_base_qual_threshold_germline",
                "#main/vc_base_qual_threshold"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_germline_step/vc_base_qual_threshold"
            },
            {
              "source": "#main/vc_decoy_contigs",
              "id": "#main/run_dragen_germline_step/vc_decoy_contigs"
            },
            {
              "source": "#main/vc_enable_baf",
              "id": "#main/run_dragen_germline_step/vc_enable_baf"
            },
            {
              "source": "#main/vc_enable_decoy_contigs",
              "id": "#main/run_dragen_germline_step/vc_enable_decoy_contigs"
            },
            {
              "source": "#main/vc_enable_gatk_acceleration",
              "id": "#main/run_dragen_germline_step/vc_enable_gatk_acceleration"
            },
            {
              "source": "#main/vc_enable_phasing",
              "id": "#main/run_dragen_germline_step/vc_enable_phasing"
            },
            {
              "source": "#main/vc_enable_roh",
              "id": "#main/run_dragen_germline_step/vc_enable_roh"
            },
            {
              "source": "#main/vc_enable_vcf_output",
              "id": "#main/run_dragen_germline_step/vc_enable_vcf_output"
            },
            {
              "source": "#main/vc_forcegt_vcf",
              "id": "#main/run_dragen_germline_step/vc_forcegt_vcf"
            },
            {
              "source": "#main/vc_hard_filter",
              "id": "#main/run_dragen_germline_step/vc_hard_filter"
            },
            {
              "source": "#main/vc_max_reads_per_active_region",
              "id": "#main/run_dragen_germline_step/vc_max_reads_per_active_region"
            },
            {
              "source": "#main/vc_max_reads_per_raw_region",
              "id": "#main/run_dragen_germline_step/vc_max_reads_per_raw_region"
            },
            {
              "source": "#main/vc_remove_all_soft_clips",
              "id": "#main/run_dragen_germline_step/vc_remove_all_soft_clips"
            },
            {
              "source": "#main/vc_roh_blacklist_bed",
              "id": "#main/run_dragen_germline_step/vc_roh_blacklist_bed"
            },
            {
              "source": "#main/vc_target_bed",
              "id": "#main/run_dragen_germline_step/vc_target_bed"
            },
            {
              "source": "#main/vc_target_bed_padding",
              "id": "#main/run_dragen_germline_step/vc_target_bed_padding"
            },
            {
              "source": "#main/vc_target_coverage",
              "id": "#main/run_dragen_germline_step/vc_target_coverage"
            }
          ],
          "out": [
            {
              "id": "#main/run_dragen_germline_step/dragen_germline_output_directory"
            },
            {
              "id": "#main/run_dragen_germline_step/dragen_bam_out"
            },
            {
              "id": "#main/run_dragen_germline_step/dragen_vcf_out"
            }
          ],
          "run": "#dragen-germline__4.3.6.cwl",
          "id": "#main/run_dragen_germline_step"
        },
        {
          "label": "dragen qc step",
          "doc": "The dragen qc step - this takes in an array of dirs\n",
          "in": [
            {
              "source": [
                "#main/run_dragen_germline_step/dragen_germline_output_directory",
                "#main/run_dragen_somatic_step/dragen_somatic_output_directory"
              ],
              "id": "#main/run_dragen_qc_step/input_directories"
            },
            {
              "source": [
                "#main/output_prefix_somatic",
                "#main/output_prefix_germline"
              ],
              "valueFrom": "$(self[0])__$(self[1])_dragen_somatic_and_germline_multiqc",
              "id": "#main/run_dragen_qc_step/output_directory_name"
            },
            {
              "source": [
                "#main/output_prefix_somatic",
                "#main/output_prefix_germline"
              ],
              "valueFrom": "$(self[0])__$(self[1])_dragen_somatic_and_germline_multiqc.html",
              "id": "#main/run_dragen_qc_step/output_filename"
            },
            {
              "source": [
                "#main/output_prefix_somatic",
                "#main/output_prefix_germline"
              ],
              "valueFrom": "UMCCR MultiQC Dragen Somatic And Germline Report for $(self[0])__$(self[1])",
              "id": "#main/run_dragen_qc_step/title"
            }
          ],
          "out": [
            {
              "id": "#main/run_dragen_qc_step/output_directory"
            }
          ],
          "run": "#multiqc__1.25.1.cwl",
          "id": "#main/run_dragen_qc_step"
        },
        {
          "label": "run dragen somatic step",
          "doc": "Run dragen somatic v4.3.6\n",
          "in": [
            {
              "source": "#main/bam_input",
              "id": "#main/run_dragen_somatic_step/bam_input"
            },
            {
              "source": "#main/cnv_enable_self_normalization",
              "id": "#main/run_dragen_somatic_step/cnv_enable_self_normalization"
            },
            {
              "source": "#main/cnv_normal_b_allele_vcf",
              "id": "#main/run_dragen_somatic_step/cnv_normal_b_allele_vcf"
            },
            {
              "source": "#main/cnv_normal_cnv_vcf",
              "id": "#main/run_dragen_somatic_step/cnv_normal_cnv_vcf"
            },
            {
              "source": "#main/cnv_population_b_allele_vcf",
              "id": "#main/run_dragen_somatic_step/cnv_population_b_allele_vcf"
            },
            {
              "source": "#main/cnv_somatic_enable_het_calling",
              "id": "#main/run_dragen_somatic_step/cnv_somatic_enable_het_calling"
            },
            {
              "source": "#main/cnv_somatic_enable_lower_ploidy_limit",
              "id": "#main/run_dragen_somatic_step/cnv_somatic_enable_lower_ploidy_limit"
            },
            {
              "source": "#main/cnv_somatic_essential_genes_bed",
              "id": "#main/run_dragen_somatic_step/cnv_somatic_essential_genes_bed"
            },
            {
              "source": "#main/cnv_use_somatic_vc_baf",
              "id": "#main/run_dragen_somatic_step/cnv_use_somatic_vc_baf"
            },
            {
              "source": "#main/cnv_use_somatic_vc_vaf",
              "id": "#main/run_dragen_somatic_step/cnv_use_somatic_vc_vaf"
            },
            {
              "source": "#main/cram_input",
              "id": "#main/run_dragen_somatic_step/cram_input"
            },
            {
              "source": "#main/cram_reference",
              "id": "#main/run_dragen_somatic_step/cram_reference"
            },
            {
              "source": "#main/dbsnp_annotation",
              "id": "#main/run_dragen_somatic_step/dbsnp_annotation"
            },
            {
              "source": [
                "#main/dedup_min_qual_somatic",
                "#main/dedup_min_qual"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_somatic_step/dedup_min_qual"
            },
            {
              "source": [
                "#main/enable_cnv_somatic",
                "#main/enable_cnv"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_somatic_step/enable_cnv"
            },
            {
              "source": [
                "#main/enable_duplicate_marking_somatic",
                "#main/enable_duplicate_marking"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_somatic_step/enable_duplicate_marking"
            },
            {
              "source": "#main/enable_hla",
              "id": "#main/run_dragen_somatic_step/enable_hla"
            },
            {
              "source": "#main/enable_hrd",
              "id": "#main/run_dragen_somatic_step/enable_hrd"
            },
            {
              "source": [
                "#main/enable_map_align_somatic",
                "#main/enable_map_align"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_somatic_step/enable_map_align"
            },
            {
              "source": [
                "#main/enable_map_align_output_somatic",
                "#main/enable_map_align_output"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_somatic_step/enable_map_align_output"
            },
            {
              "source": "#main/enable_rna",
              "id": "#main/run_dragen_somatic_step/enable_rna"
            },
            {
              "source": [
                "#main/enable_sort_somatic",
                "#main/enable_sort"
              ],
              "valueFrom": "${\n    return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_somatic_step/enable_sort"
            },
            {
              "source": [
                "#main/enable_sv_somatic",
                "#main/enable_sv"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_somatic_step/enable_sv"
            },
            {
              "source": "#main/enable_tmb",
              "id": "#main/run_dragen_somatic_step/enable_tmb"
            },
            {
              "source": "#main/fastq_list",
              "id": "#main/run_dragen_somatic_step/fastq_list"
            },
            {
              "source": "#main/fastq_list_rows",
              "id": "#main/run_dragen_somatic_step/fastq_list_rows"
            },
            {
              "source": "#main/hla_allele_frequency_file",
              "id": "#main/run_dragen_somatic_step/hla_allele_frequency_file"
            },
            {
              "source": "#main/hla_bed_file",
              "id": "#main/run_dragen_somatic_step/hla_bed_file"
            },
            {
              "source": "#main/hla_min_reads",
              "id": "#main/run_dragen_somatic_step/hla_min_reads"
            },
            {
              "source": "#main/hla_reference_file",
              "id": "#main/run_dragen_somatic_step/hla_reference_file"
            },
            {
              "source": "#main/hla_tiebreaker_threshold",
              "id": "#main/run_dragen_somatic_step/hla_tiebreaker_threshold"
            },
            {
              "source": "#main/hla_zygosity_threshold",
              "id": "#main/run_dragen_somatic_step/hla_zygosity_threshold"
            },
            {
              "source": "#main/lic_instance_id_location",
              "id": "#main/run_dragen_somatic_step/lic_instance_id_location"
            },
            {
              "source": "#main/output_prefix_somatic",
              "valueFrom": "$(self)_dragen_somatic",
              "id": "#main/run_dragen_somatic_step/output_directory"
            },
            {
              "source": "#main/output_prefix_somatic",
              "id": "#main/run_dragen_somatic_step/output_file_prefix"
            },
            {
              "source": "#main/qc_coverage_ignore_overlaps",
              "id": "#main/run_dragen_somatic_step/qc_coverage_ignore_overlaps"
            },
            {
              "source": "#main/qc_coverage_region_1",
              "id": "#main/run_dragen_somatic_step/qc_coverage_region_1"
            },
            {
              "source": "#main/qc_coverage_region_2",
              "id": "#main/run_dragen_somatic_step/qc_coverage_region_2"
            },
            {
              "source": "#main/qc_coverage_region_3",
              "id": "#main/run_dragen_somatic_step/qc_coverage_region_3"
            },
            {
              "source": "#main/reference_tar",
              "id": "#main/run_dragen_somatic_step/reference_tar"
            },
            {
              "source": "#main/repeat_genotype_enable",
              "id": "#main/run_dragen_somatic_step/repeat_genotype_enable"
            },
            {
              "source": "#main/repeat_genotype_specs",
              "id": "#main/run_dragen_somatic_step/repeat_genotype_specs"
            },
            {
              "source": "#main/repeat_genotype_use_catalog",
              "id": "#main/run_dragen_somatic_step/repeat_genotype_use_catalog"
            },
            {
              "source": "#main/sample_sex",
              "id": "#main/run_dragen_somatic_step/sample_sex"
            },
            {
              "source": "#main/sv_call_regions_bed",
              "id": "#main/run_dragen_somatic_step/sv_call_regions_bed"
            },
            {
              "source": "#main/sv_discovery",
              "id": "#main/run_dragen_somatic_step/sv_discovery"
            },
            {
              "source": "#main/sv_enable_liquid_tumor_mode",
              "id": "#main/run_dragen_somatic_step/sv_enable_liquid_tumor_mode"
            },
            {
              "source": "#main/sv_enable_somatic_ins_tandup_hotspot_regions",
              "id": "#main/run_dragen_somatic_step/sv_enable_somatic_ins_tandup_hotspot_regions"
            },
            {
              "source": "#main/sv_exome",
              "id": "#main/run_dragen_somatic_step/sv_exome"
            },
            {
              "source": "#main/sv_forcegt_vcf",
              "id": "#main/run_dragen_somatic_step/sv_forcegt_vcf"
            },
            {
              "source": "#main/sv_output_contigs",
              "id": "#main/run_dragen_somatic_step/sv_output_contigs"
            },
            {
              "source": "#main/sv_region",
              "id": "#main/run_dragen_somatic_step/sv_region"
            },
            {
              "source": "#main/sv_se_overlap_pair_evidence",
              "id": "#main/run_dragen_somatic_step/sv_se_overlap_pair_evidence"
            },
            {
              "source": "#main/sv_somatic_ins_tandup_hotspot_regions_bed",
              "id": "#main/run_dragen_somatic_step/sv_somatic_ins_tandup_hotspot_regions_bed"
            },
            {
              "source": "#main/sv_tin_contam_tolerance",
              "id": "#main/run_dragen_somatic_step/sv_tin_contam_tolerance"
            },
            {
              "source": "#main/tmb_db_threshold",
              "id": "#main/run_dragen_somatic_step/tmb_db_threshold"
            },
            {
              "source": "#main/tmb_vaf_threshold",
              "id": "#main/run_dragen_somatic_step/tmb_vaf_threshold"
            },
            {
              "source": "#main/tumor_bam_input",
              "id": "#main/run_dragen_somatic_step/tumor_bam_input"
            },
            {
              "source": "#main/tumor_cram_input",
              "id": "#main/run_dragen_somatic_step/tumor_cram_input"
            },
            {
              "source": "#main/tumor_fastq_list",
              "id": "#main/run_dragen_somatic_step/tumor_fastq_list"
            },
            {
              "source": "#main/tumor_fastq_list_rows",
              "id": "#main/run_dragen_somatic_step/tumor_fastq_list_rows"
            },
            {
              "source": "#main/vc_af_call_threshold",
              "id": "#main/run_dragen_somatic_step/vc_af_call_threshold"
            },
            {
              "source": "#main/vc_af_call_threshold_mito",
              "id": "#main/run_dragen_somatic_step/vc_af_call_threshold_mito"
            },
            {
              "source": "#main/vc_af_filter_threshold",
              "id": "#main/run_dragen_somatic_step/vc_af_filter_threshold"
            },
            {
              "source": "#main/vc_af_filter_threshold_mito",
              "id": "#main/run_dragen_somatic_step/vc_af_filter_threshold_mito"
            },
            {
              "source": [
                "#main/vc_base_qual_threshold_somatic",
                "#main/vc_base_qual_threshold"
              ],
              "valueFrom": "${\n  return get_first_non_null_input(self);\n}\n",
              "id": "#main/run_dragen_somatic_step/vc_base_qual_threshold"
            },
            {
              "source": "#main/vc_callability_normal_thresh",
              "id": "#main/run_dragen_somatic_step/vc_callability_normal_thresh"
            },
            {
              "source": "#main/vc_callability_tumor_thresh",
              "id": "#main/run_dragen_somatic_step/vc_callability_tumor_thresh"
            },
            {
              "source": "#main/vc_combine_phased_variants_distance_somatic",
              "id": "#main/run_dragen_somatic_step/vc_combine_phased_variants_distance"
            },
            {
              "source": "#main/vc_combine_phased_variants_max_vaf_delta_somatic",
              "id": "#main/run_dragen_somatic_step/vc_combine_phased_variants_max_vaf_delta"
            },
            {
              "source": "#main/vc_decoy_contigs",
              "id": "#main/run_dragen_somatic_step/vc_decoy_contigs"
            },
            {
              "source": "#main/vc_enable_af_filter",
              "id": "#main/run_dragen_somatic_step/vc_enable_af_filter"
            },
            {
              "source": "#main/vc_enable_baf",
              "id": "#main/run_dragen_somatic_step/vc_enable_baf"
            },
            {
              "source": "#main/vc_enable_decoy_contigs",
              "id": "#main/run_dragen_somatic_step/vc_enable_decoy_contigs"
            },
            {
              "source": "#main/vc_enable_gatk_acceleration",
              "id": "#main/run_dragen_somatic_step/vc_enable_gatk_acceleration"
            },
            {
              "source": "#main/vc_enable_liquid_tumor_mode",
              "id": "#main/run_dragen_somatic_step/vc_enable_liquid_tumor_mode"
            },
            {
              "source": "#main/vc_enable_non_homref_normal_filter",
              "id": "#main/run_dragen_somatic_step/vc_enable_non_homref_normal_filter"
            },
            {
              "source": "#main/vc_enable_non_primary_allelic_filter",
              "id": "#main/run_dragen_somatic_step/vc_enable_non_primary_allelic_filter"
            },
            {
              "source": "#main/vc_enable_orientation_bias_filter",
              "id": "#main/run_dragen_somatic_step/vc_enable_orientation_bias_filter"
            },
            {
              "source": "#main/vc_enable_orientation_bias_filter_artifacts",
              "id": "#main/run_dragen_somatic_step/vc_enable_orientation_bias_filter_artifacts"
            },
            {
              "source": "#main/vc_enable_phasing",
              "id": "#main/run_dragen_somatic_step/vc_enable_phasing"
            },
            {
              "source": "#main/vc_enable_roh",
              "id": "#main/run_dragen_somatic_step/vc_enable_roh"
            },
            {
              "source": "#main/vc_enable_triallelic_filter",
              "id": "#main/run_dragen_somatic_step/vc_enable_triallelic_filter"
            },
            {
              "source": "#main/vc_enable_unequal_ntd",
              "id": "#main/run_dragen_somatic_step/vc_enable_unequal_ntd"
            },
            {
              "source": "#main/vc_enable_vcf_output",
              "id": "#main/run_dragen_somatic_step/vc_enable_vcf_output"
            },
            {
              "source": "#main/vc_hard_filter",
              "id": "#main/run_dragen_somatic_step/vc_hard_filter"
            },
            {
              "source": "#main/vc_hotspot_log10_prior_boost",
              "id": "#main/run_dragen_somatic_step/vc_hotspot_log10_prior_boost"
            },
            {
              "source": "#main/vc_max_reads_per_active_region",
              "id": "#main/run_dragen_somatic_step/vc_max_reads_per_active_region"
            },
            {
              "source": "#main/vc_max_reads_per_raw_region",
              "id": "#main/run_dragen_somatic_step/vc_max_reads_per_raw_region"
            },
            {
              "source": "#main/vc_min_tumor_read_qual",
              "id": "#main/run_dragen_somatic_step/vc_min_tumor_read_qual"
            },
            {
              "source": "#main/vc_mnv_emit_component_calls_somatic",
              "id": "#main/run_dragen_somatic_step/vc_mnv_emit_component_calls"
            },
            {
              "source": "#main/vc_remove_all_soft_clips",
              "id": "#main/run_dragen_somatic_step/vc_remove_all_soft_clips"
            },
            {
              "source": "#main/vc_roh_blacklist_bed",
              "id": "#main/run_dragen_somatic_step/vc_roh_blacklist_bed"
            },
            {
              "source": "#main/vc_somatic_hotspots",
              "id": "#main/run_dragen_somatic_step/vc_somatic_hotspots"
            },
            {
              "source": "#main/vc_sq_call_threshold",
              "id": "#main/run_dragen_somatic_step/vc_sq_call_threshold"
            },
            {
              "source": "#main/vc_sq_filter_threshold",
              "id": "#main/run_dragen_somatic_step/vc_sq_filter_threshold"
            },
            {
              "source": "#main/vc_target_bed",
              "id": "#main/run_dragen_somatic_step/vc_target_bed"
            },
            {
              "source": "#main/vc_target_bed_padding",
              "id": "#main/run_dragen_somatic_step/vc_target_bed_padding"
            },
            {
              "source": "#main/vc_target_coverage",
              "id": "#main/run_dragen_somatic_step/vc_target_coverage"
            },
            {
              "source": "#main/vc_target_vaf_somatic",
              "id": "#main/run_dragen_somatic_step/vc_target_vaf"
            },
            {
              "source": "#main/vc_tin_contam_tolerance",
              "id": "#main/run_dragen_somatic_step/vc_tin_contam_tolerance"
            }
          ],
          "out": [
            {
              "id": "#main/run_dragen_somatic_step/dragen_somatic_output_directory"
            },
            {
              "id": "#main/run_dragen_somatic_step/tumor_bam_out"
            },
            {
              "id": "#main/run_dragen_somatic_step/normal_bam_out"
            },
            {
              "id": "#main/run_dragen_somatic_step/somatic_snv_vcf_out"
            },
            {
              "id": "#main/run_dragen_somatic_step/somatic_snv_vcf_hard_filtered_out"
            },
            {
              "id": "#main/run_dragen_somatic_step/somatic_structural_vcf_out"
            }
          ],
          "run": "#dragen-somatic__4.3.6.cwl",
          "id": "#main/run_dragen_somatic_step"
        }
      ],
      "outputs": [
        {
          "label": "dragen germline output directory",
          "doc": "The output directory containing all germline output files\n",
          "type": "Directory",
          "outputSource": "#main/run_dragen_germline_step/dragen_germline_output_directory",
          "id": "#main/dragen_germline_output_directory"
        },
        {
          "label": "dragen somatic output directory",
          "doc": "Output directory containing all outputs of the somatic dragen run\n",
          "type": "Directory",
          "outputSource": "#main/run_dragen_somatic_step/dragen_somatic_output_directory",
          "id": "#main/dragen_somatic_output_directory"
        },
        {
          "label": "germline snv vcf out",
          "doc": "The output vcf file of germline step\n",
          "type": [
            "null",
            "File"
          ],
          "outputSource": "#main/run_dragen_germline_step/dragen_vcf_out",
          "id": "#main/germline_snv_vcf_out"
        },
        {
          "label": "multiqc output directory",
          "doc": "The output directory for multiqc\n",
          "type": "Directory",
          "outputSource": "#main/run_dragen_qc_step/output_directory",
          "id": "#main/multiqc_output_directory"
        },
        {
          "label": "output normal bam",
          "doc": "Bam file of the normal sample\n",
          "type": [
            "null",
            "File"
          ],
          "outputSource": "#main/get_normal_bam_out/output_bam_file",
          "id": "#main/normal_bam_out"
        },
        {
          "label": "somatic snv vcf filetered",
          "doc": "Output of the snv vcf filtered tumor calls\n",
          "type": [
            "null",
            "File"
          ],
          "outputSource": "#main/run_dragen_somatic_step/somatic_snv_vcf_hard_filtered_out",
          "id": "#main/somatic_snv_vcf_hard_filtered_out"
        },
        {
          "label": "somatic snv vcf",
          "doc": "Output of the snv vcf tumor calls\n",
          "type": [
            "null",
            "File"
          ],
          "outputSource": "#main/run_dragen_somatic_step/somatic_snv_vcf_out",
          "id": "#main/somatic_snv_vcf_out"
        },
        {
          "label": "somatic sv vcf filetered",
          "doc": "Output of the sv vcf filtered tumor calls.\nExists only if --enable-sv is set to true.\n",
          "type": [
            "null",
            "File"
          ],
          "outputSource": "#main/run_dragen_somatic_step/somatic_structural_vcf_out",
          "id": "#main/somatic_structural_vcf_out"
        },
        {
          "label": "output tumor bam",
          "doc": "Bam file of the tumor sample\n",
          "type": [
            "null",
            "File"
          ],
          "outputSource": "#main/run_dragen_somatic_step/tumor_bam_out",
          "id": "#main/tumor_bam_out"
        }
      ],
      "https://schema.org/author": {
        "class": "https://schema.org/Person",
        "https://schema.org/name": "Alexis Lucattini",
        "https://schema.org/email": "Alexis.Lucattini@umccr.org",
        "https://schema.org/identifier": "https://orcid.org/0000-0001-9754-647X"
      }
    }
  ],
  "cwlVersion": "v1.1",
  "$schemas": [
    "https://schema.org/version/latest/schemaorg-current-http.rdf"
  ],
  "$namespaces": {
    "s": "https://schema.org/"
  }
}